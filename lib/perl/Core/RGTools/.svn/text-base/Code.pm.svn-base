################################################################################
# Code.pm
#
# This object represents a Perl source code.  It has the ability to insert Perldoc and re-organize a source file.
#
###################################################################################################################################
# $Id: Code.pm,v 1.36 2004/08/27 18:26:55 rguin Exp $
###################################################################################################################################
package Code;

##############################
# perldoc_header             #
##############################

=head1 NAME <UPLINK>

Code.pm - This object represents a Perl source code.  It has the ability to insert Perldoc and re-organize a source file.

=head1 SYNOPSIS <UPLINK>

 my $code = Code->new('Code.pm');   # Create a new Code object with the specified source
 $code->define_custom_modules(-dirs=>['alDente','SDB','RGTools']); #Define custom modules
 $code->generate_code(-perldoc=>2); # Generate the code (insert perldoc and re-organize)
 $code->save_code(-overwrite=>1);   # Save the generated code

=head1 DESCRIPTION <UPLINK>

=for html
This object represents a Perl source code.  It has the ability to insert Perldoc and re-organize a source file.<BR>

=cut

##############################
# superclasses               #
##############################
##############################
# system_variables           #
##############################
##############################
# standard_modules_ref       #
##############################
use strict;
use Data::Dumper;
use Cwd 'abs_path';

##############################
# custom_modules_ref         #
##############################
use RGTools::RGIO;

##############################
# global_vars                #
##############################
##############################
# modular_vars               #
##############################
##############################
# constants                  #
##############################
##############################
# main_header                #
##############################
my $file;
my %Referenced;

##############################
# constructor                #
##############################

#
# Adjust input to separately specify directory and file name...
#
#
##########
sub new {
##########
    my $this = shift;
    $file = shift;
    my %args = @_;

    my $dir  = $args{-dir};
    my $ext  = $args{-ext};
    my $name = $args{-filename};
    my $method = $args{-method};

    my ($class) = ref($this) || $this;
    my ($self) = {};

    $self->{dir} = $dir;
    $self->{ext} = $ext;

    if ($name) {
        if ( $name =~ /(.*)\.(.*)/ ) {
            $self->{name} = $1;
            $self->{ext}  = $2;
        }
        else {
            $self->{name} = $name;
            $self->{ext}  = '';
        }
    }
    elsif ( $file =~ /(.*\/)(.*)\.(.*)/ ) {

        $self->{dir}         = abs_path($1) . "/";    #Dir of the code [String]
        $self->{name}        = "$2.$3";               #Name of the file [String]
        $self->{module_name} = $2;                    #Name of module [String]
        $self->{ext}         = $3;                    #Extension of the code [String]
    }
    else {
        print "Error Undefined file\n";
    }

    $self->{fullname}          = "$self->{dir}$self->{name}";    #The full name of the file including dir [String]
    $self->{brief_description} = '';                             #A brief description of the code (i.e. the first line of the description found at the top of the file) [String]
    $self->{description}       = '';                             #The description of code at the top of the file.

    $self->{code}           = '';                                #The entire source code read from the source file [without the perldoc String]
    $self->{perldoc}        = {};                                #The current perldoc of the source file
    $self->{generated_code} = '';                                #The entire source code regenerated by this script [String]

    $self->{perl_interpreter}   = {};                            #Perl interpreter [Hash]
    $self->{package_definition} = {};                            #Package definition [Hash]
    $self->{superclasses}       = {};                            #Superclasses as in the @ISA array [Hash]
    $self->{perldoc_header}     = {};                            #Perldoc header [Hash]
    $self->{perldoc_footer}     = {};                            #Perldoc footer [Hash]

    $self->{standard_modules_ref} = {};                          #References to Perl modules [Hash]
    $self->{custom_modules_ref}   = {};                          #References to custom modules [Hash]
    $self->{custom_modules}       = {};                          #Define custom modules [Hash]
    $self->{global_vars}          = {};                          #Global variables used [Hash]
    $self->{modular_vars}         = {};                          #Modular level variables [Hash]
    $self->{constants}            = {};                          #Constants used [Hash]
    $self->{main_header}          = {};                          #Main body header of the code [Hash]
    $self->{main_footer}          = {};                          #Main body footer of the code [Hash]
    $self->{attributes}           = {};                          #All the attributes of the class [Hash]

    $self->{constructor}       = {};                             #Constructor of the class [Hash]
    $self->{public_methods}    = {};                             #Public methods of the class [Hash]
    $self->{public_functions}  = {};                             #Public functions of the class [Hash]
    $self->{private_methods}   = {};                             #Private methods of the class [Hash]
    $self->{private_functions} = {};                             #Private functions of the class [Hash]

    $self->{method} = $method;
    $self->{sections_order} = [
        'perl_interpreter', 'package_definition', 'perldoc_header', 'superclasses',     'system_variables', 'standard_modules_ref', 'custom_modules_ref', 'global_vars', 'modular_vars', 'constants',
        'main_header',      'constructor',        'public_methods', 'public_functions', 'private_methods',  'private_functions',    'main_footer',        'perldoc_footer'
    ];                                                           #The order of sections to be appeared in the code. [ArrayRef]

    $self->{blocks}  = {};                                       # Blocks of the code [Hash]
    $self->{indexes} = {};                                       # Index hash of various properties [Hash]

    bless $self, $class;

    if ( $self->{name} ) {
        $self->load_code( $method);
    }
    return $self;
}

##############################
# public_methods             #
##############################

#####################################################################
sub load_code {
#####################################################################
    #
    # Loads the code from the file
    #
    my $self = shift;
    my $method = shift;
    
    if ( -f $self->{fullname} ) {
        open( FILE, $self->{fullname} ) || die("Cannot open $self->{fullname}");

        my $inside_perldoc        = 0;    #Flag to indicate whether we are inside a Perldoc section or not
        my $non_comments_found    = 0;    #Flag to indicate whether a non-comments line is found.
        my $desc_first_line_found = 0;    #Flag to indicate whether the first line of description is found.
        
        my ($started, $ended) = (0,0);  ## only used if loading single module 
        while (<FILE>) {
            my $line = $_;
            
            if ($method) {
                ## if only loading code from a single method ##
                if ($line =~ /^sub\s+$method /) { $started=1 }
                elsif ($started && $line =~/^sub\s+\w+/) { $ended=1 }
#                print "$line [ $started : $ended ]\n";
                if (!$started || $ended) { next }
            }
            
            if ( $line =~ /^=cut/ ) {
                $self->{perldoc}->{code} .= $line;
                $inside_perldoc = 0;
            }
            elsif ( $line =~ /^=/ ) {
                $self->{perldoc}->{code} .= $line;
                $inside_perldoc = 1;
            }
            elsif ($inside_perldoc) {
                $self->{perldoc}->{code} .= $line;
            }
            else {
                $self->{code} .= $line;
                unless ($non_comments_found) {
                    if ( $line =~ /^\s*\#+(.*)/ ) {
                        my $desc = $1;
                        if ( $desc =~ /\S/ && $desc !~ /^\s*$self->{module_name}(?:\.$self->{ext})*\s*\#*\s*$/i && $desc !~ /\$Id.*Exp\s*\$/i && $desc !~ /CVS.*\$Revision.*\$/i && $desc !~ /CVS.*\$Date.*\$/i ) {
                            $desc =~ s/^\s*(.*)\s*$/$1/;    #Get rid of leading and trailing spaces
                            $self->{description} .= "$desc\n";
                            unless ($desc_first_line_found) {
                                $self->{brief_description} .= "$desc\n";    #Get the first line of the description be the brief description
                                $desc_first_line_found = 1;
                            }
                        }
                    }
                    elsif ( $line =~ /^\s*[^\#]/ && $line !~ /^\s*$/ ) {
                        $non_comments_found = 1;
                    }
                }
            }
        }

        close(FILE);
    }

    foreach my $section ( @{ $self->{sections_order} } ) {
        my $section_label = _section_label($section);
        $self->{code} =~ s/$section_label//g;    ### remove previously generated section labels.
    }

    return;

}

#
# Access description of code if it exists...
#
#
###############
sub description {
###############
    my $self = shift;
    my %args = @_;

    my $verbose = $args{-verbose};
    if ($verbose) {
        return $self->{description};
    }
    else {
        return $self->{brief_description};
    }
}

#####################################################################
sub define_custom_modules {
#####################################################################
    #
    # Defines what custom modules are
    #
    my $self = shift;
    my %args = @_;

    my $dirs_ref  = $args{-dirs};     # Define custom modules by directories [ArrayRef]
    my $files_ref = $args{-files};    # Define custom modules by files [ArrayRef]

    foreach my $dir ( @{$dirs_ref} ) {
        $self->{custom_modules}->{dirs}->{$dir} = 1;
    }

    foreach my $file ( @{$files_ref} ) {
        $self->{custom_modules}->{files}->{$file} = 1;
    }
    return;
}

#####################################################################
sub parse_perldoc {
#####################################################################
    #
    # Parse the =head1 sections of the current perldoc into a hash
    #
    my $self = shift;

    my $current_command = '';    # Stores the current perldoc command
    foreach my $line ( split /\n/, $self->{perldoc}->{code} ) {
        if ( $line =~ /^=head1\s+([A-Z\s_]+).*/ ) {
            my $command = $1;
            $command =~ s/(.*)\s+$/$1/;    #Get rid of trailing space.
            $self->{perldoc}->{commands}->{$command} .= "$line\n";
            $current_command = $command;
        }
        elsif ( $line =~ /^=/ ) {          #Any perldoc commands not starting with '=head1'
            $current_command = '';
        }
        elsif ($current_command) {
            $self->{perldoc}->{commands}->{$current_command} .= "$line\n";
        }
        else { }
    }
}

#################
sub get_attributes {
#################
    my $self = shift;
    my %args = @_;

    my $verbose = $args{'-verbose'};
    my $format = $args{'-format'} || 'text';

    my @attributes = keys %{ $self->{attributes} };

    if ($verbose) {
        my @details;
        foreach my $attribute (@attributes) {
            if ( $format =~ /html/ ) {
                push( @details, "<B>$attribute</B><P>" . $self->{attributes}->{$attribute}->{description} );
            }
            else {
                push( @details, "$attribute\n*****\n" . $self->{attributes}->{$attribute}->{description} . "\n" );
            }
        }
        return \@details;
    }
    return \@attributes;
}

##############
sub get_methods {
##############
    my $self = shift;
    my %args = @_;

    my $verbose = $args{-verbose};
    my $format = $args{'-format'} || 'text';

    my @methods = keys %{ $self->{public_methods} };

    if ($verbose) {
        my @details;
        foreach my $method (@methods) {
            my $code = $self->{public_methods}->{$method}->{code};
            my $comments = $self->get_comments( -code => $code, -direction => 'fwd' );

            if ( $format =~ /html/ ) {
                $comments =~ s/\n/<BR>/g;
                push( @details, "<B>$method</B><P>$comments" );
            }
            else {
                push @details, "$method\n******************\n$comments\n";
            }
        }
        return \@details;
    }

    return \@methods;
}

####################
sub get_run_modes {
####################
    my $file = shift;

    my @run_modes;
    
    my $Code = Code->new($file, -method=>'setup');
    $Code->{code} =~ /run_modes\((.+?)\);/xms;
    my @run_modes = split /\s*\n\s*/, $1;
       
    my %Run_mode;
    foreach my $run_mode ( @run_modes) {
        if ($run_mode =~ /['"](.+?)["']\s*=>\s*['"](.+)['""']/) {
            $Run_mode{$1} = $2;
        }
    } 

    return \%Run_mode;
}

#####################################################################
sub get_blocks {
#####################################################################
    #
    #Parse the entire code base and extract blocks of code
    #
    my $self = shift;

    my $inside_sub          = 0;    #Flag indicating whether we are inside a sub.
    my $open_bracket_count  = 0;    #Number of open brackets encountered
    my $close_bracket_count = 0;    #Number of close brackets encounted
    my $i                   = 1;    #Index of the blocks
    my %temp_blocks;

    my $line_number = 0;
    foreach my $line ( split /\n/, $self->{code} ) {
        $line_number++;
        if ( $line =~ /^\s*sub\s+(\w+)\s*\{/ ) {    #look for beginning of a sub
            $open_bracket_count++;
            $inside_sub = 1;
            $i++;

            $self->{blocks}->{$i}->{type}        = 'sub';
            $self->{blocks}->{$i}->{line_number} = $line_number;

            my $comments = $self->get_comments(
                -code        => $self->{code},
                -line_number => $line_number
            );
            my $comment_lines = 0;
            if ($comments) {
                $comment_lines = int( my @list = split "\n", $comments );
            }

            $self->{blocks}->{$i}->{line_number} = $line_number - $comment_lines;
            $self->{blocks}->{$i}->{code}        = "$comments$line\n";

            if ( $i == 2 ) {    ## first one after header...
                $self->{blocks}->{1}->{code} =~ s /$comments$//;    ## remove comments from end of first block
                                                                    #print $self->{blocks}->{1}->{code};
            }

        }
        elsif ( !$inside_sub && $line =~ /\s*(\S)/ ) {
            ## put all code found BETWEEN subroutines at the beginning (block 1)
            if ( ( $i > 1 ) && ( $1 =~ /^\#/ ) ) {
                next;
            }    ## leave mid routine comments...
            elsif ( $line =~ /^\s*return/ ) {
                next;
            }    ## do not include return statement in mid-routine code
            $self->{blocks}->{1}->{code} .= "$line\n";
            $self->{blocks}->{1}->{type}        = 'non_sub';
            $self->{blocks}->{1}->{line_number} = 1;
        }
        elsif ($inside_sub) {
            $self->{blocks}->{$i}->{code} .= "$line\n";
            $line =~ s/\\\#//g;    ## remove escaped hashes so comments can be id'd
            $line =~ s/\$\#//g;    ## remove hashes right after dollar signs so can properly count brackets
            if ( $line =~ /(.*?)\#/ ) {
                $line = $1;
            }                      ## do not include the comments for bracket counting

            $open_bracket_count  += () = $line =~ /\{/g;
            $close_bracket_count += () = $line =~ /\}/g;

            $open_bracket_count  -= () = $line =~ /\\\{/g;    ## exclude escaped brackets (sheesh...)
            $close_bracket_count -= () = $line =~ /\\\}/g;

            if ( $open_bracket_count == $close_bracket_count ) {    #if number of open anc close brackets matched then we found the end of a sub
                $inside_sub                  = 0;
                $open_bracket_count          = 0;
                $close_bracket_count         = 0;
                $self->{blocks}->{$i}->{end} = $line_number;
            }
        }
    }
}

#####################################################################
sub parse_blocks {
#####################################################################
    #
    #Parse the blocks and extract information
    #
    my $self    = shift;
    my %args    = @_;
    my $perldoc = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    my $i = 0;
    foreach my $block ( sort { $a <=> $b } keys %{ $self->{blocks} } ) {
        my $code           = $self->{blocks}->{$block}->{code};
        my $type           = $self->{blocks}->{$block}->{type};
        my $line_number    = $self->{blocks}->{$block}->{line_number};
        my $secondary_type = $self->{blocks}->{$block}->{secondary_type};
        if ( $type =~ /\bsub\b/ ) {
            ## for now skip pre-code for first sub (included in header block
            $self->parse_sub(
                -code          => $code,
                -perldoc       => 2,
                -line_number   => $line_number,
                -skip_pre_code => !$i
            );
            $i++;
        }
        elsif ( $type =~ /non_sub/ ) {
            $self->parse_non_sub(
                -code           => $code,
                -perldoc        => 2,
                -secondary_type => $secondary_type
            );
        }
    }
}

#####################################################################
sub parse_sub {
#####################################################################
    #
    # Parse a sub and extract infomation
    #
    my $self = shift;
    my %args = @_;

    my $code          = $args{-code};
    my $line_number   = $args{-line_number};
    my $skip_pre_code = $args{-skip_pre_code};    ## ignore comments prior to block

    my $perldoc = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    my $type = $self->get_sub_type( -code => $code );
    my $i = () = keys %{ $self->{$type} };
    $i++;

    my $name = $self->get_sub_name( -code => $code );
    $self->{indexes}->{$type}->{$i} = $name;
    ( $self->{$type}->{$name}->{description}, $self->{$type}->{$name}->{code_snip} ) = $self->get_sub_description_and_code_snip( -code => $code );

    $self->{$type}->{$name}->{code} = "$code\n";

    my ( $args_ref, $args_index_ref ) = $self->get_sub_arguments( -code => $code );
    %{ $self->{$type}->{$name}->{arguments} } = %{$args_ref};
    %{ $self->{$type}->{$name}->{indexes}->{arguments} } = %{$args_index_ref};

    if ( $type =~ /constructor/i ) {
        my ( $att_ref, $att_index_ref ) = $self->_get_attributes( -code => $code );
        %{ $self->{attributes} } = %{$att_ref};
        %{ $self->{indexes}->{attributes} } = %{$att_index_ref};
    }

    if ($perldoc) {    ## && $type !~ /private/i) { # Only generate perldoc if scope is not private
        print "parse $name : $type ($i)\n";
        if ( $type =~ /private/ ) {
            unless ( $Referenced{$name} ) {return}
        }

        if ( $i == 1 ) {    #If we are dealing with the first sub of the type, then we need to insert the perldoc header and footer for the section.
            my $phi = 1;
            my $pfi = 1;

            if ( $type =~ /constructor/i ) {    # If we are dealing with constructor then also need to build perldoc for attributes.
                $self->{$type}->{perldoc_header}->{ $phi++ } = "=head2 ATTRIBUTES <UPLINK>";

                my $att_text;
                my $att_count = () = keys %{ $self->{indexes}->{attributes} };
                if ( $att_count > 0 ) {
                    $att_text .= "=over";

                    my $att_pi = 1;
                    foreach my $att ( keys %{ $self->{indexes}->{attributes} } ) {
                        my $att_name = $self->{indexes}->{attributes}->{$att};
                        $self->{attributes}->{$att_name}->{perldoc}->{ $att_pi++ } = "=item $att_name ($self->{attributes}->{$att_name}->{type})";
                        my $desc = $self->{attributes}->{$att_name}->{description};
                        if ($desc) { $desc .= ' ' }
                        $self->{attributes}->{$att_name}->{perldoc}->{ $att_pi++ } = $desc . "[Default = $self->{attributes}->{$att_name}->{default}]";
                        $att_text .= $self->generate_perldoc( $self->{attributes}->{$att_name}->{perldoc} );
                    }

                    $att_text .= "=back";
                }
                else {
                    $att_text = "None\n";
                }

                $self->{$type}->{perldoc_header}->{ $phi++ } = $att_text;
                $self->{$type}->{perldoc_header}->{ $phi++ } = "=cut";
            }

            my $type_name = $type;
            $type_name =~ tr/a-z/A-Z/;    # Translate the type to all upper case
            $type_name =~ s/_/ /g;        # Replace underscores with space

            $self->{$type}->{perldoc_header}->{ $phi++ } = "=head2 $type_name <UPLINK>\n\n";

            #	    if ($type =~/public_(methods|functions)/) {
            #		print "(+$name)";
            #		$self->{$type}->{perldoc_header}->{1} .= "=for html <font size='-1'><strong><A href='#$name'>$name; </A></strong></font><BR>\n";
            #	    }
            $self->{$type}->{perldoc_header}->{ $phi++ } = "=over";

            $self->{$type}->{perldoc_footer}->{ $pfi++ } = "=back";
            $self->{$type}->{perldoc_footer}->{ $pfi++ } = "=cut";
        }
        ### Add links to public_methods.. ###
        if ( $type =~ /public_(functions|methods)/ ) {
            $self->{$type}->{perldoc_header}->{1} .= "=for html <font size='-1'><strong><A href='#$name'>$name; </A></strong></font><BR>\n\n";
        }

        my $pi = 1;
        $self->{$type}->{$name}->{perldoc}->{ $pi++ } = "\n=for html <A NAME='$name'>\n\n=item $name\n";
        my $args_text = "=for html\n";
        $args_text .= "<B>Arguments:</B><BR>\n********************<BR>\n";
        my $args_count = ()
            = keys %{ $self->{$type}->{$name}->{indexes}->{arguments} };
        if ( $args_count > 0 ) {
            $args_text .= "<Font size =-2>";
            foreach my $arg (
                sort { $a <=> $b }
                keys %{ $self->{$type}->{$name}->{indexes}->{arguments} }
                )
            {
                my $arg_name = $self->{$type}->{$name}->{indexes}->{arguments}->{$arg};
                my $last_arg = 1 unless ( defined $self->{$type}->{$name}->{indexes}->{arguments}->{ $arg + 1 } );

                #		if ($self->{$type}->{$name}->{arguments}->{$arg_name}->{pre_comments}) {
                #		    $args_text .= "<Font color=blue>$self->{$type}->{$name}->{arguments}->{$arg_name}->{pre_comments}</Font><BR>\n"; #Default value
                #		}
                $args_text .= "- <B>$arg_name</B>($self->{$type}->{$name}->{arguments}->{$arg_name}->{type}): ";    # Name (Type)
                my $desc = $self->{$type}->{$name}->{arguments}->{$arg_name}->{description};
                if ($desc) { $desc .= ' ' }
                $args_text .= $desc;
                $args_text .= " [Default = <B>$self->{$type}->{$name}->{arguments}->{$arg_name}->{default}</B>]<BR>\n";    # Default value
                if ( $self->{$type}->{$name}->{arguments}->{$arg_name}->{post_comments} ) {
                    $args_text .= "$self->{$type}->{$name}->{arguments}->{$arg_name}->{post_comments}\n";                  #Default value
                }
            }
            $args_text .= "</Font>";
        }
        else {
            $args_text .= "- None<BR>\n";
        }

        my $sub_desc;
        $sub_desc = $self->{$type}->{$name}->{description};

        #$sub_desc =~ s/\n{1}/\n\n/g; #Make sure each line of the description is separted by a blank line in the perldoc
        $sub_desc =~ s/\n/<BR>/g;    #Replace newline characters with <BR> tags.
        $sub_desc                                     = "=for html\n$sub_desc";
        $self->{$type}->{$name}->{perldoc}->{ $pi++ } = $sub_desc;
        $self->{$type}->{$name}->{perldoc}->{ $pi++ } = $self->{$type}->{$name}->{code_snip};
        $self->{$type}->{$name}->{perldoc}->{ $pi++ } = "$args_text<BR>\n";
        $self->{$type}->{$name}->{perldoc}->{ $pi++ } = "=cut";
    }
    return;
}

#####################################################################
sub get_sub_name {
#####################################################################
    #
    #Parse a sub and get the name of the sub.
    #Returns: Name of the sub [String]
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    $code =~ /.*^\s*sub\s+(\w+)\s*\{/ms;

    return $1;
}

#####################################################################
sub get_sub_description_and_code_snip {
#####################################################################
    #
    # Parse a sub and get the description and code snip
    # Returns: An array that contains the description of the sub [String] and code snip [String]
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my $description      = '';
    my $code_snip        = '';
    my $inside_code_snip = 0;    # Flag to indicate whether we are inside a code snip section;

    my $all_description = $self->get_comments( -code => $code, -direction => 'rev' ) . $self->get_comments( -code => $code, -direction => 'forward' );

    foreach my $line ( split /\n/, $all_description ) {
        if ( $line =~ /^\s*\#+\s*<snip>/i ) {
            $inside_code_snip = 1;
        }
        elsif ( $line =~ /^\s*\#+\s*<\/snip>/i ) {
            $inside_code_snip = 0;
        }
        elsif ( $line =~ /^\s*\#+(\s*)(.*[a-zA-Z0-9]+.*)/ ) {
            if ($inside_code_snip) {
                $code_snip .= " $2\n";
            }
            else {
                $description .= "$2\n";
            }
        }
        elsif ( $line =~ /^\s*\#{1}\s*$/ ) {
            if ($inside_code_snip) {
                $code_snip .= " \n";
            }
            else {
                $description .= "\n";
            }
        }
    }

    return ( $description, $code_snip );
}

#####################################################################
sub get_sub_type {
#####################################################################
    #
    #Parse a sub and get the type of the sub
    #Returns: The type of the sub [String]
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    $code =~ /.*^\s*sub\s+(\w+)\s*\{/ms;
    my $scope;
    my $name = $1;
    if ( $name =~ /^_.*/ ) {
        $scope = 'private';
    }
    else {
        $scope = 'public';
    }

    my $type;
    if ( $name =~ /\bnew\b/i || $code =~ /.*^\s*bless\s+(?:\$self|\$this).*/ms ) {
        $type = 'constructor';
    }
    elsif ( $code =~ /.*^\s*my\s+(?:\$self|\$this)\s*=\s*shift\s*;.*/ms ) {
        $type = $scope . "_methods";
    }
    else {
        $type = $scope . "_functions";
    }

    return $type;
}

#####################################################################
sub get_sub_arguments {
#####################################################################
    #
    # Parse a sub and get the arguments of the sub;
    # Returns: An array that contains the arguments of the sub [HashRef] and the index to those arguments [HashRef]
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};
    my $sub_name = $args{-name} || 0;

    my %arguments;
    my %arguments_index;
    my $args_hash_found = '';

    my $i = 1;

    my $start = 0;
    my $done  = 0;
    foreach my $line ( split /\n/, $code ) {
        if ( $line =~ /^\s*$/ ) {next}    ## Ignore blank lines ##
        if ( $sub_name && $line =~ /^sub $sub_name / ) {    ## if this subroutine was specifically asked for, we have found it.
            $start = 1;
        }
        elsif ( $sub_name && $line =~ /^sub / ) {           ## .. or if we have specified a name, and a new subroutine is found.
            if ($start) {
                last;
            }                                               # (we already found the routine required so we are done)
            else {
                next;
            }                                               # (we haven't found the desired routine yet, so keep looking)
        }
        elsif ( $sub_name && !$start ) {
            next;
        }    ## .. or if we have specified a name and it has not yet been found, keep looking
        else {
            $start = 1;
        }    ## .. or else we are looking in the right spot .. (keep going)...

        if ( $line =~ /^\s*(?:my|local)\s+(\$self|\$this)\s*=\s*shift\s*;.*/ ) {    # Do not count '$self=shift' and '$this=shift' as argument
            next;
        }
        elsif ( $start && !$done && defined $arguments_index{ $i - 1 } && $line =~ /^\s*(\#.*)$/ ) {
            ## include comments if inside argument list block... ##
            my $comment = $1;
            my $name    = $arguments_index{ $i - 1 };
            if ( $comment =~ /\S/ ) {
                $arguments{$name}{post_comments} .= "## <Font color=blue>$comment</Font><BR>";
            }
        }
        elsif ( $line =~ /^\s*\#/ ) {
            next;
        }    ## Ignore comments unless in arguments block ##
        elsif ( ( $line =~ /^\s*(?:my|local)\s+(\S+)\s*=\s*(shift)\s*(.*);\s*\#*(.*)/ ) || ( $line =~ /^\s*(?:my|local)\s+(\S+)\s*=\s*(\@_|\$_).*;\s*\#*(.*)/ ) || ( $line =~ /^\s*(?:my|local)\s+(\S+)\s*=\s*(.+)(\@_|\$_).*;\s*\#*(.*)/ ) ) {
            ## look for arguments of the sub in regular format ##
            my $name  = $1;
            my $value = $2 . $3;
            my $desc  = $4;
            my $type;
            print "($name; $value; $desc; $type) : $line\n";
            if ( $2 =~ /(\@|\%)/ ) {
                my $type = $1;
                $name =~ s/($type)(\w+)/$1\$$2/;
            }
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            $desc =~ s/^\s*(.*)/$1/;    #Trim leading spaces
            $desc =~ s/</&lt;/g;
            $desc =~ s/>/&gt;/g;
            $arguments{$name}{default}     = $value;
            $arguments{$name}{description} = $desc;
            $arguments{$name}{type}        = $type;
            $arguments_index{ $i++ }       = $name;

            if ( $value =~ /\@_/ && $name =~ /%(\w+)/ ) {
                $args_hash_found = $1;
            }
            print "HASH = ($name) $args_hash_found.\n";
        }
        elsif ( $args_hash_found && $line =~ /^\s*(?:my|local)*\s+(\S+)\s*=\s*([\@\%\{\$]*$args_hash_found[->]*[\{].*[\}]+)(.*)\s*;\s*\#*(.*)/ ) {
            ## Look for arguments in the %args format
            my $name  = $1;
            my $value = $2 . $3;
            my $desc  = $4;
            my $type;
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            print "[$name; $value; $desc; $type]\n";
            $desc =~ s/^\s*(.*)/$1/;    #Trim leading spaces
            $desc =~ s/</&lt;/g;
            $desc =~ s/>/&gt;/g;
            $arguments{$name}{default}     = $value;
            $arguments{$name}{description} = $desc;
            $arguments{$name}{type}        = $type;
            $arguments_index{ $i++ }       = $name;
        }
        elsif ( ( $line =~ /\&?(\w+)\(\\?%$args_hash_found/ ) || ( $line =~ /(?:\&|->|)([\w^>]+)\(\S*?=\>\\%args/ ) ) {
            my $reference = $1;
            print "(references $reference) : $line\n";

            #	    $arguments_index{$i++} = $reference;
            my $lastarg = $arguments_index{ $i - 1 };    ## append to last comment (to avoid formatting with arg = [Default= ] etc.)
            $lastarg =~ s/^\s+//g;
            $lastarg =~ s/\s+$//g;

            $arguments{$lastarg}{post_comments} .= "<FONT color=red>## parameters are also passed on to <A Href=#$reference>$reference</A> ##</Font><BR>";
            unless ( defined $Referenced{$reference} ) {
                if ( $reference =~ /^_/ ) { $Referenced{$reference} = 1; }
            }
        }
        elsif ( %arguments && $line !~ /^\S/ ) {

            # If arguments are found and we are at a non-blank line not describing arguments, then we are done!
            ## ... and clear any comments after last argument if applicable
            #	    if ( defined $arguments{$arguments_index{$i-1}}{post_comments} ) {
            #		$arguments{$arguments_index{$i-1}}{post_comments} = '';
            #	    }
            $done = 1;
        }

    }

    return ( \%arguments, \%arguments_index );
}

#####################################################################
sub parse_non_sub {
#####################################################################
    #
    #Parse the portion of the code that is not inside a sub
    #
    my $self = shift;
    my %args = @_;

    my $code           = $args{-code};
    my $secondary_type = $args{-secondary_type} || 'header';
    my $perldoc        = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    $self->get_perl_interpreter( -code => $code );
    $self->get_package_definition( -code => $code );
    $code = $self->get_system_variables( -code => $code );
    $self->get_superclasses( -code => $code, -perldoc => $perldoc );
    $self->get_modules_ref( -code => $code, -perldoc => $perldoc );
    $self->get_global_vars( -code => $code, -perldoc => $perldoc );

    #$self->get_modular_vars_and_constants(-code=>$code);
    $self->get_main( -code => $code, -secondary_type => $secondary_type );
}

#####################################################################
sub get_perl_interpreter {
#####################################################################
    #
    #Gets the perl interpreter
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my $i = () = keys %{ $self->{indexes}->{perl_interpreter} };
    $i += 1;

    $code =~ /^(\s*\#\!.*perl.*)\n/;
    $self->{perl_interpreter}->{perl_interpreter}->{code} = $1;
    $self->{indexes}->{perl_interpreter}->{$i} = 'perl_interpreter';
}

#####################################################################
sub build_perldoc_header_and_footer {
#####################################################################
    #
    #Builds the Perldoc header and footer
    #
    my $self = shift;
    my %args = @_;

    my $code   = $args{-code};
    my $author = $args{-author};

    ###Header
    my $ph_index = () = keys %{ $self->{indexes}->{perldoc_header} };
    $ph_index += 1;
    my $text;

    #if (exists $self->{perldoc}->{commands}->{'NAME'}) {
    #$self->{perldoc_header}->{perldoc_header}->{$ph_index++} = $self->{perldoc}->{commands}->{'NAME'};
    #}
    #else {
    $text = "=head1 NAME <UPLINK>\n\n";
    $text .= "$self->{name} - $self->{brief_description}";
    $self->{perldoc_header}->{perldoc_header}->{ $ph_index++ } = $text;

    #}

    if ( exists $self->{perldoc}->{commands}->{'SYNOPSIS'} ) {
        $self->{perldoc_header}->{perldoc_header}->{ $ph_index++ } = $self->{perldoc}->{commands}->{'SYNOPSIS'};
    }
    else {
        $text = "=head1 SYNOPSIS <UPLINK>\n\n";
        $text .= "\t<<SYNOPSIS>>\n";
        $self->{perldoc_header}->{perldoc_header}->{ $ph_index++ } = $text;
    }

    #if (exists $self->{perldoc}->{commands}->{'DESCRIPTION'}) {
    #$self->{perldoc_header}->{perldoc_header}->{$ph_index++} = $self->{perldoc}->{commands}->{'DESCRIPTION'};
    #}
    #else {
    my $desc = $self->{description};
    $desc =~ s/\n/<BR>/g;    #Replace newline characters with <BR> tags.
    $text = "=head1 DESCRIPTION <UPLINK>\n\n";
    $text .= "=for html\n$desc";
    $self->{perldoc_header}->{perldoc_header}->{ $ph_index++ } = $text;

    #}

    $self->{perldoc_header}->{perldoc_header}->{ $ph_index++ } = "=cut";

    $self->{indexes}->{perldoc_header}->{1} = 'perldoc_header';

    ###Footer
    my $pf_index = () = keys %{ $self->{indexes}->{perldoc_footer} };
    $pf_index += 1;
    $text = '';    ## clear variable...

    ### Include internal references if input parameters may be passed to them ##

    if ( exists $self->{perldoc}->{commands}->{'KNOWN ISSUES'} ) {
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $self->{perldoc}->{commands}->{'KNOWN ISSUES'};
    }
    else {
        $text = "=head1 KNOWN ISSUES <UPLINK>\n\n";
        $text .= "<<KNOWN ISSUES>>\n";
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $text;
    }

    if ( exists $self->{perldoc}->{commands}->{'FUTURE IMPROVEMENTS'} ) {
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $self->{perldoc}->{commands}->{'FUTURE IMPROVEMENTS'};
    }
    else {
        $text = "=head1 FUTURE IMPROVEMENTS <UPLINK>\n\n";
        $text .= "<<FUTURE IMPROVEMENTS>>\n";
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $text;
    }

    my $author_list;

    if ( exists $self->{perldoc}->{commands}->{'AUTHORS'} ) {
        $author_list = $self->{perldoc}->{commands}->{'AUTHORS'};
    }
    else {
        $author_list = "=head1 AUTHORS <UPLINK>\n\n<<AUTHORS>>\n";
    }
    if ($author) {
        if ( $author_list =~ s /<<AUTHORS>>/$author/ ) {
        }
        elsif ( $author_list =~ /$author/ ) {    # skip (already exists)
        }
        else {
            $author_list .= "$author\n";
        }
        $author_list =~ s/,/\n/g;
    }
    $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $author_list;

    if ( exists $self->{perldoc}->{commands}->{'CREATED'} ) {
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $self->{perldoc}->{commands}->{'CREATED'};
    }
    else {
        $text = "=head1 CREATED <UPLINK>\n\n";
        $text .= today() . "\n";
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $text;
    }

    if ( exists $self->{perldoc}->{commands}->{'REVISION'} ) {
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $self->{perldoc}->{commands}->{'REVISION'};
    }
    else {
        $text = "=head1 REVISION <UPLINK>\n\n";
        $text .= '$Id: Code.pm,v 1.36 2004/08/27 18:26:55 rguin Exp $ (Release: $Name:  $)' . "\n";
        $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = $text;
    }

    $self->{perldoc_footer}->{perldoc_footer}->{ $pf_index++ } = "=cut";

    $self->{indexes}->{perldoc_footer}->{1} = 'perldoc_footer';
}

#####################################################################
sub get_package_definition {
#####################################################################
    #
    #Gets the package definition
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my $i = () = keys %{ $self->{indexes}->{package_definition} };
    $i += 1;

    if ( $code =~ /^(.*)(\s*package\s+)(.*?)(;\S*).*$/ms ) {
        my $name = $3;
        $self->{package_definition}->{$name}->{code} = "$1$2$3$4\n";
        $self->{indexes}->{package_definition}->{$i} = "$name";
    }
}

#####################################################################
sub get_system_variables {
#####################################################################
    #
    #Gets the package definition
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my $i = () = keys %{ $self->{indexes}->{system_variables} };
    $i += 1;

    my $check = $code;
    while ( ( $check =~ s/(.*)^(require Exporter;.*?)$(.*)/$1$3/ms ) || ( $check =~ s/(.*)^(\s*(?:\@|%)EXPORT(?:|_OK|_TAGS)\s*=\s*(?:qw)*\(.*?\);.*?)$(.*)/$1$3/ms ) ) {

        #($check =~s/(.*)^(\s*\@EXPORT(?:|_OK|_TAGS)\s*=\s*qw*\(.*?\).*?)$(.*)/$1$3/ms) ) {
        my $lines = $2;
        $self->{system_variables}->{$i}->{code} = "$lines\n";
        $self->{indexes}->{system_variables}->{$i} = "$i";

        $i++;
    }

    $code = $check;

    return $code;
}

#################################################################
sub get_superclasses {
#####################################################################
    #
    #Gets the superclasses
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};
    my $perldoc = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    my $i = () = keys %{ $self->{indexes}->{superclasses} };
    $i += 1;

    if ( $code =~ /^(.*?)(\s*\@ISA\s*=\s*(?:qw*)\()(.*?)(\);\s*)$/ms ) {
        my $precode      = $1;
        my $declare      = $2;
        my $superclasses = $3;
        my $comments     = $4;
        my $line_number  = () = $precode =~ /\n/msg;    # Figure out the current line number
        $line_number += 2;
        foreach my $superclass ( split /\s/, $superclasses ) {
            $self->{indexes}->{superclasses}->{$i} = "$superclass";
            $self->{superclasses}->{$superclass}->{code} = $self->get_comments(
                -code        => $code,
                -line_number => $line_number
            ) . "$declare$superclasses$comments\n";
            unless ( $i == 1 ) {
                $self->{superclasses}->{$superclass}->{skip_generation} = 1;
            }                                           #Skip code generation unless it is the first one of the group
        }
    }

    if ($perldoc) {
        my $pdi = 1;
        $self->{superclasses}->{perldoc_header}->{ $pdi++ } = "=head2 SUPERCLASSES <UPLINK>";
        $self->{superclasses}->{perldoc_header}->{ $pdi++ } = "=over";

        foreach my $i (
            sort { $a <=> $b }
            keys %{ $self->{indexes}->{superclasses} }
            )
        {
            my $sc = $self->{indexes}->{superclasses}->{$i};
            $self->{superclasses}->{perldoc_header}->{ $pdi++ } = "=item $sc";
        }

        $self->{superclasses}->{perldoc_header}->{ $pdi++ } = "=back";
        $self->{superclasses}->{perldoc_header}->{ $pdi++ } = "=cut";
    }
}

#####################################################################
sub get_modules_ref {
#####################################################################
    #
    # Gets references to modules
    # (This only gets called for the initial code (excludes subroutines)
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};
    my $perldoc = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    my $pm_index = () = keys %{ $self->{indexes}->{standard_modules_ref} };
    my $cm_index = () = keys %{ $self->{indexes}->{custom_modules_ref} };

    $pm_index += 1;
    $cm_index += 1;

    my $line_number = 0;
    foreach my $line ( split /\n/, $code ) {
        $line_number++;
        if ( $line =~ /^use vars.*\(.*\)/ ) {
            next;
        }    # use vars are not references to modules
        elsif ( $line =~ /^\s*\#/ ) {next}
        elsif ( $line =~ /^use\s+(.*);\s*\#*(.*)/ ) {
            my $name = $1;
            my $desc = $2;
            $desc =~ s/^\s*(.*)/$1/;    # Remove leading spaces from description

            $line = "$line\n";

            if ( $name =~ /^(.*)::(.*)/ ) {
                my $dir  = $1;
                my $file = $2;
                if ( exists $self->{custom_modules}->{dirs}->{$dir} || exists $self->{custom_modules}->{files}->{$file} ) {
                    $self->{custom_modules_ref}->{$name}->{description} = $desc;
                    ## include comments immediately preceeding this line if available.. ##
                    $self->{custom_modules_ref}->{$name}->{code} .= $self->get_comments(
                        -code        => $code,
                        -line_number => $line_number
                    ) . $line;
                    $self->{indexes}->{custom_modules_ref}->{ $cm_index++ } = $name;
                }
                else {
                    $self->{standard_modules_ref}->{$name}->{description} = $desc;
                    $self->{standard_modules_ref}->{$name}->{code} .= $self->get_comments(
                        -code        => $code,
                        -line_number => $line_number
                    ) . $line;
                    $self->{indexes}->{standard_modules_ref}->{ $pm_index++ } = $name;
                }
            }
            else {
                if ( exists $self->{custom_modules}->{files}->{$name} ) {
                    $self->{custom_modules_ref}->{$name}->{description} = $desc;
                    $self->{custom_modules_ref}->{$name}->{code} .= $self->get_comments(
                        -code        => $code,
                        -line_number => $line_number
                    ) . $line;
                    $self->{indexes}->{custom_modules_ref}->{ $cm_index++ } = $name;
                }
                else {
                    $self->{standard_modules_ref}->{$name}->{description} = $desc;
                    $self->{indexes}->{standard_modules_ref}->{ $pm_index++ } = $name;
                    $self->{standard_modules_ref}->{$name}->{code} .= $self->get_comments(
                        -code        => $code,
                        -line_number => $line_number
                    ) . $line;
                }
            }
        }
    }

    if ($perldoc) {

        # Standard modules
        my $pdi = 1;
        $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = "=head2 STANDARD MODULES REFERENCE <UPLINK>";
        $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = "=over";

        foreach my $i (
            sort { $a <=> $b }
            keys %{ $self->{indexes}->{standard_modules_ref} }
            )
        {
            my $smf = $self->{indexes}->{standard_modules_ref}->{$i};
            $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = "=item $smf";
            $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = $self->{standard_modules_ref}->{$smf}->{description};
        }

        $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = "=back";
        $self->{standard_modules_ref}->{perldoc_header}->{ $pdi++ } = "=cut";

        # Custom modules

        $pdi                                                      = 1;                                            ## reset variable ...
        $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=head2 CUSTOM MODULES REFERENCE <UPLINK>";
        $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=over";

        foreach my $i (
            sort { $a <=> $b }
            keys %{ $self->{indexes}->{custom_modules_ref} }
            )
        {
            my $cmf = $self->{indexes}->{custom_modules_ref}->{$i};
            my ($href) = $cmf =~ /(?:\w*:?:?)(\w+)$/;
            $href .= ".html";
            $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=for html <font size='-1'><strong><a href='$href'>$cmf</a></strong></font><br>";
            $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=for html <dd><font size='-1'>$self->{custom_modules_ref}->{$cmf}->{description}<br></font>";
            if ( $self->{custom_modules_ref}->{$cmf}->{description} ne '' ) {
                $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=for html <br>";
            }

            #$self->{custom_modules_ref}->{perldoc_header}->{$pdi++} = "=item $cmf";
            #$self->{custom_modules_ref}->{perldoc_header}->{$pdi++} = $self->{custom_modules_ref}->{$cmf}->{description};
        }

        $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=back";
        $self->{custom_modules_ref}->{perldoc_header}->{ $pdi++ } = "=cut";
    }
}

#####################################################################
sub get_global_vars {
#####################################################################
    #
    #Gets global variables
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};
    my $perldoc = ( defined $args{-perldoc} ) ? $args{-perldoc} : 2;

    my $gvi = () = keys %{ $self->{indexes}->{global_vars} };
    $gvi += 1;

    my $line_number = 0;
    foreach my $line ( split /\n/, $code ) {
        $line_number++;

        my $gvs;
        my $desc;
        if ( $line =~ /^\s*\#/ ) {next}
        elsif ( $line =~ /^\s*use\s+vars.*\((.*)\);\s*\#*(.*)/ ) {
            $gvs  = $1;
            $desc = $2;
            $desc =~ s/^\s*(.*)\s*$/$1/;    #Get rid of leading and trailing spaces
            my $group_index = 1;
            foreach my $gv ( split /\s/, $gvs ) {
                $self->{global_vars}->{$gv}->{description} = $desc;
                ## include comments immediately preceeding these lines ##
                $self->{global_vars}->{$gv}->{code} .= $self->get_comments(
                    -code        => $code,
                    -line_number => $line_number
                ) . "$line\n";
                unless ( $group_index == 1 ) {
                    $self->{global_vars}->{$gv}->{skip_generation} = 1;
                }                           #Skip code generation unless it is the first one of the group
                $group_index++;
                $self->{indexes}->{global_vars}->{ $gvi++ } = $gv;
            }
        }
        elsif ( $line =~ /^\s*our.*\((.*)\);\s*\#*(.*)/ ) {
            $gvs  = $1;
            $desc = $2;
            $desc =~ s/^\s*(.*)\s*$/$1/;    #Get rid of leading and trailing spaces
            my $group_index = 1;
            foreach my $gv ( split /,/, $gvs ) {
                $self->{global_vars}->{$gv}->{description} = $desc;
                ## include comments immediately preceeding these lines ##
                $self->{global_vars}->{$gv}->{code} .= $self->get_comments(
                    -code        => $code,
                    -line_number => $line_number
                ) . "$line\n";
                unless ( $group_index == 1 ) {
                    $self->{global_vars}->{$gv}->{skip_generation} = 1;
                }                           #Skip code generation unless it is the first one of the group
                $group_index++;
                $self->{indexes}->{global_vars}->{ $gvi++ } = $gv;
            }
        }
    }

    if ($perldoc) {
        my $pdi = 1;
        $self->{global_vars}->{perldoc_header}->{ $pdi++ } = "=head2 GLOBAL VARIABLES <UPLINK>";
        $self->{global_vars}->{perldoc_header}->{ $pdi++ } = "=over";

        foreach my $i ( sort { $a <=> $b } keys %{ $self->{indexes}->{global_vars} } ) {
            my $gv = $self->{indexes}->{global_vars}->{$i};
            $self->{global_vars}->{perldoc_header}->{ $pdi++ } = "=item $gv";
            $self->{global_vars}->{perldoc_header}->{ $pdi++ } = $self->{global_vars}->{$gv}->{description};
        }

        $self->{global_vars}->{perldoc_header}->{ $pdi++ } = "=back";
        $self->{global_vars}->{perldoc_header}->{ $pdi++ } = "=cut";
    }
}

#####################################################################
sub get_modular_vars_and_constants {
#####################################################################
    #
    #Gets modular variables and constants
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my $mvi = () = keys %{ $self->{indexes}->{modular_vars} };
    $mvi += 1;

    my $ci = () = keys %{ $self->{indexes}->{constants} };
    $ci += 1;

    my $open_bracket_count  = 0;
    my $close_bracket_count = 0;
    my $inside_block        = 0;

    my $line_number = 0;
    foreach my $line ( split /\n/, $code ) {
        $line_number++;
        if ( $line =~ /^\s*\#/ ) {next}
        elsif ( $line =~ /\{/g || $line =~ /\}/g ) {
            $open_bracket_count  += () = $line =~ /\{/g;
            $close_bracket_count += () = $line =~ /\}/g;

            if ( $open_bracket_count == $close_bracket_count ) {
                $inside_block        = 0;
                $open_bracket_count  = 0;
                $close_bracket_count = 0;
            }
            else {
                $inside_block = 1;
            }
        }
        elsif ( !$inside_block && $line =~ /^\s*(?:my|local)\s+([\$|\@|\%]{1}[A-Z_]+)\s*=\s*(.*)\s*;\s*\#*(.*)/ ) {
            my $name  = $1;
            my $value = $2;
            my $desc  = $3;
            my $type;
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            $self->{constants}->{$name}->{default}     = $value;
            $self->{constants}->{$name}->{description} = $desc;
            $self->{constants}->{$name}->{type}        = $type;
            $self->{constants}->{$name}->{code} .= $self->get_comments(
                -code        => $code,
                -line_number => $line_number
            ) . "$line\n";
            $self->{indexes}->{constants}->{ $ci++ } = $name;
        }
        elsif ( !$inside_block && $line =~ /^\s*(?:my|local)\s+([\$|\@|\%]{1}\w+)\s*;\s*\#*(.*)/ ) {
            my $name = $1;
            my $desc = $2;
            my $type;
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            $self->{modular_vars}->{$name}->{default}     = '';
            $self->{modular_vars}->{$name}->{description} = $desc;
            $self->{modular_vars}->{$name}->{type}        = $type;
            $self->{modular_vars}->{$name}->{code} .= $self->get_comments(
                -code        => $code,
                -line_number => $line_number
            ) . "$line\n";
            $self->{indexes}->{modular_vars}->{ $mvi++ } = $name;
        }
        elsif ( !$inside_block && $line =~ /^\s*(?:my|local)\s+([\$|\@|\%]{1}\w+)\s*=\s*(.*)\s*;\s*\#*(.*)/ ) {
            my $name  = $1;
            my $value = $2;
            my $desc  = $3;
            my $type;
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            $self->{modular_vars}->{$name}->{default}     = $value;
            $self->{modular_vars}->{$name}->{description} = $desc;
            $self->{modular_vars}->{$name}->{type}        = $type;
            $self->{modular_vars}->{$name}->{code} .= $self->get_comments(
                -code        => $code,
                -line_number => $line_number
            ) . "$line\n";
            $self->{indexes}->{modular_vars}->{ $mvi++ } = $name;
        }
    }
}

#####################################################################
sub get_main {
#####################################################################
    #
    #Gets the main body and return value of the code
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};
    my $secondary_type = $args{-secondary_type} || 'header';

    my $mi = () = keys %{ $self->{indexes}->{ "main_" . $secondary_type } };
    $mi += 1;

    my $open_bracket_count  = 0;
    my $close_bracket_count = 0;
    my $inside_block        = 0;

    my $line_number = 0;
    foreach my $line ( split /\n/, $code ) {
        $line_number++;
        if ( $line =~ /\{/g || $line =~ /\}/g ) {    #Determine whether we are inside a block
            $open_bracket_count  += () = $line =~ /\{/g;
            $close_bracket_count += () = $line =~ /\}/g;

            if ( $open_bracket_count == $close_bracket_count ) {
                $inside_block        = 0;
                $open_bracket_count  = 0;
                $close_bracket_count = 0;
            }
            else {
                $inside_block = 1;
            }
        }

        if ( $line =~ /^\s*\#\!.*perl.*$/ ) {next}    #Perl scripts directive
        elsif ( $line =~ /^\s*\#+/ || $line =~ /^\s*$/ ) {
            next;
        }                                             #Comments or blank lines
        elsif ( $line =~ /^\s*package\s+.*;/ ) {next} #Perl modules directive
        elsif ( $line =~ /^use\s+.*;\s*\#*.*/ ) {
            next;
        }                                             #References to other modules
        elsif ( $line =~ /^\s*use\s+vars.*\(.*\);\s*\#*.*/ || $line =~ /^\s*our.*\(.*\);\s*\#*.*/ ) {
            next;
        }                                             #Global variables
                                                      #elsif (!$inside_block && $line =~ /^\s*(?:my|local)\s+[\$|\@|\%]{1}[A-Z_]+\s*=\s*.*\s*;\s*\#*.*/) {next} #Modular level constants
                                                      #elsif (!$inside_block && ($line =~ /^\s*(?:my|local)\s+[\$|\@|\%]{1}\w+\s*;\s*\#*.*/ || $line =~ /^\s*(?:my|local)\s+[\$|\@|\%]{1}\w+\s*=\s*.*\s*;\s*\#*.*/)) {next} #Modular level variables
        elsif ( $line =~ /^(\s*\@ISA\s*=\s*(?:qw*)\()(.*?)(\);\s*)$/ ) {
            next;
        }                                             #Superclasses
        elsif ( $line =~ /^(\s*\@Export\w*\s*=\s*(?:qw*)\()(.*?)(\);\s*)$/ ) {
            next;
        }                                             # Exporter
        else {                                        # This is coding lines for the main body of the code
            my $section = "main_" . $secondary_type;
            my $name    = "main_" . $secondary_type . "_" . $mi;
            $self->{$section}->{$name}->{code} .= $self->get_comments(
                -code        => $code,
                -line_number => $line_number
            ) . "$line\n";
            $self->{indexes}->{$section}->{ $mi++ } = $name;
        }
    }

}

#####################################################################
sub get_comments {
#####################################################################
    #
    # Gets the comments that preceed the first executable lines of code
    # Returns: The comments that start off the next given block.
    #
    my $self = shift;
    my %args = @_;

    my $code        = $args{-code};                 # The code to extract the comments from
    my $line_number = $args{-line_number} || 1;     # Optional line number at which to start
    my $search      = $args{ - search };            # The block of code to search for which is preceeded by the comments
    my $direction   = $args{-direction} || 'rev';

    $search = "\Q$search\E";                        # Need to escape special characters during the regexp searching.
    my @lines = split "\n", $code;

    my $comments = '';
    my $nextline;

    $line_number--;                                 ## adjust to represent index rather than line #

    if   ( $direction =~ /^f/i ) { $nextline = $lines[ ++$line_number ] }
    else                         { $nextline = $lines[ --$line_number ] }

    while ( ( $line_number > 0 ) && ( ( $nextline =~ /^\s*\#+/ ) || ( $nextline =~ /^\s*$/ ) || ( $nextline =~ /^sub / ) ) && ( $line_number <= int(@lines) ) ) {

        if ( $direction =~ /^f/i ) {
            $comments .= "$nextline\n" unless ( $nextline =~ /^sub / );    ## skip definition line
            $nextline = $lines[ ++$line_number ];
        }
        else {
            $comments = "$nextline\n$comments" unless ( $nextline =~ /^sub / );    ## skip definition line;
            $nextline = $lines[ --$line_number ];
        }
    }
    return $comments;
}

#####################################################################
sub generate_code {
#####################################################################
    #
    #Builds the code.
    #
    my $self = shift;
    my %args = @_;

    my $author = $args{-author};
    my $perldoc
        = ( defined $args{-perldoc} )
        ? $args{-perldoc}
        : 2;    # 3 perldoc levels: 0 = No perldoc; 1 = perldoc header & footer; 2 = ALL perldoc

    $self->parse_perldoc();
    $self->get_blocks();
    $self->parse_blocks( -perldoc => 2 );

    if ($perldoc) {
        $self->build_perldoc_header_and_footer( -author => $author );
    }

    #print Dumper @{$self->{sections_order}};

## hide the block headings for some of the sections... ##
    my %Hide;
    $Hide{perl_interpreter}   = 1;
    $Hide{package_definition} = 1;

    foreach my $section ( @{ $self->{sections_order} } ) {
        unless ( $Hide{$section} ) {    ## don't include labels for these sections
            $self->{generated_code} .= _section_label($section);
            print _section_label($section);
        }

        if ( $perldoc && $self->{$section}->{perldoc_header} ) {
            if ( $perldoc == 2 || $section =~ /perldoc_header|perldoc_footer/ ) {    # If perldoc level is 1 then only print if section is perldoc header or footer
                $self->{generated_code} .= $self->generate_perldoc( $self->{$section}->{perldoc_header} );
                print "added perldoc..";
            }
        }

        my $max_index = () = keys %{ $self->{indexes}->{$section} };
        foreach my $key ( sort { $a <=> $b } keys %{ $self->{indexes}->{$section} } ) {
            my $item = $self->{indexes}->{$section}->{$key};

            #print ">>>>>$section ($item)\n";
            #print $self->{$section}->{$item}->{code};
            unless ( defined $self->{$section}->{$item}->{skip_generation} ) {
                if ( $perldoc == 2 ) {
                    $self->{generated_code} .= $self->generate_perldoc( $self->{$section}->{$item}->{perldoc} );
                    $self->{generated_code} .= $self->{$section}->{$item}->{pre_code};
                    $self->{generated_code} .= $self->{$section}->{$item}->{code};
                }
                else {
                    $self->{generated_code} .= $self->{$section}->{$item}->{pre_code};
                    $self->{generated_code} .= $self->{$section}->{$item}->{code};
                }

                #Insert blank line between sections
                if ( $key == $max_index ) { $self->{generated_code} .= "\n"; }
            }
        }
        if ( $perldoc && $self->{$section}->{perldoc_footer} ) {
            if ( $perldoc == 2 || $section =~ /perldoc_header|perldoc_footer/ ) {    # If perldoc level is 1 then only print if section is perldoc header or footer
                $self->{generated_code} .= $self->generate_perldoc( $self->{$section}->{perldoc_footer} );
                print "footer;";
            }
        }
        print "\n";
    }

    $self->{generated_code} =~ s/\n{3,}/\n\n/sg;                                     # Get rid of extra blank lines
    $self->{generated_code} =~ s/^\s*(.*)\s*$/$1/s;                                  # Get rid of leading and trailing spaces

    if ( $file =~ /\.pm$/ ) { $self->{generated_code} .= "\nreturn 1;\n" }
}

#####################################################################
sub generate_perldoc {                                                               #
#####################################################################
    #
    # Generates the perldoc from a Perldoc object
    # Returns: The formatted Perldoc [String]
    #
    my $self   = shift;
    my $pd_ref = shift;

    my $perldoc;

    foreach my $command ( sort { $a <=> $b } keys %{$pd_ref} ) {
        $perldoc .= "\n\n" . $pd_ref->{$command} . "\n\n";
    }

    return $perldoc;
}

#####################################################################
sub save_code {
#####################################################################
    #
    # Saves the code to the file
    #
    my $self = shift;
    my %args = @_;

    my $overwrite = $args{-overwrite} || 0;
    my $perltidy = $args{-perltidy};

    my $newfile;
    if ($overwrite) {
        $newfile = $self->{fullname};
    }
    else {
        $newfile = "$self->{fullname}.pod";
    }

    # print Dumper $self->{blocks};

    open( FILE, ">$newfile" ) || die("Cannot open $newfile");
    print FILE $self->{generated_code};
    close(FILE);

    if ($perltidy) {`$perltidy $newfile`}

}

##############################
# public_functions           #
##############################
##############################
# private_methods            #
##############################

#####################################################################
sub _get_attributes {
#####################################################################
    #
    #Parse a constructor and gets the attributes of the class
    #Returns: An array that contains the attributes of the class [HashRef] and the index to the attributes[HashRef]
    #
    my $self = shift;
    my %args = @_;

    my $code = $args{-code};

    my %attributes;
    my %attributes_index;
    my $i = 1;

    foreach my $line ( split /\n/, $code ) {
        if ( $line =~ /^\s*\#/ ) {next}
        elsif ( $line =~ /\$self->\{(.*?)\}(.*)\s*=\s*(.*)\s*;\s*\#*(.*)/ ) {
            my $name  = "$1$2";
            my $value = $3;
            my $desc  = $4;
            my $type;
            if ( $desc =~ /(.*)\s*\[(.*)\]/ ) {
                $desc = $1;
                $type = $2;
            }
            $desc =~ s/^\s*(.*)\s*$/$1/;    #Get rid of leading and trailing spaces
            unless ( exists $attributes{$name} ) {
                $attributes{$name}{default}     = $value;
                $attributes{$name}{description} = $desc;
                $attributes{$name}{type}        = $type;
                $attributes_index{ $i++ }       = $name;
            }
        }
    }

    return ( \%attributes, \%attributes_index );
}

##############################
# private_functions          #
##############################

###################################
# Generate label for each section
# Return : label [string]
#################
sub _section_label {
#################
    my $section = shift;

    my $length = 30;

    my $label = "#" x $length;
    $label .= "\n\# ";

    $label .= sprintf "%-26s", $section;

    $label .= " \#\n";
    $label .= "\#" x 30 . "\n";

    return $label;
}

##############################
# main_footer                #
##############################
##############################
# perldoc_footer             #
##############################

=head1 KNOWN ISSUES <UPLINK>

None.

    =head1 FUTURE IMPROVEMENTS <UPLINK>

None.

=head1 FUTURE IMPROVEMENTS <UPLINK>

<<FUTURE IMPROVEMENTS>>

=head1 AUTHORS <UPLINK>

Ran Guin and Andy Chan: Michael Smith Genome Sciences Centre

=head1 CREATED <UPLINK>

2003-07-14

=head1 REVISION <UPLINK>

$Id: Code.pm,v 1.36 2004/08/27 18:26:55 rguin Exp $ (Release: $Name:  $)

=head1 KNOWN ISSUES <UPLINK>
    
None.
    

=head1 FUTURE IMPROVEMENTS <UPLINK>
    
    Eventually this object will replace the existing GSDB.pm and DB_IO.pm. Also support for transaction will be added in the future.
    

=head1 AUTHORS <UPLINK>
    
    Ran Guin, Andy Chan and J.R. Santos at the Canadas Michael Smith Genome Sciences Centre
    

=head1 CREATED <UPLINK>
    
    2003-09-05
    

=head1 REVISION <UPLINK>
    
    $Id: DBIO.pm,v 1.107 2004/11/30 01:42:24 rguin Exp $ (Release: $Name:  $)
							 
=cut

return 1;
