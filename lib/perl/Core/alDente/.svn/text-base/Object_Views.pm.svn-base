###################################################################################################################################
#
# Wrapper for objects for standard <class>_Views method.
#
# Methods should include the line:
# use base alDente::Object_Views if it is to be defined as an Object.
#
###################################################################################################################################
package alDente::Object_Views;

use base SDB::DB_Object_Views;

use strict;
use CGI qw(:standard);

## SDB modules
use SDB::CustomSettings;
use SDB::DBIO;
use SDB::HTML;

## RG Tools
use RGTools::RGIO;
use RGTools::Views;
use RGTools::HTML_Table;

## alDente modules
use alDente::SDB_Defaults;
use alDente::Tools;

use LampLite::Bootstrap;
use LampLite::JQuery;

use vars qw( %Configs );
my $BS = new Bootstrap;

my $split_page_format = <<SPLITFORMAT;
        <div class='row col-md-12'> <!-- START OF SPLIT PAGE -->
            <TOP_CONTENT>
        </div> <!-- end of top section -->
        <div class = 'row col-md-12'> <!-- start of full width span -->
          <div class = 'col-md-9'>
            <div class = 'col-md-12'>    
                    <div class='col-md-<LEFT_SPAN>'>
                        <LEFT_CONTENT>
                    </div> <!-- end of left section -->
                    <div class='col-md-<CENTRE_SPAN>'>
                        <CENTRE_CONTENT>
                    </div> <!-- end of centre section -->
                    <div class='col-md-<RIGHT_SPAN>'>
                        <RIGHT_CONTENT>
                    </div> <!-- end of right section -->
            </div> <!-- end of left / centre / right row -->   
            
            <div class='row col-md-12'>
                <MIDDLE_CONTENT>
            </div> <!-- end of middle section -->
                    
            <div class='col-md-12'>
                <HR>
                <LAYERS_CONTENT>
            </div> <!-- end of layers section -->
          </div> <!-- end of 9 col span -->
          <div class = 'col-md-3'>
            <RIGHT_COLUMN_CONTENT>
          </div> <!-- end of right column -->
        </div> <!-- end of full width span -->
        <div class='row col-md-12'>
            <BOTTOM_CONTENT>
        </div> <!-- end of bottom section -->
    </div> <!-- END OF STANDARD PAGE -->
SPLITFORMAT

#
#####################
sub new {
#####################
    my $this   = shift;
    my %args   = &filter_input( \@_ );
    my $models = $args{-models} || $args{-model};
    my $dbc    = $args{-dbc};

    my $self = {};

    my ($class) = ref($this) || $this;
    bless $self, $class;

    if ( ref $models eq 'ARRAY' ) {
        ## load models if supplied ... eg   new Object_Views( -dbc=> $dbc, -models => [$object]);
        foreach my $model (@$models) {
            my $type = ref $model;
            if ( $type =~ /(\w+)$/ ) { $type = $1 }    ## convert from 'alDente::System' to 'System'
            $self->{$type} = $model;
        }
    }
    elsif ( ref $models eq 'HASH' ) {
        ## load models if supplied ... eg   new Object_Views( -dbc=> $dbc, -models => [$object]);
        foreach my $model ( keys %{$models} ) {
            my $type = $model;
            if ( $type =~ /(\w+)$/ ) { $type = $1 }    ## convert from 'alDente::System' to 'System'
            $self->{$type} = $models->{$model};
        }
    }

    if ($dbc) { $self->{dbc} = $dbc }
    return $self;
}

#
# Wrapper for alDente single_record page generation
#
# This includes default home page generation
# 
# Usage:
#   This method should be called by individual alDente object modules of the same name ( eg return $self->SUPER::display_record_page(...) ), passing in the following (optional) parameters:
#    
#   Typical home page parameters:
#    -centre => $links        ## this should generally contain standard links and object specific buttons (that were previously listed below the main object label) which may now appear in the top centre of the screen on desktops
#    -right  => $right        ## this can contain anything that you would like to print on the top right side of the screen - eg ancestry (some of which may previously have appeared in the centre)
#    -layers => \@layers (if layers are desired this should be an array of layer hashes - eg [ { -label=>"A", -content=>"Content of A layers.."}, { -label=>'B', -content=>"Content of B layer"} ])
#    -open_layer => $open     ## indicate the layer that should be open by default upon loading
#
#   Note: -layers parameter can also be a single static string in which case it is treated like any other section, and it will appear where the layers are normally displayed.
#   
#   ** The top left of the screen is generated by default and should not be included as a parameter **
#   It will contain the object label (customize by defining object_label within your class), with standard field editing & reprint barcode options below it.
#   (the -left parameter may be passed in to override the default if desired, but this should be avoided unless it is for a good reason since this is meant to be standardized as much as possible)     
#
# Other additional options (these are all automatically converted to attributes of the page hash which is used by the generate_page() method ):
#    -layer_type => $type  ## this can be either 'tabs' or 'accordion' - by default, mobile mode switches to accordion if more than 3 layers are present 
#    -visibility => { 'B' => ['desktop'], 'right' => ['desktop'] } ## this can be used to set (or override) the visibility of the various sections & layers - by default centre and right sections are only visible for desktop)
#    -collapse_to_layer => { 'centre' => 'Links', 'left' => 'Info' } (this is the default)  ## this can be used to define how left/right/centre layers are to be collapsed in mobile mode
#    -span => [2,4,6]    ## this allows specification of how left / centre / right layers are spanned across the screen (total should be 12)  
#                        ## you can also use a shorter array if applicable ... eg  -span=>[2,10] if only left, right are supplied (in this case it would otherwise default to [6,6])
#                        ## (by default the left/right/centre sections are evenly spaced and automatically adjusted if only 1 or two of these sections are included - if only left, right are specified, they span at [6,6] by default
#    -record_position 'right' ## defaults to layer meaning that the database record dump is included in the layer.  Other options are 'right' (only valid in desktop mode) or 'hidden')
#    -label_style => $style   ## optional style specification for label 
#
# Exceptional options (Generally these should not be used, since they imply a deviation from the standard format that we are trying to establish):
#    -middle => $middle (anything that should between the layers and the left / centre / right section= spanning the full width) - this may be used for small sections that need to appear above the layers on both single and multiple record pages
#    -left => $left (this defaults to the object label + standard field editing options + standard barcode reprinting options if applicable)
#    -top  => $top  (this defaults to a heading containing the object alDente_ref.  This content will span the full width at the top of the page)
##   -bottom => $bottom (anything that should appear at the bottom of the page - spanning the full width) - this may be reasonably used if the layers option is excluded, but a scalar can also be passed as the layers parameter accomplishing the same result
#
# Return: page hash that is specifically formatted for the 'generate_page' method which generates the html page rendering string.
#########################
sub display_record_page {
#########################
    my $self = shift;
    my %args  = filter_input( \@_);
    
    my $Object = $self->Model;
    my $id = $args{-id} || $self->{id} || $Object->{id};
    
    ## Defined standard sections ##    
    my $left = $args{-left};
    my $centre = $args{-centre};
    my $right = $args{-right};
    my $layers = $args{-layers};
    my $top    = $args{-top};
    my $bottom = $args{-bottom};
    my $group_options = $args{-group_options};
    
    ## Additional options ##
    my $format = $args{-format};
    my $visibility = $args{-visibility};                   ## visibility of various sections (adapted in real time)
    my $collapse_to_layer = $args{-collapse_to_layer};     ## left / centre / right sections which should be collapsed into layers for mobile mode (at run time)
    my $span = $args{-span};                               ## span distribution for left / centre / right sections ##
    my $record_position = $args{-record_position} || 'layer';  ## where to include the display record dump of the database record (use 'layer', 'right', or 'hidden') - use split_page format with RIGHT_COLUMN section
    my $layer_type = $args{-layer_type};
    my $label_style = $args{-label_style};  
    my $open_layer = $args{-open_layer};    ## open layer on loading 
        
    my $add_to_label = $args{-add_to_label};
    my $label_size = $args{-label_size} || 'md';
    my $label_span = $args{-label_span} || 12;                      ## colspan of labels ( in 12x grid) - primarily used by multiple_record form to organize multiple label wrapping.
    my $mobile_summary = $args{-mobile};

    my $mobile_summary = $args{-mobile};
    my $detailed = $args{-detailed};
    
    my $dbc = $args{-dbc} || $self->dbc();
    
    my @ids = Cast_List(-list=>$id, -to=>'array');

    my $max_displayed = 100;   ## maximum labels displayed if list is scanned ... 
    my $class = ref $Object;
    $class =~s/(.+):://;
    $class =~s/Container/Plate/;  ## adjust for non-standard classes... 
   
    my $label_class;
    if ($self->objects() > 1 && $label_span) { $label_class = "col-$label_size-$label_span" }  ## enable grid organized separation of labels for multi_record page if applicable 

    ### Initialize page object ##
    my $page;
    my @std_params = qw(format visibility collapse_to_layer span record_position layer_type);  ## exclude layers ##
    foreach my $section (keys %args) { 
        $section =~s/^-//;
#       if (grep /^$section$/i, @std_params) { next }
        $page->{$section} = $args{"-$section"}
    }

    ## for alDente, by default the left section will be collapsed into the layer on the mobile version ##
    $page->{collapse_to_layer} = $collapse_to_layer;
    if ($collapse_to_layer && !ref $collapse_to_layer) { $page->{collapse_to_layer} = {'left' => $BS->icon('info-circle'), 'centre' => 'Links ' . $BS->icon('external-link'), 'links' => 'Links ' . $BS->icon('external-link') } }

    my ($short_label, $label_block, $centre_block, $batch_block);
    if ( ! defined $page->{left} ) {
        ## Left section should not generally be included for single_record displays since this is standardized for alDente objects ##
        ($short_label, $label_block, $batch_block) = $self->labels($class, $id, -class=>$label_class, -style=>$label_style, -label_span=>$label_span, 
            -add_to_label=>$add_to_label, -detailed => $detailed,  -collapse=>$collapse_to_layer, -group_options=>$group_options);
    }
        
    my @ids = Cast_List( -list => $id, -to => 'array' );
    if ($class =~ /Plate/ && int(@ids) > 1) {
        my $tree = { 'Detailed List of Plate(s)/Tube(s)' => $label_block };
        $label_block = create_tree( -tree => $tree );
    }
    
    $label_block .= $batch_block;

#    print "MAIN : $label_block";
   
    my $ref = alDente::Tools::alDente_ref($class, $id, -dbc=>$dbc);
    
    if (! $page->{top} && $class && $id =~/^\w+$/) { $page->{top} = section_heading( "$class: " . alDente::Tools::alDente_ref($class, $id, -dbc=>$dbc) ) }
    
    if ($label_block && $self->objects() == 1) { $page->{left} = $label_block }               ## put label in left section for single record pages
    elsif ($label_block && $self->objects() > 1) { 
        $page->{top} .= subsection_heading($short_label); 
        $page->{left} = $label_block;
#        unshift @{$page->{layers}}, { label => $BS->icon('info-circle'), content => $label_block };
    }    
  
    if ($dbc->mobile()) {
        $page->{left} .= $mobile_summary;
    }

    ## for alDente, by default the top sections will not show up on the mobile version ##
    $page->{visibility} = $visibility || { 'right' => ['desktop'], 'Lab' => ['desktop']};
    
    if ($Object && $id=~/^\w+$/) {
        ## Only include record table for single record pages ##
        if ($record_position eq 'layer') {
            if (ref $page->{layers} eq 'ARRAY') {                
                ## add reprint barcode (if applicable) ##
 #               if ($dbc->table_populated('Printer') && $dbc->barcode_prefix($class)) {
                    require LampLite::Barcode;
                    my $reprint = LampLite::Barcode->reprint_option(-table=>$class, -id=>$id, -return_html=>1, -type=>$class, -dbc=>$dbc);
                    push @{$page->{layers}}, { label => 'Barcode', content => $reprint };
 #               }    
 
                ## Add Standard DB_Record Layer ##
                push @{$page->{layers}}, { label => 'DB Record', content => $Object->display_Record( -filename => $dbc->config('tmp_web_dir') . "/$class.$id.html" , -id=>$id) };
            }
            elsif ($layers) {
                $dbc->debug_message("layers parameter should be array... not " . ref $layers);
            }
            else {
                ## add single layer for record contents... ##
                $page->{layers} = [{ label => 'DB Record', content => $Object->display_Record( -filename => $dbc->config('tmp_url_dir') . "/$class.$id.html" , -id=>$id) }];
            }
        } 
        elsif ($record_position eq 'right' && $dbc->config('screen_mode') =~ /desktop/) {
            ## only allow database dump on right when in desktop mode ##
            $format ||= $split_page_format;
            ## show Database details on right side if specified that way ##
            $page->{right_column} = $Object->display_Record( -filename => $dbc->config('tmp_web_dir') . "/$class.$id.html" , -id=>$id);
        }
        else {
            $dbc->error("undefined record_position parameter: $record_position");
        }
    }
    $page->{format} = $format;
    return $page;

}

#############
sub labels {
#############
    my $self = shift;
    
    my %args     = filter_input( \@_, -args => 'table,id' );
    my $table = $args{-table};
    my $id   = $args{-id};
    my $label_class = $args{-class};
    my $label_style = $args{-style};
    my $include = $args{-include} || 4;                             ## show N labels for individual wells in trays if -detailed param is not passed in
    my $label_span = $args{-label_span};
    my $add_to_label = $args{-add_to_label};
    my $detailed = $args{-detailed};
    my $collapse = $args{-collapse};
    my $group_options = $args{-group_options};    ## custom options to include in separate block applicable to group of objects ##
    
    my $label_size = $args{-label_size} || 'md';
	
    my $dbc      = $args{-dbc} || $self->{dbc};

    my @ids = Cast_List(-list=>$id, -to=>'array');

    ## col_spec below is for entire label section (so use full span of 12 since it may contain N internal label_span elements ##
    my $col_spec = 'col-' . $label_size . '-' . 12  unless $collapse;  ## only specify full column width if the label is NOT collapsed into a layer ##
    
    ## if ($dbc->mobile()) { ## only do this for mobiles perhaps ? ... 
    my $label_block = "<div class='row $col_spec'>\n<!-- start label row -->\n";

    my $short_label = $label_block;

    my $dbtable = $table;
    $dbtable =~s/(.*):://;
    
    my ($verbose);
    if ( int(@ids) == 1 ) { 
        ## If only displaying a single record ##
        $verbose = 1;
    }
    else {
        $short_label = $dbc->display_value(-table=>$dbtable, -id=>$ids[0]); ## alDente::Tools::alDente_ref($dbtable, $ids[0], -dbc=>$dbc);
        $short_label .= ' ... ';
        $short_label .= $dbc->display_value(-table=>$dbtable, -id=>$ids[-1]);
    }

    my $class = $table;
    $class =~s/Plate/Container/;
    
    
    my $max_list = 100;
    if (int(@ids) > $max_list) { return "too many to list (" . int(@ids) . " > $max_list)" }
        
  
    my ($col, $count, $limit, $total) = (0, 0, $include, int(@ids));
    my @slides;
    my $items;
    if (!$dbc->mobile()) { $items = 4; }
    foreach my $idN (@ids) {
        $col++;
        $count++;
        my $slide .= "<div class='$label_class' style='$label_style'>\n" 
        . "<div class='object-label'>\n"       ### separate from parent class to provide visible spacing automatically ###
        . $self->object_label(-id => $idN, -verbose => 1) ## want object labels in slides to be verbose
        . "</div> <!-- End of object-label $idN -->\n"
        . "</div> \n";
        push @slides, $slide;
    }
    if ( scalar(@ids) > 1 ) {
        $label_block = LampLite::JQuery::carousel(-slides => \@slides, -items => $items);
    }
    else { $label_block = $slides[0] }
    
    if ($add_to_label) { $label_block .= "<div class='row col-$label_size-12'>\n$add_to_label</div>\n" }
   
    if (@ids) {
        my $append = $self->std_options(-table=>$table, -id=>$id); ## move to different sections and include default options from page spec ##
        if ($group_options) { $append .= '<hr>' . $group_options }
        if (int(@ids) > 1) { 
            if ($dbc->config('screen_mode') eq 'desktop') {    
                $group_options = $append;
            }
            else {
                ## put batch options into modal for smaller screens ##
                $group_options = $BS->modal(-title=>"$dbtable Options - x" . int(@ids), -icon=>'bars', -body=>$append) . ' [Batch Options]';
            }
            $label_block .= "<div class='row $col_spec'></div>\n";
        }
        elsif  (int(@ids) == 1) {
            $label_block .= "<div class='row $col_spec'><HR>$append</div>\n";
            $group_options = '';
        }
    }
 
    return ($short_label, $label_block, $group_options);
}
    
####################
sub std_options {
####################
    my $self = shift;
    my %args = filter_input(\@_);
    
    my $id = $args{-id};
    my $table = $args{-table};
    my $options = $args{-options} || [];
    
    my $dbc = $self->dbc;
    
    my $dbtable = $table;
    $dbtable =~s/(.*):://;
    
    
    ## add option to edit attributes ##
    push @$options,  alDente::Attribute_Views::show_attribute_link( -dbc => $dbc, -object => $table, -id => $id );

    return join '<HR>', @$options;
}

# In case no generic_page is defined for a particular object class, this redirects output to standard
#
#########################
sub generic_page {
#########################
    my $self = shift;
    my %args = filter_input(\@_);
    my $dbc = $self->dbc;
    
    $dbc->warning("home page not defined for " . ref $self);
    Call_Stack();

    return { 
        top => section_heading('Generic Home Page'), 
        layers => [ { label => 'Options', content =>'generic home page not tied to specific object(s) - nothing currently in place'} ],
    };
}

#
# Customize standard page generation for alDente home pages.
#
#  * collapses 'left' section into layer by default if layers are defined
#  * sets visibility to desktop for centre, left sections
#
# Return: page generated
####################
sub generate_page {
####################
    my $self = shift;
    my %args = filter_input(\@_, -args=>'page');
    my $page = $args{-page};
    my $format = $args{-format} || $page->{format};
    my $visibility = $args{-visibility} || $page->{visibility};                   ## visibility of various sections (adapted in real time)
    my $collapse_to_layer = $args{-collapse_to_layer} || $page->{collapse_to_layer};     ## left / centre / right sections which should be collapsed into layers for mobile mode (at run time)
    my $span = $args{-span} || $page->{span};                                     ## span distribution for left / centre / right sections ##
    my $layer_type = $args{-layer_type} || $page->{layer_type};        ## layer style (eg tabs or accordion)
    
    $layer_type ||= $self->_layer_type($page->{layers}, $collapse_to_layer);    
    my $page = $self->SUPER::generate_page($page, -format=>$format, -layer_type=>$layer_type);

    return $page;
}

#
# Simple accessor to retrieve the appropriate navigation type based upon the page information.
#
# eg if layers are provided and there are more than 3 layers, the ui goes into accordion mode for the mobile version
# tab navigation is used for all desktop cases 
#
# Return: navigation mode (eg 'accordion' or 'tabs')
###############
sub _layer_type {
###############
    my $self = shift;
    my %args = filter_input(\@_, -args=>'layers, collapse');
    my $page_layers = $args{-layers};
    my $collapse = $args{-collapse};
    my $max      = $args{-max} || 3;  ## maximum number of layers in mobile mode before converting to accordion style
    
    my $dbc = $self->{dbc};
    
    if ($dbc->config('screen_mode') eq 'desktop') { return 'tabs' }
    
    my $layers = 0;
    if (ref $page_layers eq 'ARRAY') {
        $layers = int(@{$page_layers} );
    }
    elsif (ref $page_layers eq 'HASH') {
        $layers = int( keys %{$page_layers} );
    }
    else { $layers = 1 }
    
    if ($collapse) {
        my @keys = keys %{$collapse};
        $layers .= int(@keys);
    }
    
    if ($layers > $max) { return 'accordion' }        ## use accordion layers for mobile screens if more than 3 layers ##
      
    return 'tabs';    
}

####################
sub foreign_label {
####################
    my $self = shift;
    my %args = filter_input(\@_);
    my $dbc = $args{-dbc} || $self->{dbc};

    return $self->object_label(%args);    ## default object label from SDB::Object_Views
}

####################
sub object_label {
####################
    my $self = shift;
    my %args = filter_input(\@_);
    my $id = $args{-id} || $self->{id};
    my $table = $args{-table};

    my $dbc = $self->{dbc};
    
    my @display;

    my @list = Cast_List(-list=>$id, -to=>'array');
    foreach my $idN (@list) { 
        push @display, alDente::Tools::alDente_ref(-table=>$table, -id=>$id, -dbc=>$dbc);
    }
    
    my $list_type = 'UL';
    if (int(@list) > 1) { $list_type = 'OL' }
    
    return Cast_List(-list=>\@display, -to=>$list_type);
}
#
# Accessor to easily prompt users to update join table records for any object class
#
#
#
####################
sub join_records_plus {  ## use version in LampLite::DB_Views
####################
    my $self = shift;
    my %args = filter_input( \@_, -self => 'alDente::Object_Views' );

    #    my $mode       = $args{-mode} || 'popup';                                               ## allow scroll for users to add / edit multiple records at one time...
    my $table      = $args{-table};                                                         ## main table for defined record
    my $defined    = $args{ -defined };                                                     ## referenced field for defined record
    my $id         = $args{-id};                                                            ## id of defined record
    my $join       = $args{ -join };                                                        ## eg FK_Grp__ID
    my $dbc        = $args{-dbc} || $self->{dbc};
    my $join_table = $args{-join_table};
    my $filter     = $args{-filter};
    my $mode       = $args{-mode} || 'select,add';                                          ## select or scroll  (can indicate both select + add, but must choose select OR scroll)
    my $editable   = defined $args{-editable} ? $args{-editable} : $dbc->admin_access();    ## default to admin access if not specified
    my $title      = $args{-title};
    my $extra      = $args{-extra};                                                         ## extra field(s) in the join table
    my $edit       = $args{-edit};                                                          ## include buttons to edit / update records ...
    my $debug      = $args{-debug};

    my @current = $dbc->Table_find( $join_table, $join, "WHERE $defined = '$id'", -debug => $debug );
    my @options = $dbc->get_FK_info_list( $join, $filter );

    my ( $defined_table, $defined_field ) = $dbc->foreign_key_check($defined);
    my ( $joined_table,  $joined_field )  = $dbc->foreign_key_check($join);

    my @extra_fields = ();
    my $extra_fields_list;
    @extra_fields = Cast_List( -list => $extra, -to => 'array' ) if ($extra);
    $extra_fields_list = Cast_List( -list => $extra, -to => 'string', -autoquote => 0 ) if ($extra);

    $title ||= "Manage Links between $joined_table and $defined_table";
    my $q = new CGI;

    my $block = section_heading($title);

    my $note = "Note: If you do not see a $joined_table listed below, please inquire with the LIMS team (some options may be filtered out by default)";

    if ($editable) { $block .= $note }

    ## retrieve information for extra fields
    my %extra_info;
    if ($extra) {
        foreach my $field (@extra_fields) {
            my $col;
            if ( $field =~ /^FK/ ) {    # FK
                my @opts = $dbc->get_FK_info_list($field);
                $extra_info{$field}{type}    = 'FK';
                $extra_info{$field}{options} = \@opts;
            }
            else {
                my @field_info = $dbc->get_field_types( -table => $join_table, -field => $field );
                my ( $name, $type ) = split '\t', $field_info[0] if ( int(@field_info) );
                if ( $type =~ /enum/i ) {
                    my @opts = $dbc->get_enum_list( $join_table, $field );
                    $extra_info{$field}{type}    = 'enum';
                    $extra_info{$field}{options} = \@opts;
                }
                else {
                    $extra_info{$field}{type} = 'text';
                }
            }
        }
    }

    my $options = new HTML_Table( -colour => 'white' );
    $block
        .= alDente::Form::start_alDente_form( $dbc, 'join_records' )
        . $q->hidden( -name => 'cgi_application', -value => 'alDente::Object_App', -force => 1 )
        . $q->hidden( -name => 'Link',            -value => $join,                 -force => 1 )
        . $q->hidden( -name => 'Defined_Record',  -value => $defined,              -force => 1 )
        . $q->hidden( -name => 'Defined_ID',      -value => $id,                   -force => 1 )
        . $q->hidden( -name => 'Join_Table',      -value => $join_table,           -force => 1 )
        . $q->hidden( -name => 'HomePage',        -value => $table,                -force => 1 )
        . $q->hidden( -name => 'ID',              -value => $id,                   -force => 1 );
    if ($extra) { $block .= $q->hidden( -name => 'Extra_Fields', -value => $extra_fields_list, -force => 1 ) }

    if ( $editable && $mode =~ /scroll/ ) {
        ## provide scrolling list to re-define full list of applicable links (quicker and easier for multiple edits, but not quite as clean as select + add for simple management) ##
        $options->Set_sub_header("<h3>Re-define Links to $joined_table:</h3>");
        my $current_list = join ',', @current;
        my @default = $dbc->get_FK_info_list( $join, -condition => "WHERE ${joined_table}_ID IN ($current_list)" );
        my $default;
        my $col1 = alDente::Tools::search_list( -name => $join, -element_name => "Reset-$join", -filter => 1, -search => 1, -default => \@default, -force => 1, -mode => 'scroll', -scroll => 10, -condition=>$filter);

        my $col2 .= $q->submit( -name => 'rm', -value => 'Reset Links', -class => 'Action' );
        $col2 .= '<P>' . $q->reset( -name => 'Reset', -class => 'Std' );

        $options->Set_Row( [ $col1, $col2 ] );
    }
    elsif ( $mode =~ /select/ ) {
        ##   provide checkboxes to de-select existing linked records ##
        $options->Set_sub_header( subsection_heading("Currently Linked to ${joined_table}s:") );
        my $col1 = new HTML_Table( -colour => 'white' );
        if ($extra) {
            $col1->Set_Row( [ $joined_table, @extra_fields ] );
        }

        if (@current) {
            if ($editable) {
                foreach my $current_link (@current) {
                    my $current = $dbc->get_FK_info( $join, $current_link );

                    my $label = $dbc->display_value($joined_table, $current_link); ## alDente::Tools::alDente_ref( $joined_table, $current_link, -dbc => $dbc );    ## $dbc->get_FK_info($join, $current_link);
                    my $link;
                    if ( $edit && grep /$current/, @options ) {
                        $link .= Show_Tool_Tip( $q->checkbox( -name => "Select-$join", -value => $current_link, -label => '', -checked => 1, -force => 1 ), "Deselect to remove user from this group" );
                    }
                    else {
                        $link .= Show_Tool_Tip( $BS->icon('check'), "Current user does not have permission to control $current membership\nPlease contact Admin from that group if required" )
                            . $q->hidden( -name => "Select-$join", -value => $current_link, -force => 1 );
                    }

                    my @cols = ( $link, $label );

                    foreach my $field (@extra_fields) {
                        my ($default) = $dbc->Table_find( $join_table, $field, "where $defined = '$id' and $join = '$current_link' " );
                        my $col;
                        if ( $extra_info{$field}{type} eq 'FK' ) {
                            $col = alDente::Tools::search_list( -name => "$current_link-$field", -filter => 1, -search => 1, -options => $extra_info{$field}{options}, -default => $default, -breaks => 2 );
                        }
                        elsif ( $extra_info{$field}{type} eq 'enum' ) {
                            $col = popup_menu( -name => "$current_link-$field", -values => $extra_info{$field}{options}, -default => $default, -force => 1 );
                        }
                        else {
                            $col = textfield( -name => "$current_link-$field", -size => 20, -default => $default, -force => 1 );
                        }
                        push @cols, $col;
                    }
                    $col1->Set_Row( \@cols );
                }
                my $col2;
                if ($edit) { $col2 = $q->submit( -name => 'rm', -value => 'Update Links', -class => 'Action' ) }
                $options->Set_Row( [ $col1->Printout(0), $col2 ] );
            }
            else {
                ## not editable .. just show list ##
                foreach my $current_link (@current) {
                    my $label = $dbc->get_FK_info( $join, $current_link );
                    my @cols = ($label);
                    foreach my $field (@extra_fields) {
                        my ($value) = $dbc->Table_find( $join_table, $field, "where $defined = '$id' and $join = '$current_link' " );
                        push @cols, $value;
                    }
                    $col1->Set_Row( \@cols );
                }
                $options->Set_Row( [ $col1->Printout(0) ] );
            }
        }
        else { $options->Set_Row( ['(no current links)'] ) }
    }

    if ( $editable && $mode =~ /add/ && $edit ) {
        ## provide dropdown list to add single linked record ##
        $options->Set_sub_header( subsection_heading("Add Link to single $joined_table") );
        my $col1 = new HTML_Table( -colour => 'white' );
        my $add = alDente::Tools::search_list( -dbc => $dbc, -name => "Add-$join", -filter => 1, -search => 1, -options => \@options, -breaks => 2 );
        my @cols = ($add);
        if ($extra) {
            $col1->Set_Row( [ $joined_table, @extra_fields ] );
            foreach my $field (@extra_fields) {
                my $col;
                if ( $extra_info{$field}{type} eq 'FK' ) {
                    $col = alDente::Tools::search_list( -name => "Add-$field", -filter => 1, -search => 1, -options => $extra_info{$field}{options}, -breaks => 2 );
                }
                elsif ( $extra_info{$field}{type} eq 'enum' ) {
                    $col = popup_menu( -name => "Add-$field", -values => $extra_info{$field}{options}, -force => 1 );
                }
                else {
                    $col = textfield( -name => "Add-$field", -size => 20, -force => 1 );
                }
                push @cols, $col;
            }
        }
        $col1->Set_Row( \@cols );
        my $col2 = $q->submit( -name => 'rm', -value => 'Add Link', -class => 'Action' );
        $options->Set_Row( [ $col1->Printout(0), $col2 ] );
    }
    $block .= $options->Printout(0);
    $block .= $q->end_form();

    return $block . '<hr>';

}

################################################################
# Block of code generating table including object labels.
#..
# Relies upon local $object->foreign_label method to return object label.
#
# (used by Tube, Library_Plate, Source,
#
# Return: HTML for table
#########################
sub multiple_labels {
#########################
    my %args = filter_input( \@_, -args => 'type,ids' );
    my $type = $args{-type};
    my $ids  = $args{-ids};
    my $dbc  = $args{-dbc};

    my $col      = 0;
    my $colspan  = 0;
    my $cols     = $args{-cols} || 6;
    my $max_rows = $args{-rows} || 4;    ## limit rows of plate_labels displayed to this many rows...
    my $rows     = 1;
    my @all_ids  = split ',', $ids;
    my $num_ids  = int(@all_ids);

    use alDente::Source_Views;
    my $object = 'alDente::' . $type . '_Views';

    #    eval { "require $object" }

    my $block = "<Table cellpadding=10 width=100% border=1><TR>";
    foreach my $id (@all_ids) {
        ## if more than  one id provide simple label for each id scanned ##
        $block .= "<TD valign=top height=1 nowrap align=left>";

        $block .= $object->foreign_label( -dbc => $dbc, -id => $id, -verbose => 1, -border => 0, -colour => 'white' );
        $block .= "</TD>";
        $col++;
        if ( $col >= $cols ) {
            ## limit columns to 8 and start a new row if more ids ##
            $block .= "</TR><TR>";
            $col     = 0;
            $colspan = $cols;
            $rows++;
        }
        ## limit display in case 500 ids are being created...
        if ( ( $rows > $max_rows ) && ( $num_ids > $max_rows * $cols ) ) {
            $block .= "<TD>...(showing " . $max_rows * $cols . " / $num_ids)...</TD>";
            last;
        }
    }
    $colspan ||= $col;
    $block .= "</TR></Table>\n";    ## Table cellpadding=10 width=100%><TR>";

    return $block;
}

1;
