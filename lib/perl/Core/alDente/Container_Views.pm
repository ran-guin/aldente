####################
# Container_Views.pm #
####################
#
# This contains various Container (Plate) view pages directly including:
#
# home_plate - page generated by clicking on generic Plate icon
# plates_box - layer for key lab plate options (appearing on plate section of Lab layer options)
#
# layers appearing when a single plate is the object of focus:
# Plate_button_options - main page generator
# search
# misc
# start_protocol
# choose_set
# extract
# transfer
# std_plate_actions
#
#sub home_plate {
#sub plates_box {
#sub select_wells {
#sub _print_generations {
#sub select_wells_on_plate {
#sub mark_plates_view {
#sub show_Solutions {
#sub view_Ancestry {
#sub view_History {
#sub _generate_history_row {
#sub original_form {
#sub _child_form {
#sub update_plate_schedule_frm {
#sub fail_toolbox {
#sub Plate_button_options {
#sub search_options {
#sub misc_options {
#sub choose_set {
#sub extract_prompt {
#sub transfer_prompt {
#sub std_plate_actions {
#sub start_protocol {
#sub Set_options {

#sub well_options {
#sub transposon_options {
#sub convert_wells {
#sub show_well_conversion_tool {
#sub Tube_home_page {
#sub Tube_button_options {

#

package alDente::Container_Views;
use base alDente::Object_Views;

use RGTools::RGIO;
use RGTools::Conversion;
use RGTools::RGmath;

use SDB::HTML;
use SDB::DBIO;
use SDB::CustomSettings;

use alDente::Validation;
use alDente::SDB_Defaults;
use alDente::Tools;
use alDente::QA_Views;
use alDente::Pipeline;
use alDente::Attribute_Views;
use alDente::Grp;
use CGI qw(:standard);
use strict;

use LampLite::Bootstrap;

use vars qw(%Configs $Security $scanner_mode);

use LampLite::CGI;
my $q  = new LampLite::CGI;
my $BS = new Bootstrap;

#
# Standard home page for Container (Plate) object
#
#
# Return home page view
###################
sub home_page {
###################
    my $self = shift;
    my %args = filter_input( \@_ );
    my $id   = $args{-id};

    my $dbc = $self->{dbc};

    SDB::Errors::log_deprecated_usage('Container Home Page');

    my $Object;
    if ($id) {
        $Object = new alDente::Container( -id => $id, -dbc => $dbc );
    }

    return $self->std_home_page( -Object => $Object, -id => $id );
}

##################
sub home_plate {
###################
    my $self = shift;
    my %args = filter_input( \@_ );

    my $dbc = $args{-dbc} || $self->{dbc};

    SDB::Errors::log_deprecated_usage('Container generic home page');

    my $Object = new alDente::Container( -dbc => $dbc );

    return $self->std_home_page( -Object => $Object );
}

############################################
#
# Home page generated by Plate Icon
#
############################################
sub generic_page {
#######################
    my $self   = shift;
    my %args   = filter_input( \@_ );
    my $dbc    = $args{-dbc} || $self->{dbc};
    my $output = section_heading("Plate/Tube Home Page");

    my %library_plate;
    my $search_header = LampLite::Login_Views->icons( 'Search', -dbc => $dbc );

    my @layers;
    my $page;

    # h3('Search:') . '<BR>' .
    #    "\n<img src='/$URL_dir_name/$image_dir/flashlight.png'>";

    my $search_plate_block    = alDente::Form::init_HTML_table("Search Plate / Tube Options");
    my $search_protocol_block = alDente::Form::init_HTML_table("Search Protocol Options");
    require alDente::Rack_Views;

    $search_protocol_block->Set_Row( [ &SDB::DB_Form_Viewer::Table_search( $dbc, 'Prep' ) . hr ] );

    $search_plate_block->Set_Row(
        [         &alDente::Form::start_alDente_form( $dbc, 'PlateStore' )
                . hidden( -name => 'cgi_application', -value => 'SDB::DB_Object_App', -force => 1 )
                . hidden( -name => 'rm', -value => 'Search Records', -class => 'Search', -force => 1 )
                . hidden( -name => 'Table', -value => 'Plate', -force => 1 )
                . submit( -name => 'Button', -value => 'Search Container Records', -class => 'Search' )
                . checkbox( -name => 'Multi-Record' )
                . end_form()
        ]
    );

    $search_plate_block->Set_Row(
        [         &alDente::Form::start_alDente_form( $dbc, 'TubeStore' )
                . hidden( -name => 'cgi_application', -value => 'SDB::DB_Object_App', -force => 1 )
                . hidden( -name => 'rm', -value => 'Search Records', -class => 'Search', -force => 1 )
                . hidden( -name => 'Table',     -value => 'Plate,Tube',            -force => 1 )
                . hidden( -name => 'Condition', -value => 'FK_Plate__ID=Plate_ID', -force => 1 )
                . submit( -name => 'Button', -value => 'Search Tube Records', -class => 'Search' )
                . end_form()

                #	 . checkbox( -name => 'Multi-Record' )  ## not yet working for multiple tables... needs refactoring...
        ]
    );

    $search_plate_block->Set_Row( [ alDente::Rack_Views::find_in_rack( -find => 'Plate', -dbc => $dbc ) ] );

    my $db_header = h3('Database Definitions:') . '<BR>' . LampLite::Login_Views->icons( 'Plates', -pic_only => 1, -dbc => $dbc );

    #	    "\n<img src='/$URL_dir_name/$image_dir/chem.png'>";

    my $db_block = alDente::Form::init_HTML_table("Container Formats");
    my $db_part = alDente::Form::start_alDente_form( $dbc, 'DB_Block' ) . submit( -name => 'New Entry', -value => 'New Plate_Format', -class => "Std" ) . hspace(10);
    $db_part .= hidden( -name => 'Table', -value => 'Plate', -force => 1 );
    $db_part .= end_form();

    $db_block->Set_Row( [$db_part] );
    $db_block->Set_Row( [ $dbc->Table_retrieve_display( 'Plate_Format', [ 'Plate_Format_Style', 'Plate_Format_Type' ], "WHERE Plate_Format_Type <> 'Undefined - To Be Determined' ORDER BY Plate_Format_Style", -distinct => 1, -return_html => 1 ) ] );
    $db_block->Set_Row( [ submit( -name => 'Edit Table', -value => 'Edit Plate_Format', -class => "Search" ) ] );

    my $plate_options_header = h3('Annotate / Delete');

    my $plate_options_block  = alDente::Form::init_HTML_table("Annotate / Delete");
    my $plate_ancestry_block = alDente::Form::init_HTML_table("View Ancestry");
    $plate_options_block->Set_Row( [ alDente::Form::start_alDente_form( $dbc, 'Plate_Option_Block' ) ] );

    $plate_options_block->Set_Row( [ "Made within " . textfield( -name => 'Plates Made Within', -size => 3, -default => '7' ) . " days" ] );
    $plate_options_block->Set_Row(
        [         checkbox( -name => 'All users', -checked => 0, -value => 'ON', -label => 'All users' ) 
                . vspace()
                . radio_group(
                -name   => 'Type',
                -class  => 'inline',
                -values => [ 'Library_Plate', 'Tube', 'Array' ],
                -labels => {
                    'Library_Plate' => 'Plate',
                    'Tube'          => 'Tube',
                    'Array'         => 'Array'
                },
                -default => 'Library_Plate'
                )
        ]
    );

    $plate_options_block->Set_Row( [ submit( -name => 'rm', -value => 'Delete/Annotate Plates', -class => "Search" ) ] );
    $plate_ancestry_block->Set_Row( [ submit( -name => 'rm', -value => 'View Ancestry', -class => "Std" ) . " for " . textfield( -name => 'Seek Plate', -size => 10 ) . " (Scan Plate or enter plate number)" ] );
    $plate_options_block->Set_Row( [ hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 ) . end_form() ] );

    push @layers, { label => "Search for Plates / Tubes", content => $search_plate_block->Printout(0) };
    push @layers, { label => "Search Protocols",          content => $search_protocol_block->Printout(0) };
    push @layers, { label => "Container Formats",         content => $db_block->Printout(0) };
    push @layers, { label => "Annotate / Delete",         content => $plate_options_block->Printout(0) };
    push @layers, { label => "View Ancestry",             content => $plate_ancestry_block->Printout(0) };

    return {
        top    => section_heading("Plate / Tube Home Page"),
        layers => \@layers
    };
}

####################
sub confirm_event {
####################
    my %args      = filter_input( \@_, -args => 'event' );
    my $event     = $args{-event};                           ## associated rm should be '$event Plates'
    my $ids       = $args{-ids};
    my $notes     = $args{-notes};
    my $dbc       = $args{-dbc};
    my $reason_id = $args{-reason_id};                       # optional reason (eg FailReason)

    my $page;

    my $stats = alDente::Tray::group_ids( $dbc, 'Plate', $ids );
    $dbc->warning("Are you sure you want to $event the following $stats->{physical_plates} Plate(s) ?!");
    $page .= $dbc->Table_retrieve_display(
        'Plate,Rack',
        [ 'Plate_ID', 'FK_Library__Name as Library', 'Plate_Number as Number', 'Rack_Alias as Current_Location', 'Plate_Status as Current_Status', 'Failed as Current_Failed' ],
        "WHERE FK_Rack__ID=Rack_ID AND Plate_ID in ($ids)",
        -return_html => 1
    );

    $page .= '<hr>';
    
    $page .= alDente::Form::start_alDente_form( $dbc, 'PlateEventConfirmation' );

    if ( $event =~ /Fail/ ) {
        $page .= submit(
            -name    => 'rm',
            -value   => "$event Plates",
            -class   => 'Action',
            -onClick => "return validateForm(this.form)"
        );    # ensure Fail Reason is set

        if ($reason_id) {
            $page .= hidden( -name => 'FK_FailReason__ID', -value => $reason_id ) . set_validator( -name => 'FK_FailReason__ID', -mandatory => 1 );
            $page .= vspace(5) . "Fail Reason: " . alDente::Tools::alDente_ref( 'FailReason', $reason_id, -dbc => $dbc );
        }
        else {
            $page .= '<BR>' . prompt_for_Fail_Reason($dbc);
        }
    }
    else {

        $page .= submit( -name => 'rm', -value => "$event Plates", -class => 'Action' );
    }

    $page
        .= hspace(10)
        . submit( -name => 'rm', -value => 'Back', -class => 'Std' )
        . hspace(10)
        . submit( -name => 'rm', -value => 'Cancel', -class => 'Std' )
        . hidden( -name => 'Plate IDs', -value => $ids, -force => 1 )
        . hidden( -name => 'Confirmed', -value => 1 )
        . hidden( -name => 'Back_To',         -value => $event )
        . hidden( -name => 'cgi_application', -value => 'alDente::Container_App' );

    $page .= vspace(5) . 'Annotate Comments: ' . textfield( -name => 'Mark Note', -size => 48, -value => $notes, -force => 1 );

    $page .= end_form;
    print $page;
    &main::leave();
    return;
}

###############################################################################################
# small box containing link to primary plate handling actions
# (eg appearing on main Lab layer for Departments)
###################
sub plates_box {
###################
    my %args = @_;

    my $type              = $args{-type};
    my $basic_choices_ref = $args{-basic_choices};
    my $id_choices_ref    = $args{-id_choices};                          ## from Annotate, Delete, Plate History, View Ancestry, Set No Grows, Set Slow Grows, Set Empty Wells, Set Problematic Wells, Set Unused Wells
    my $lib_choices_ref   = $args{-lib_choices};
    my $labels_ref        = $args{-labels};
    my $include_rearray   = $args{-include_rearray};
    my $department        = $args{-department} || $Current_Department;
    my $dbc               = $args{-dbc};
    my @access;
    @access = @{ $args{-access} } if $args{-access};

    my @basic_choices;
    @basic_choices = @{$basic_choices_ref} if $basic_choices_ref;
    my @id_choices;
    @id_choices = @{$id_choices_ref} if $id_choices_ref;
    my @lib_choices;
    @lib_choices = @{$lib_choices_ref} if $lib_choices_ref;
    my %labels;
    %labels = %{$labels_ref} if $labels_ref;

    # use supplied order
    #
    #    @basic_choices = sort(@basic_choices);
    #    @id_choices    = sort(@id_choices);
    #    @lib_choices   = sort(@lib_choices);

    my $cgi_app = "&cgi_application=alDente::Container_App";
    my $add_plate_link = &Link_To( $dbc->config('homelink'), '<span class=small>(create)</span>', "$cgi_app&rm=New Plate" );    ## "&New+Library_Plate=1&New+Plate+Type=Original",$Settings{LINK_COLOUR});
    my $reserve_plate_link
        .= &Link_To( $dbc->config('homelink'), '<span class=small>(reserve)</span>', "$cgi_app&rm=New Plate&Status=Reserved" );    ## "&New+Library_Plate=1&New+Plate+Type=Original&Status=Reserved",$Settings{LINK_COLOUR});# if ($type eq 'Library_Plate') ;

    my $add_tube_link     = &Link_To( $dbc->config('homelink'), '<span class=small>(create)</span>',  "$cgi_app&rm=New Tube" );                    ## "&New+Tube=1&New+Plate+Type=Original",$Settings{LINK_COLOUR});
    my $reserve_tube_link = &Link_To( $dbc->config('homelink'), '<span class=small>(reserve)</span>', "$cgi_app&rm=New Tube&Status=Reserved" );    ## "&New+Tube=1&New+Plate+Type=Original&Status=Reserved",$Settings{LINK_COLOUR});# if ($type eq 'Tube') ;
    my $output = alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'plates', -dbc => $dbc );
    $output .= $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );

    my $search_link
        = "Search for: "
        . &Link_To( $dbc->config('homelink'), 'Rack', '&Search+for=1&Table=Rack', -tooltip => 'Shelf or Freezer Locations' )
        . &hspace(5)
        . &Link_To( $dbc->config('homelink'), "Containers", '&Search+for=1&Table=Plate', -tooltip => 'valid for either tubes or library plates' )
        . &hspace(5)
        . &Link_To( $dbc->config('homelink'), "Tubes", '&Search+for=1&Table=Tube', -tooltip => 'specific to Tubes' )
        . &hspace(5)
        . &Link_To( $dbc->config('homelink'), "Library Plates", '&Search+for=1&Table=Library_Plate', -tooltip => 'specific to 96 or 384-well plates' );

    my $base_table;

    my $plateimg;
    if ( $Current_Department eq 'Lib_Construction' ) {
        $plateimg = LampLite::Login_Views->icons( 'Plates', -dbc => $dbc );
    }
    else {
        $plateimg = LampLite::Login_Views->icons( 'Tubes', -dbc => $dbc );
    }

    my ( $left, $right );
    if ( grep( /Lab/, @access ) ) {
        $left  = "Plates " . hspace(5) . $add_plate_link . $reserve_plate_link . hspace(20) . "Tubes" . hspace(5) . $add_tube_link . $reserve_tube_link;
        $right = $search_link;
    }
    elsif ( grep( /Bioinformatics/, @access ) ) {
        $left  = "${type}s";
        $right = '-';
    }
    else {    ## this was not included originally (below) ... why ?
        $left = "${type}s";
    }

    $dbc->Benchmark('plates_box_init_table');
    my $table = alDente::Form::init_HTML_table( -subsection => 'Standard Plate / Tube Handling' );    ## $base_table;

    #    my @libraries = @{$dbc->Security->get_accessible_items(-table=>'Library')};
    my @formats = $dbc->get_FK_info( 'FK_Plate_Format__ID', -list => 1 );

    if ( grep( /Lab/, @access ) ) {

        #        $table->Set_Row([ "Plates",$add_plate_link . $reserve_plate_link ]);
        #        $table->Set_Row([ "Tubes",$add_tube_link . $reserve_tube_link ]);
        #        $table->Set_Row([ "Search For",$search_link]);
        $table->Set_Row(
            [   'Enter Plate ID(s): ',
                Show_Tool_Tip( $q->textfield( -name => 'Plate IDs', -force => 1, -size => 15, -default => "" ), 'Scan plates or enter plate set number if grabbing plate set.' ) . ' <-  ' . $q->popup_menu(
                    -name   => 'rm',
                    -values => [ '-- Select --', @id_choices ],

                    #labels=>\%labels,
                    -default => '--Select--',
                    -force   => 1,
                    -width   => 200
                    )

                    . RGTools::Web_Form::Image_Submit(
                    -dbc  => $dbc,
                    -name => 'go',
                    -src  => "/$Configs{'URL_dir_name'}/images/icons/arrow_fwd_blue.gif",
                    )
            ]
        );

    }
    $table->Set_Alignment( 'right', 1 );
    $table->Set_Alignment( 'left',  2 );

    $output .= $table->Printout(0);
    $output .= $q->hidden( -name => 'preset', -value => 1 );    ## pre-select items in this form
    $output .= $q->end_form;

    $dbc->Benchmark('plates_box_start_form');

    $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'del_plates' );
    $output .= $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );

    #
    $table = alDente::Form::init_HTML_table( -subsection => 'Delete / Annotate Plates & Tubes' );

    my $form = 'del_plates';                                    ## 'del_plates';

    ## <CONSTRUCTON> - remove hardcoded Department specific coding (below) if possible (?)

    if ( grep( /Lab/, @access ) ) {
        if ( $Current_Department eq 'Microarray' ) {
            $table->Set_Row(
                [   RGTools::Web_Form::Submit_Button( -dbc => $dbc, form => $form, name => 'rm', label => "Delete/Annotate Plates" )
                        . " &emsp; "
                        . $q->radio_group( -name => "Type", -values => [ 'Library_Plate', 'Tube', 'Array' ], -labels => { 'Library_Plate' => 'Plates', 'Tube' => 'Tubes', 'Array' => 'Microarray' }, -default => 'Tube' ),
                    " &emsp; Made within " . $q->textfield( -name => 'Plates Made Within', -force => 1, -size => 3, -default => "7" ) . 'days' . &hspace(1) . Show_Tool_Tip( $q->checkbox( -name => 'All users' ), "Include plates made by all users" )
                ]
            );
        }
        elsif ( $Current_Department eq 'Lib_Construction' ) {
            $table->Set_Row(
                [   RGTools::Web_Form::Submit_Button( -dbc => $dbc, form => $form, name => 'rm', label => "Delete/Annotate Plates" )
                        . " &emsp; "
                        . $q->radio_group( -name => "Type", -values => [ 'Library_Plate', 'Tube' ], -labels => { 'Library_Plate' => 'Plates', 'Tube' => 'Tubes' }, -default => 'Tube' ),
                    " &emsp; Made within " . $q->textfield( -name => 'Plates Made Within', -force => 1, -size => 3, -default => "7" ) . 'days' . &hspace(1) . Show_Tool_Tip( $q->checkbox( -name => 'All users' ), "Include plates made by all users" )
                ]
            );
        }
        else {
            $table->Set_Row( [ "Specify Library: ", alDente::Tools::search_list( -dbc => $dbc, -name => 'Plate.FK_Library__Name', -search => 1, -filter_by_dept => 1, -filter => 1, -breaks => 1, -action => 'search' ) ] );
            $table->Set_Row( [ "Specify Format: ", Show_Tool_Tip( RGTools::Web_Form::Popup_Menu( -dbc => $dbc, -name => 'Plate_Format_Type', -value => [ '', @formats ] ), "Include Plates of specified Format" ) ] );
            $table->Set_Row( [ "Include Type(s): ", alDente::Tools::search_list( -dbc => $dbc, -name => 'Plate_Type', -table => 'Plate', -mode => 'checkbox', -default => [ 'Tube', 'Library_Plate' ] ) ] );

            #		      $q->checkbox(-name=>'Plate_Type',-value=>'Plate',-checked=>1)
            #		      . &hspace(5)
            #		      . $q->checkbox(-name=>'Plate_Type',-value=>'Tube',-checked=>1)
            #	  ]);
            $table->Set_Row( [ "Made within: ", $q->textfield( -name => 'Plates Made Within', -force => 1, -size => 3, -default => "7" ) . 'days' . &hspace(1) . Show_Tool_Tip( $q->checkbox( -name => 'All users' ), "Include plates made by all users" ) ] );

            $table->Set_Row( [ '', RGTools::Web_Form::Submit_Button( -dbc => $dbc, form => $form, name => "rm", label => "Delete/Annotate Plates" ) . " <br><i>Find Plates based upon above search criteria</i>" ] );
        }
    }

    $table->Set_Alignment( 'right', 1 );
    $table->Set_Alignment( 'left',  2 );

    $output .= $table->Printout(0);
    $output .= $q->end_form();

    $dbc->Benchmark('plates_box_end_form');

    if ($include_rearray) {
        $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'Rearray' );
        $output .= $q->hidden( -name => 'cgi_application', -value => 'alDente::ReArray_App' );

        #
        $table = alDente::Form::init_HTML_table( -subsection => 'Rearray Plates / Tubes' );

        $table->Set_sub_header("<HR>");
        $table->Set_Row(
            [   'Enter Rearray ID: ',
                &hspace(55)
                    . Show_Tool_Tip( $q->textfield( -name => 'Request IDs', -force => 1, -size => 15, -default => "" ), 'Enter Rearray IDs to view' )
                    . hspace(5)
                    . $q->submit( -name => 'rm', -value => 'View ReArray', -class => "Std" )
                    . &hspace(40)
                    . $q->submit( -value => "Rearray Home", -class => "Std" )
            ]
        );

        $table->Set_Alignment('left');

        $output .= $table->Printout(0);
        $output .= $q->end_form();
    }

    $dbc->Benchmark('plates_box_include_rearray');

    #    my $title = $plateimg . hspace(40) . $left . hspace(100) . $right;
    $base_table = alDente::Form::init_HTML_table(
        'Containers',
        -margin => 'on',
        -left   => $left,
        -right  => $right,
    );

    $base_table->Set_Row( [ $plateimg, $output ] );
    return $base_table->Printout(0);
}

#################################################
#
# Generate interface to select wells for annotation.
#
#
# Return: web page interface to select wells
###################
sub select_wells {
###################
    my %args        = filter_input( \@_ );
    my $dbc         = $args{-dbc};
    my $select_type = $args{-type};          # No_Grows, Slow_Grows, or Unused Wells
    my $status_type = $args{-status};        # Production or Test..
    my $plate_ids   = $args{-plate_id};

    my $multi_mode;
    my $plate_info;
    my $tray_of_tubes = 0;

    ## Look at first plate....
    my ($first_plate) = split( ',', $plate_ids );
    my $tray;

    my %availability;

    ## Check to see if they want to set wells for a tray (more than 1 plate scanned in)
    #   if($plate_ids=~/,/) {
    my $tray_flag = alDente::Tray::exists_on_tray( $dbc, 'Plate', $first_plate );

    if ($tray_flag) {
        ## If exists on a tray
        $tray = alDente::Tray->new( -dbc => $dbc, -plate_ids => $plate_ids );
        ## And all plates are in the same tray

        if ( scalar( keys %{ $tray->{trays} } ) == 1 ) {
            $multi_mode = 1;
            my @quad_info = $dbc->Table_find( "Plate_Tray,Well_Lookup", "Plate_384", "WHERE Plate_Position=Quadrant AND FK_Plate__ID in ($plate_ids)" );
            foreach my $row (@quad_info) {
                my $well = uc($row);
                $availability{$well} = 1;
            }
            if ( int(@quad_info) == 0 ) {
                $tray_of_tubes = 1;
            }

        }
    }

    if ($multi_mode) {
        $plate_info = "TRA" . $tray->{tray_ids};

        #      $plate_info = get_FK_info($dbc,'FK_Tray__ID',$tray->{tray_ids});  this one displays mul|tray500 for example
    }
    else {
        ### If not multi mode, we'll only display wells for first plate
        $plate_ids = $first_plate;
        $plate_info = $dbc->get_FK_info( 'FK_Plate__ID', $first_plate );
    }
    my @plate_info_fields
        = ( 'Parent_Quadrant', 'Max_Row', 'Max_Col', 'No_Grows', 'Slow_Grows', 'Unused_Wells', 'Problematic_Wells', 'Empty_Wells', 'Plate_Test_Status', 'Plate_Size', 'Plate_Comments', 'Plate.Plate_Class', 'Plate_Tray.Plate_Position AS Position' );
    my %wells = $dbc->Table_retrieve( 'Plate,Library_Plate,Plate_Format LEFT JOIN Plate_Tray ON Plate_Tray.FK_Plate__ID=Plate_ID',
        \@plate_info_fields, "WHERE Library_Plate.FK_Plate__ID=Plate_ID AND Plate_Format_ID=FK_Plate_Format__ID AND Plate_ID IN($plate_ids)" );
    my ( $size, @NGs, @SGs, @Us, @Ps, @Es );

    if ( $multi_mode && !$tray_of_tubes ) {
        my %quads_included;
        my $total_plates = scalar( my @array = split( ',', $plate_ids ) );
        for ( my $i = 0; $i < $total_plates; $i++ ) {
            $size = $wells{Plate_Size}[$i];
            if ( $size != '96-well' ) {
                ## Check to see if all plates are 96 well or no
                Message("non-96 well plate found in a multi plate");
                Call_Stack();

            }
            elsif ( defined $quads_included{ $wells{Position}[$i] } ) {
                ## Check to see if two plates with the same positions are not listed
                Message( "Another plate in Current Plates has the same position (" . $wells{Position}[$i] . ") as  plate " . $wells{Plate_ID}[$i] );
                Call_Stack();

            }
            else {
                $quads_included{ $wells{Position}[$i] } = 1;
                my @wells = &alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{No_Grows}[$i], -target_size => '384', -quadrant => $wells{Position}[$i] );
                push( @NGs, alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{No_Grows}[$i],          -target_size => '384', -quadrant => $wells{Position}[$i] ) ) if ( $wells{No_Grows}[$i] );
                push( @SGs, alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{Slow_Grows}[$i],        -target_size => '384', -quadrant => $wells{Position}[$i] ) ) if ( $wells{Slow_Grows}[$i] );
                push( @Us,  alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{Unused_Wells}[$i],      -target_size => '384', -quadrant => $wells{Position}[$i] ) ) if ( $wells{Unused_Wells}[$i] );
                push( @Ps,  alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{Problematic_Wells}[$i], -target_size => '384', -quadrant => $wells{Position}[$i] ) ) if ( $wells{Problematic_Wells}[$i] );
                push( @Es,  alDente::Well::Convert_Wells( -dbc => $dbc, -wells => $wells{Empty_Wells}[$i],       -target_size => '384', -quadrant => $wells{Position}[$i] ) ) if ( $wells{Empty_Wells}[$i] );
            }
        }
    }
    else {
        $size = $wells{Plate_Size}[0];
        @NGs  = split( ',', $wells{No_Grows}[0] );
        @SGs  = split( ',', $wells{Slow_Grows}[0] );
        @Us   = split( ',', $wells{Unused_Wells}[0] );
        @Ps   = split( ',', $wells{Problematic_Wells}[0] );
        @Es   = split( ',', $wells{Empty_Wells}[0] );
    }

    ### These variables will be only used when we are NOT in multi mode
    my $max_row         = $wells{Max_Row}[0];
    my $max_col         = $wells{Max_Col}[0];
    my $status          = $wells{Plate_Test_Status}[0];
    my $plate_class     = $wells{Plate_Class}[0];
    my $comments        = $wells{Plate_Comments}[0];
    my $parent_quadrant = $wells{Parent_Quadrant}[0];
    $status_type ||= $status;

    # remove zeropads
    @NGs = map { RGTools::Conversion::format_well( $_, 'nopad' ) } @NGs;
    @SGs = map { RGTools::Conversion::format_well( $_, 'nopad' ) } @SGs;
    @Us  = map { &format_well( $_,                     'nopad' ) } @Us;
    @Ps  = map { &format_well( $_,                     'nopad' ) } @Ps;
    @Es  = map { &format_well( $_,                     'nopad' ) } @Es;

    ############### generate list of all wells ##################
    my @all_wells;

    my $label_colour  = "yellow";
    my $row_colour    = toggle_colour( undef, 'whitesmoke', 'cream' );
    my $highlight     = "red";
    my $dim_highlight = "pink";
    my $U_highlight   = "gray";
    my $P_highlight   = "orange";
    my $E_highlight   = "lightgreen";

    my $NGselected = join( ',', @NGs );
    my $SGselected = join( ',', @SGs );
    my $Uselected  = join( ',', @Us );
    my $Pselected  = join( ',', @Ps );
    my $Eselected  = join( ',', @Es );

    my $selected;
    my $selected_color;
    my $selected_rm;
    if    ( $select_type =~ /^No/ )          { $selected = $NGselected; $selected_color = $highlight;     $selected_rm = "Set No Grows"; }
    elsif ( $select_type =~ /^Slow/ )        { $selected = $SGselected; $selected_color = $dim_highlight; $selected_rm = "Set Slow Grows"; }
    elsif ( $select_type =~ /^Unused/ )      { $selected = $Uselected;  $selected_color = $U_highlight;   $selected_rm = "Set Unused Wells"; }
    elsif ( $select_type =~ /^Problematic/ ) { $selected = $Pselected;  $selected_color = $P_highlight;   $selected_rm = "Set Problematic Wells"; }
    elsif ( $select_type =~ /^Empty/ )       { $selected = $Eselected;  $selected_color = $E_highlight;   $selected_rm = "Set Empty Wells"; }

    my $output = alDente::Form::start_alDente_form( $dbc, 'Growth' );
    $output .= $q->hidden( -name => 'Plate IDs', -value => $plate_ids );

    #To create a string for 'Select All Wells' and 'Clear All Wells' buttons
    foreach my $row ( 'A' .. $max_row ) {
        foreach my $col ( 1 .. $max_col ) {
            push( @all_wells, "$row$col" );
        }
    }
    my $all   = join ',', @all_wells;
    my $true  = "SetSelection(this.form,\"Wells\",1,\"all\");";
    my $false = "SetSelection(this.form,\"Wells\",0,\"all\");";

    ## HTML ID for the Growth table
    my $wellstableid = 'wellstable';

    my $setNGs = "$false;SetSelection(this.form,'Wells',1,'$NGselected');document.getElementById('$wellstableid').firstChild.firstChild.firstChild.bgColor='$highlight';";
    my $setSGs = "$false;SetSelection(this.form,'Wells',1,'$SGselected');document.getElementById('$wellstableid').firstChild.firstChild.firstChild.bgColor='$dim_highlight';";
    my $setUs  = "$false;SetSelection(this.form,'Wells',1,'$Uselected');document.getElementById('$wellstableid').firstChild.firstChild.firstChild.bgColor='$U_highlight';";
    my $setPs  = "$false;SetSelection(this.form,'Wells',1,'$Pselected');document.getElementById('$wellstableid').firstChild.firstChild.firstChild.bgColor='$P_highlight';";
    my $setEs  = "$false;SetSelection(this.form,'Wells',1,'$Eselected');document.getElementById('$wellstableid').firstChild.firstChild.firstChild.bgColor='$E_highlight';";

    my $headerTable = HTML_Table->new( -title => "Specify Status for Clones in $plate_info ($status)", -bgcolour => 'lightgrey' );
    $headerTable->Set_Row(
        [   $q->h4('Set Test Status to:'),
            $q->popup_menu(
                -name    => 'Test Status',
                -value   => [ 'Production', 'Test' ],
                -default => $status
                )
                . $q->hidden( -name => 'Growth_Status', -value => $select_type )
        ]
    );
    $headerTable->Set_sub_header( $q->h2('View Wells') );
    $headerTable->Set_Row(
        [   $q->button( -value => 'No Grows',          -onClick => "{this.form.Growth_Status.value='No Grows';$setNGs}",         -style => "background-color:$highlight" ),
            $q->button( -value => 'Slow Grows',        -onClick => "{this.form.Growth_Status.value='Slow Grows';$setSGs}",       -style => "background-color:$dim_highlight" ),
            $q->button( -value => 'Unused Wells',      -onClick => "{this.form.Growth_Status.value='Unused Wells';$setUs}",      -style => "background-color: $U_highlight" ),
            $q->button( -value => 'Problematic Wells', -onClick => "{this.form.Growth_Status.value='Problematic Wells';$setPs}", -style => "background-color:$P_highlight" ),
            $q->button( -value => 'Empty Wells',       -onClick => "{this.form.Growth_Status.value='Empty Wells';$setEs}",       -style => "background-color:$E_highlight" )
        ]
    );
    $headerTable->Set_Row(
        [   $q->textfield( -value => $NGselected, -force => 1, -readonly => 1 ),
            $q->textfield( -value => $SGselected, -force => 1, -readonly => 1 ),
            $q->textfield( -value => $Uselected,  -force => 1, -readonly => 1 ),
            $q->textfield( -value => $Pselected,  -force => 1, -readonly => 1 ),
            $q->textfield( -value => $Eselected,  -force => 1, -readonly => 1 )
        ]
    );

    my $i = 0;
    $headerTable->Set_Cell_Colour( 4, ++$i, $highlight );
    $headerTable->Set_Cell_Colour( 4, ++$i, $dim_highlight );
    $headerTable->Set_Cell_Colour( 4, ++$i, $U_highlight );
    $headerTable->Set_Cell_Colour( 4, ++$i, $P_highlight );
    $headerTable->Set_Cell_Colour( 4, ++$i, $E_highlight );
    $headerTable->Set_Border(1);
    $headerTable->Toggle_Colour('off');

    $output .= $headerTable->Printout(0);
    $output .= vspace(5);

    if ( $parent_quadrant && !$multi_mode ) {
        $output .= "<font size=+2>Editing quadrant </font><font size=+3>'$parent_quadrant'</font><font size=+2> of a 384-well plate.</font>", vspace(5);
    }

    my @list;    ##### default to selected type...
    if    ( $select_type =~ /No Grow/i )     { @list = @NGs; }
    elsif ( $select_type =~ /Slow Grow/i )   { @list = @SGs; }
    elsif ( $select_type =~ /Unused/i )      { @list = @Us; }
    elsif ( $select_type =~ /Problematic/i ) { @list = @Ps; }
    elsif ( $select_type =~ /Empty/i )       { @list = @Es; }

    my %preset_colour;
    $preset_colour{$highlight}     = \@NGs;
    $preset_colour{$dim_highlight} = \@SGs;
    $preset_colour{$U_highlight}   = \@Us;
    $preset_colour{$P_highlight}   = \@Ps;
    $preset_colour{$E_highlight}   = \@Es;

    $output .= select_wells_on_plate(
        -table_id          => $wellstableid,
        -max_row           => $max_row,
        -max_col           => $max_col,
        -availability      => \%availability,
        -preset_colour     => \%preset_colour,
        -tray_flag         => $tray_flag,
        -background_colour => $row_colour,
        -list              => \@list,
        -plate_info        => $plate_info,       # optional
        -select_type       => $select_type       # optional
    );

    ## Remove the class on the title of the wells table and set it's color;
    ##reza
    $output .= "<script>var bw=lib_bwcheck();if(!bw.ie){document.getElementById('$wellstableid').removeChild(document.getElementById('$wellstableid').firstChild);}
    var titlerow = document.getElementById('$wellstableid').firstChild.firstChild;
    if(titlerow.firstChild.nodeName == '#text') { titlerow.removeChild(titlerow.firstChild) };
    titlerow.firstChild.className='';
    titlerow.firstChild.bgColor='$selected_color';
    </script>";

    my $plate_id = $plate_ids;    ## do we need to separate this... ??

    ## Allow the user to edit plates in this generation set on if not in multi plate mode
    if ($multi_mode) {
        $output .= vspace(10) . $q->submit( -name => 'rm', -value => "Submit Wells", -class => 'Action', -onClick => "if(this.form.Growth_Status.value) {return true;} else {alert('Please select a growth status');return false;}" );
    }
    else {

        # grab plate class
        if ( ( $plate_class eq "Rearray" ) || ( $plate_class eq "Oligo" ) ) {
            $output .= $q->submit( -name => "Set Wells from Rearray Sources", -class => "Action" );
        }

        $output .= vspace(10);

        my $Growth = HTML_Table->new();
        $Growth->Set_Title('<B>Optionally assign the above well status to the following plates as well</B>');
        $Growth->Set_Headers( [ 'Select', 'Plate', 'Format', 'Size', 'No Grows', 'Slow Grows', 'Unused Wells', 'Problematic Wells', 'Empty Wells', 'Test Status', 'Parent Plate' ] );

        my $parents = &alDente::Container::get_Parents( -dbc => $dbc, -plate_id => $plate_id, -format => 'list' );
        if ($parents) {
            if ( $parents !~ /^$plate_id$/ ) {
                $Growth->Set_sub_header( 'Past Generations', 'lightredbw' );
                _print_generations( $dbc, $parents, $plate_id, $Growth );
            }
        }

        my $children = &alDente::Container::get_Children( -dbc => $dbc, -plate_id => $plate_id, -format => 'list', -include_self => 1 );
        if ( $children !~ /^$plate_id$/ ) {
            $Growth->Set_sub_header( 'Future Generations', 'lightredbw' );
            _print_generations( $dbc, $children, $plate_id, $Growth );
        }

        if ( $children || ( $parents != $plate_id ) ) { $output .= $Growth->Printout(0); }

        my $commentsTable = HTML_Table->new( -bgcolour => 'white' );
        $commentsTable->Set_Column(
            [   $q->h2('Comments:'),
                $q->textarea( -name => 'Well Comments', -rows => 2, -cols => 40, -force => 1, -default => $comments ),
                $q->h4("(submit Test/Production status OR Growth Status at one time)"),
                $q->submit( -name => 'rm', -value => "Submit Wells", -class => 'Action', -onClick => "if(this.form.Growth_Status.value) {return true;} else {alert('Please select a growth status');return false;}" )
            ]
        );
        $commentsTable->Toggle_Colour('off');
        $output .= $commentsTable->Printout(0);
    }

    $output .= $q->hidden( -name => 'cgi_application', -value => "alDente::Container_App" );
    $output .= "\n</FORM><p ></p><hr>";

    $output .= alDente::Form::start_alDente_form( $dbc, 'ScanNewPlate' )    ## alDente::Form::start_alDente_form($dbc,'ScanNewPlate',undef,$Sess->parameters())
        . $q->submit( -name => 'Library_Plate_Option_btn', -value => "Scan New Plate", -class => "Std" )
        . hspace(5)
        . $q->hidden( -name => 'cgi_application', -value => "alDente::Container_App" )
        . $q->hidden( -name => 'rm', -value => $selected_rm )
        . $q->textfield( -name => 'Barcode', -size => 10 )
        . '</FORM>';

    return $output;
}

########################################
# Sets rows for Growth table, since the exact same code was in two places (in select_wells())
#   it was turned into a private method
#
########################
sub _print_generations {
########################
    my $dbc = shift;

    my $input_plates = shift;
    my $self_id      = shift;
    my $Growth       = shift;

    my %Info = $dbc->Table_retrieve(
        'Plate,Library_Plate,Plate_Format',
        [ 'Plate_ID', 'No_Grows', 'Slow_Grows', 'Unused_Wells', 'Problematic_Wells', 'Empty_Wells', 'Plate_Test_Status as Status', 'FKParent_Plate__ID as Parent', 'Plate_Format_Type as Format', 'Plate_Size' ],
        "where FK_Plate_Format__ID=Plate_Format_ID AND FK_Plate__ID=Plate_ID AND Plate_ID IN($input_plates) ORDER BY Plate_Created ASC"
    );
    my $index = 0;
    my $self_size;

    ##  First loop through to find the current size
    while ( defined $Info{Plate_ID}[$index] ) {
        if ( $Info{Plate_ID}[$index] == $self_id ) {
            $self_size = $Info{'Plate_Size'}[$index];
            last;
        }
        else {

            #        Message("$Info{Plate_ID}[$index] ($self_id)");
        }
        $index++;
    }

    $index = 0;
    while ( defined $Info{Plate_ID}[$index] ) {
        my $this_plate = $Info{Plate_ID}[$index];
        if ( $this_plate != $self_id ) {
            my $size = $Info{'Plate_Size'}[$index];

            my $link;

            if ( $size =~ /$self_size/ ) {
                $link = $q->checkbox( -name => 'Mark Generations', -value => $this_plate, -label => '' );
            }
            else {
                $link = "<a href='$dbc->config('homelink')&Set+Well+Status=1&Barcode=pla$this_plate'>View</a>";
            }
            ## Only allow them to change wells of other 96well plates, does not make sense for 384 well plates (needs plate conversion)
            $Growth->Set_Row(
                [   $link,                   $q->b($this_plate),
                    $Info{'Format'}[$index], $size,
                    $q->textfield( -value => $Info{'No_Grows'}[$index],     -readonly => 1, -size => 10 ), $q->textfield( -value => $Info{'Slow_Grows'}[$index],        -readonly => 1, -size => 10 ),
                    $q->textfield( -value => $Info{'Unused_Wells'}[$index], -readonly => 1, -size => 10 ), $q->textfield( -value => $Info{'Problematic_Wells'}[$index], -readonly => 1, -size => 10 ),
                    $q->textfield( -value => $Info{'Empty_Wells'}[$index],  -readonly => 1, -size => 10 ), $Info{'Status'}[$index],
                    $Info{'Parent'}[$index]
                ]
            );
        }
        $index++;
    }

    return;
}

# List the daughter plates and allow the user to select which inheritable attribute to set
# Also cascades the given plate's work_request
#
#
#############################
sub inherit_plate_attributes_view {
#############################
    my %args           = filter_input( \@_, -args => 'plate_id,dbc' );
    my $plate_id       = $args{-plate_id};
    my $child_ancestry = $args{-child_ancestry};
    my $dbc            = $args{-dbc};
    my $output         = "";

    $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'Inherit_Plate_Attribute', -type => 'plate' );
    ## Get the inheritable attributes for the plate ID
    ##
    my @inheritable_attributes = $dbc->Table_find( 'Plate_Attribute,Attribute', 'Attribute_Name', "WHERE Inherited = 'Yes' and FK_Plate__ID in ($plate_id) and FK_Attribute__ID = Attribute_ID", -distinct => 1 );

    my $inherit_attributes_view = HTML_Table->new( -title => 'Optionally assign the inherited attributes and work_reqeusts to daughter plates' );
    if (@inheritable_attributes) {

        ## List the daughter plates and allow the user to select which inheritable attribute to set
        my $attributes_checkbox = alDente::Tools::search_list( -dbc => $dbc, -name => 'Attribute_Name', -table => 'Attribute', -mode => 'checkbox', -columns => 1, -options => \@inheritable_attributes, -size => 1 );

        $inherit_attributes_view->Set_Headers( [ 'Attributes', 'Daughter_Plates' ] );
        $inherit_attributes_view->Set_Column( [$attributes_checkbox] );

    }
    else {
        $inherit_attributes_view->Set_Headers( ['Daughter_Plates'] );
    }

    my $children = alDente::Container::get_Children( -dbc => $dbc, -id => $plate_id, -format => 'list', -simple => 1 );
    my @daughter_plates = Cast_List( -list => $children, -to => 'Array' );
    foreach my $daughter_plate (@daughter_plates) {
        if ($daughter_plate) {
            my $daughter_checkbox = checkbox( -id => "Daughter_Plate", -name => "Daughter_Plate", -value => "$daughter_plate", -label => '', -checked => 1, -force => 1 );
            my $plate_info = foreign_label( -dbc => $dbc, -plate_id => $daughter_plate );
            $inherit_attributes_view->Set_Column( ["$daughter_checkbox $plate_info"] );
        }
    }
    my $inherit_attributes_button = submit( -name => 'rm', -value => 'Inherit Plate Attributes', -class => 'Std' );
    my $inherit_funding_button    = submit( -name => 'rm', value  => 'Inherit Plate Funding',    -class => 'Std' );

    if (@inheritable_attributes) { $inherit_attributes_view->Set_sub_header("$inherit_attributes_button"); }
    $inherit_attributes_view->Set_sub_header("$inherit_funding_button");

    $inherit_attributes_view->Set_Row( [ hidden( -name => 'cgi_application', -value => 'alDente::Container_App' ) . end_form() ] );

    $output .= $inherit_attributes_view->Printout(0);
    return $output;
}

# Allow the user to fill in information for wells on a plate
#
#    my %headerbox;
#    $headerbox{1}->{name} = "Used Wells";                                         # category name
#    $headerbox{1}->{select_display} = "Wells";                                    # the display title above the textfield containing chosen wells (name is 'selection')
#    $headerbox{1}->{well} = "F1,G1,H1,I1,J1,K1,L1,M1,N1,O1,P1,A2,B2,C2";          # prefill the well textfield with wells, NO '0' padding
#
#    $headerbox{2}->{name} = "Water Blank";
#    $headerbox{2}->{scan} = 1;                                                    # set to 1 to display a textfield for scanning tube (name is 'scan')
#    $headerbox{2}->{select_display} = "Wells";
#    $headerbox{2}->{tooltip} = "scan in water tube";                              # tooltip for the textfield where tubes can be scanned in
#    $headerbox{2}->{well} = "A1,B1";
#
#
#    $req->Set_Row([select_wells_on_plate_own(-table_id=>'Select_Wells',
#					     -max_row=>$max_row,
#					     -max_col=>$max_col,
#					     -input_type=>'checkbox',
#					     -availability=>\%availability,
#                                                  -well_tooltip=>\%sample_tool_tip,    # show the tooltip for each well
#					     -textbox=>\%headerbox
#					     )
#		   ]);
#
#
##########################
sub select_wells_on_plate {
##########################
    my %args = filter_input( \@_, -args => 'table_id' );
    my $dbc                      = $args{-dbc} || SDB::Errors::log_deprecated_usage( "Connection", $Connection );
    my $table_id                 = $args{-table_id};
    my $max_row                  = $args{-max_row};
    my $max_col                  = $args{-max_col};
    my $tray_flag                = $args{-tray_flag};
    my $availability             = $args{-availability};
    my $well_tooltip             = $args{-well_tooltip};
    my $textbox                  = $args{-textbox};
    my $list                     = $args{-list};
    my @list                     = Cast_List( -list => $list, -to => 'Array' );
    my $fill_list                = $args{-fill_list};                                                                                                            ## Optional
    my $plate_info               = $args{-plate_info};                                                                                                           ## optional
    my $select_type              = $args{-select_type};                                                                                                          ## optional
    my @colors                   = qw(darkslategray lightsalmon palevioletred darkturquoise darkviolet deeppink peru lime firebrick red gold darkblue yellow);
    my $preset_colour            = $args{-preset_colour};                                                                                                        ## hash preset the colour of the cell
    my $background_colour        = $args{-background_colour};
    my $input_type               = $args{-input_type} || 'checkbox';
    my $plate_id                 = $args{-plate_id};
    my $no_fill                  = $args{-no_fill};
    my $tray_to_resolve          = $args{-tray_to_resolve};
    my $display_simple           = $args{-display_simple};
    my $printable_page_link_only = $args{-printable_page_link_only};

    my $image_data = _convert_parameter_for_image( -list => $list, -max_col => $max_col, -max_row => $max_row );
    require RGTools::Graphs;

    #<CONSTRUCTION> plate dimension can be stored in database
    my $graph = Graphs->new( -height => 293, -width => 425 );    # dimension measured for 384-genetix plate

    $graph->set_config( -data => $image_data, -type => 'matrix', -title => $plate_info . " (" . $select_type . ")" );
    $graph->create_graph();

    my $file = $URL_temp_dir . "/" . $plate_info . ".png";
    my $created = $graph->create_PNG_file( -file_path => $file );

    my $allTables = "";
    if ($created) {
        my $URL_path;
        if ( $file =~ m|\/(dynamic\/.*)| ) {
            $URL_path = $1;
        }
        else {
            $URL_path = $file;
        }
        my $image_link = "<a href='/$URL_path'><b>Printable Image</b></a>";
        $allTables .= $image_link;
    }

    my %wells;

    if ($textbox) {
        my $text_box_table = HTML_Table->new( -id => "text_box" );
        my $box_size       = 25;
        my $itemNum        = 0;
        foreach my $key ( sort { $a <=> $b } keys %$textbox ) {
            my @column;

            # title
            my $title = "<font size=\"+0\"><b>$$textbox{$key}->{name}</font></b>" || "";
            push( @column, $title );

            # plate scanning textfield
            my $scan_box = "";
            $scan_box = Show_Tool_Tip( textfield( -id => $$textbox{$key}->{name}, -name => "scan", -value => '', -size => $box_size, -force => 1 ), $$textbox{$key}->{tooltip} ) if ( $$textbox{$key}->{scan} );
            push( @column, $scan_box );

            # title above well selection box
            my $selection_title = $$textbox{$key}->{select_display} || "";
            push( @column, $selection_title );

            # well selection textfield, readonly
            my $selection_box = "<input type=\"text\" name=\"selection\" readonly=\"readonly\" value=\"$$textbox{$key}->{well}\" size=\"$box_size\">";
            push( @column, $selection_box );

            # button to select wells
            my $button = Show_Tool_Tip(
                button(
                    -name   => 'select_well',
                    -value  => "Select $$textbox{$key}->{name} Wells",
                    -style  => "background-color:$colors[$itemNum]",
                    onClick => "update_well_information(this.form,'Wells','selection','$itemNum','$colors[$itemNum]');"
                ),
                "select " . $$textbox{$key}->{name} . " wells"
            );
            push( @column, $button );

            # hidden field containing initial well values
            my $field = hidden( -name => 'initial_wells', -value => $$textbox{$key}->{well} );
            push( @column, $field );

            $text_box_table->Set_Column( \@column );
            my @wells = split( ",", $$textbox{$key}->{well} );
            foreach (@wells) {
                $wells{$_} = $itemNum;
            }
            $itemNum++;
        }
        my @emptyColumn = ();
        $text_box_table->Set_Column( \@emptyColumn );
        $text_box_table->Set_Column( \@emptyColumn );
        $text_box_table->Set_Column( \@emptyColumn );
        $text_box_table->Set_Column(
            [   '', '', '', '',
                button(
                    -name   => 'clear_well',
                    -value  => "Clear Selection",
                    -id     => 'clear_well',
                    onClick => "update_well_information(this.form,'Wells','selection','','');"
                )
            ]
        );
        $allTables .= $text_box_table->Printout(0);
    }

    my $select_wells_table = HTML_Table->new( -id => "$table_id" );
    my $true               = "SetSelection(this.form,\"Wells$plate_id\",1,\"all\");";
    my $false              = "SetSelection(this.form,\"Wells$plate_id\",0,\"all\");";

    my @fill_link;
    foreach my $col ( 0 .. $max_col ) {
        my $col_list = join ',', map {
            if   ( $tray_to_resolve->{"$_$col"} ) { $tray_to_resolve->{"$_$col"} }
            else                                  {"$_$col"}
        } ( 'A' .. $max_row );
        my $col_fill;
        $col_fill = "SetSelection(this.form,'Wells$plate_id','toggle','$col_list'); " if !$no_fill;
        if ($col) {
            if ($display_simple) {
                push( @fill_link, $col );
            }
            else {
                push( @fill_link, button( -name => $col, -onClick => $col_fill, -class => 'MiniButton' ) );
            }
        }
        else {
            push( @fill_link, undef );
        }
    }
    $select_wells_table->Set_Headers( \@fill_link );

    foreach my $row ( 'A' .. $max_row ) {
        @fill_link = ();
        my $row_list = join ',', map {
            if   ( $tray_to_resolve->{"$row$_"} ) { $tray_to_resolve->{"$row$_"} }
            else                                  {"$row$_"}
        } ( 1 .. $max_col );
        my $row_fill;
        $row_fill = "SetSelection(this.form,'Wells$plate_id','toggle','$row_list'); " if !$no_fill;
        if ($display_simple) {
            push( @fill_link, $row );
        }
        else {
            push( @fill_link, button( -name => "$row", -onClick => $row_fill, -class => 'MiniButton' ) );
        }
        foreach my $col ( 1 .. $max_col ) {

            # if this cell is available given the list of plates, put in a checkbox
            # otherwise, put in a nonbreaking space
            if ( $availability->{"$row$col"} || !$tray_flag ) {
                my $input;
                my $sample_tooltip = "";
                $sample_tooltip = $well_tooltip->{"$row$col"} if ( $args{-show_sample_tooltip} );
                if ( $input_type eq 'checkbox' ) {
                    my $category;
                    $category = $wells{"$row$col"} if ( exists $wells{"$row$col"} );
                    my $color;
                    $color = $colors[$category] if ( $category ne undef );
                    my $disable = "";
                    if ( defined $availability->{"$row$col"} && $availability->{"$row$col"} == 0 ) { $disable = "-disabled" }
                    my $value = "$row$col";
                    if ( $tray_to_resolve->{$value} ) { $value = $tray_to_resolve->{$value} }

                    if ( grep /^${row}0?$col$/, @list ) {

                        $input = Show_Tool_Tip(
                            checkbox( -id => "Wells$plate_id", -name => "Wells$plate_id", -value => $value, -label => '', -checked => 1, -force => 1, $disable )
                                . hidden( -name => "$row$col", -value => "$color",    -force => 1 )
                                . hidden( -name => "$row$col", -value => "$category", -force => 1 ),
                            $sample_tooltip
                        );
                    }
                    else {
                        $input = Show_Tool_Tip(
                            checkbox( -id => "Wells$plate_id", -name => "Wells$plate_id", -value => $value, -label => '', -checked => 0, -force => 1, $disable )
                                . hidden( -name => "$row$col", -value => "$color",    -force => 1 )
                                . hidden( -name => "$row$col", -value => "$category", -force => 1 ),
                            $sample_tooltip
                        );
                    }
                }
                elsif ( $input_type eq 'text' ) {

                    if ( defined $availability->{"$row$col"} && $availability->{"$row$col"} == 0 ) {

                        $input = textfield(
                            -id         => "$row$col",
                            -disabled   => 1,
                            -style      => 'background-color:grey',
                            -name       => "Wells",
                            -value      => '',
                            -size       => 3,
                            -force      => 1,
                            -onDblClick => "fill_wells(this.form,'$row$col','$max_row','$max_col','$fill_list');"
                        );
                    }
                    else {
                        $input = textfield( -id => "$row$col", -name => "Wells", -value => '', -size => 3, -force => 1, -onDblClick => "fill_wells(this.form,'$row$col','$max_row','$max_col','$fill_list');" );
                        print hidden( -name => 'TargetWells', -value => "$row$col", -force => 1 );
                    }

                }
                elsif ( $input_type eq 'link' ) {
                    $input = $availability->{"$row$col"};
                }
                push( @fill_link, $input );
            }
            else {
                push( @fill_link, undef );
            }
            ## SET the colour for the cell
            my $cell_colour = $background_colour;

            foreach my $colour ( keys %{$preset_colour} ) {
                if ( grep /^$row$col$/i, @{ $preset_colour->{$colour} } ) {
                    $cell_colour = $colour;
                }
            }
            $select_wells_table->Set_Cell_Colour( ord($row) - 64, $col + 1, $cell_colour );

        }
        $select_wells_table->Set_Row( \@fill_link );
    }
    my $action = $args{-action} || 'well_select';

    if ( $action =~ /well_select/i ) {

        $action = button( -name => 'Select All Wells', onClick => $true ) . hspace(5) . button( -name => 'Clear All Wells', onClick => $false );
        if ( $max_row eq 'P' && $max_col eq '24' ) {
            my @quads = ( 'a', 'b', 'c', 'd' );
            foreach my $quad (@quads) {
                my @quad_wells = $dbc->Table_find( 'Well_Lookup', 'ucase(Plate_384)', "WHERE Quadrant = '$quad'" );
                my $quad_wells = Cast_List( -list => \@quad_wells, -to => 'String' );
                my $quad_fill = "SetSelection(this.form,'Wells$plate_id','toggle','$quad_wells'); ";
                $action .= hspace(5) . button( -name => $quad, -onClick => "$quad_fill", -class => 'MiniButton' );
            }
        }
    }
    elsif ( $action =~ /fill_wells/i ) {
        my $fill_wells  = "fill_wells(this.form,$max_row,$max_col,$fill_list);";
        my $clear_wells = "SetSelection(this.form,\"Wells\",'',\"all\");";
        $action = radio_group( -name => 'Fill_By', -values => [ 'by column', 'by row' ] ) . hspace(5) . button( -name => 'Clear Filled Wells', onClick => $clear_wells );
    }

    $select_wells_table->Set_Title( $action . hspace(5) . $plate_info );
    $select_wells_table->Toggle_Colour('off');
    $select_wells_table->Set_Column_Colour( 1, 'lightgrey' );
    $select_wells_table->Set_Header_Colour('lightgrey');
    $select_wells_table->Set_Border(1);
    $select_wells_table->Set_Alignment('center');
    my $stamp = int( rand(10000) );
    $allTables .= $select_wells_table->Printout("$URL_temp_dir/well_layout$stamp.html");
    if ($display_simple) {
        my %xls_settings;
        $xls_settings{'column_width'} = 18;
        $allTables .= $select_wells_table->Printout( "$URL_temp_dir/well_layout$stamp.xlsx", -xls_settings => \%xls_settings );
    }
    $allTables .= $select_wells_table->Printout(0);

    if ($printable_page_link_only) { $allTables = $select_wells_table->Printout("$URL_temp_dir/well_layout$stamp.html") }

    return $allTables;
}

sub plate_sample_qc_status_view {
    my %args      = filter_input( \@_ );
    my $dbc       = $args{-dbc};
    my $attribute = $args{-attribute} || 'Sample_QC_Status';
    my $qc_type   = $args{-qc_type};
    my $qc_prompt .= Show_Tool_Tip( submit( -name => 'rm', -value => 'Set Plate Sample QC Status', -class => 'Action', -onClick => "sub_cgi_app( 'alDente::Container_App' )", -force => 1 ), "Set the sample qc status for the plate/tube" );
    my @available_sample_qc_status;
    require alDente::Attribute;
    @available_sample_qc_status = alDente::Attribute::get_Attribute_enum_list( -name => "$attribute", -dbc => $dbc );
    $qc_prompt .= popup_menu( -name => 'Sample_QC', -value => \@available_sample_qc_status, -default => "Approved" );
    $qc_prompt .= hidden( -id => 'sub_cgi_application', -force => 1 );
    $qc_prompt .= hidden( -name => 'RUN_CGI_APP', -value => 'AFTER',      -force => 1 );
    $qc_prompt .= hidden( -name => 'Attribute',   -value => "$attribute", -force => 1 );
    if ($qc_type) { $qc_prompt .= hidden( -name => 'QC_Type', -value => "$qc_type", -force => 1 ) }

    return $qc_prompt;
}

#######################################
# Convert parameters to print empty well image
#
##############################
sub _convert_parameter_for_image {
    my %args      = @_;
    my $max_row   = $args{-max_row};
    my $max_col   = $args{-max_col};
    my $list      = $args{-list};
    my @list      = Cast_List( -list => $list, -to => 'Array' );
    my %list_hash = map { $_ => 1 } @list;

    my %data;
    my @col_header = ( 0 .. $max_col );
    my @row_header = ( 0, 'A' .. $max_row );

    for ( my $i = 0; $i < scalar @row_header; $i++ ) {

        if ( $i == 0 ) {
            $data{$i} = \@col_header;
        }
        else {
            my $row_name = $row_header[$i];
            my @row      = ($row_name);
            for ( my $j = 1; $j < scalar @col_header; $j++ ) {
                my $col_name = $col_header[$j];
                if ( exists( $list_hash{ $row_name . $col_name } ) ) {
                    push( @row, "*" );
                }
                else {
                    push( @row, "" );
                }
            }
            $data{$i} = \@row;
        }

    }

    return \%data;
}

#############
#
# allows users to select from a given list of plates and select an action to perform (run mode)
#
#
#
#######################
sub mark_plates_view {
#######################
    my %args = filter_input( \@_ );

    my $dbc         = $args{-dbc};
    my $type        = $args{-type};
    my $days        = $args{-days};
    my $plates_list = $args{-plate_ids};
    my $lib         = $args{-library};
    my $format      = $args{'-format'};
    my $all_users   = $args{-all_users};
    my $rm          = $args{-run_modes};
    my $preset      = $args{-preset} || $plates_list;    ## if plate_ids supplied, preset checkboxes by default
    my $user_id     = $dbc->get_local('user_id');

    my @run_modes = ( 'Delete Plate', 'Annotate Plate', 'Fail Plates', 'Throw Out Plates', 'Fail and Throw Out Plates', 'Re-Print Plate Labels' );
    if ($rm) { @run_modes = @{$rm} }                     ## override available run modes

    my $annotation;
    if ( grep /[Annotate|Fail]/, @run_modes ) {
        $annotation = "Notes: ";
        $annotation .= textfield( -name => 'Mark Note', -size => 20 );
    }

    my $types = Cast_List( -list => $type, -to => 'String', -autoquote => 1 );

    ##### List plates created by this user within 7 days... ####

    my @field_list;

    if ( !$plates_list && !$days ) {
        Message("Retrieving Plates created in past week (default)");
        $days = "-7d";    #default Plate_Created period
    }
    elsif ( $days =~ /^\d+$/ ) {
        $days = "-" . $days . "d";
    }

    my $extra_condition = '1';
    if ( $plates_list =~ /(Pla|Tra)\d/i ) {
        $plates_list = get_aldente_id( $dbc, $plates_list, 'Plate' );
        $extra_condition .= " AND Plate_ID IN ($plates_list)";
    }
    elsif ( $plates_list =~ /\d/ ) {
        $plates_list = extract_range($plates_list);
        $extra_condition .= " AND Plate_ID IN ($plates_list)";
    }
    else {
        if ($days) {
            $extra_condition = " Plate_Created >= \"" . RGTools::RGIO::date_time($days) . "\"";
        }
        unless ($all_users) {
            $extra_condition .= " AND FK_Employee__ID = $user_id";
        }
        if ($type) {
            $extra_condition .= " AND Plate_Type IN ($types)";
        }

        if ($format) {
            my $formats = get_FK_ID( $dbc, 'FK_Plate_Format__ID', $format );
            $extra_condition .= " AND FK_Plate_Format__ID IN ($formats)";
        }
        if ($lib) {
            my $libs = '';
            if ($lib) {
                $libs = Cast_List( -list => $lib, -to => 'String', -autoquote => 1 );
            }
            $extra_condition .= " AND FK_Library__Name IN ($libs)";
        }
    }
    Message("Cond: $extra_condition");

    $plates_list = join ',', $dbc->Table_find( 'Plate', 'Plate_ID', "WHERE $extra_condition" );

    unless ($plates_list) {
        Message("Warning: Search returned no records");
        return;
    }

    my $add_html = $q->hidden( -name => 'Override_Confirmation', -value => 1 );

    if ( grep /Fail/, @run_modes ) {
        ## Get the fail reasons for the groups of the user
        $add_html .= '<BR>' . vspace(1) . prompt_for_Fail_Reason($dbc);
    }

    my ( $tables, $condition );
    if ( $types =~ /\'(.*?)\',/ ) {
        ### Multiple plate types simultaneously ##
        $tables     = 'Plate';
        @field_list = ('Plate_ID');    ## first column should always be non-zero for mark_records...

        foreach my $thistype ( split ',', $types ) {
            $thistype =~ s/\'//g;      ## strip quotes

            $tables .= " LEFT JOIN $thistype ON $thistype.FK_Plate__ID=Plate_ID";
            push @field_list, "$thistype.FK_Plate__ID as $thistype";
        }
        push @field_list, "FK_Plate_Format__ID", "Plate_Status as Status", "Failed as Failed", "FK_Library__Name as Library", "Plate_Number", "Plate_Created", "FK_Employee__ID as Created_by", 'Plate_Comments';
        $condition = "WHERE Plate_ID in ($plates_list)";
    }
    elsif ($type) {
        ### One specific type of plate requested ###
        $tables     = "Plate,$type";
        $condition  = "WHERE Plate_ID=FK_Plate__ID AND Plate_ID in ($plates_list)";
        @field_list = ( "FK_Plate__ID", "FK_Plate_Format__ID", "Plate_Status as Status", "Failed as Failed", "FK_Library__Name as Library", "Plate_Number", "Plate_Created", "FK_Employee__ID as Created_by", 'Plate_Comments' );
    }
    else {
        ### No type info included ###
        $tables     = "Plate";
        $condition  = "WHERE Plate_ID in ($plates_list)";
        @field_list = ( "Plate_ID", "FK_Plate_Format__ID", "Plate_Status as Status", "Failed as Failed", "FK_Library__Name as Library", "Plate_Number", "Plate_Created", "FK_Employee__ID as Created_by", 'Plate_Comments' );
    }

    return &SDB::DB_Form_Viewer::mark_records(
         $dbc, $tables, \@field_list, $condition,
        -application => 'alDente::Container_App',
        -run_modes   => \@run_modes,
        -add_html    => $add_html . hspace(20) . $annotation,
        -preset      => $preset,
        -return_html => 1
    );
}

#################################
sub prompt_for_Fail_Reason {
#################################
    my $dbc = shift;

    my $groups  = $dbc->get_local('group_list');
    my $reasons = alDente::Fail::get_reasons( -object => 'Plate', -grps => $groups );
    my $prompt  = ' Fail Reason: ' . $q->popup_menu( -name => 'FK_FailReason__ID', -values => [ '', sort keys %{$reasons} ], -labels => $reasons, -force => 1 );
    $prompt .= set_validator( -name => 'FK_FailReason__ID', -mandatory => 1 );
    return $prompt;
}

##########################
# Other plate pages ##
##########################
# _Solutions
# view_History
# view_Ancestry
#
# original_form
# child_form
# update_plate_schedule_frm
# fail_toolbox
#

########################
sub show_Solutions {
#######################
    my %args = &filter_input( \@_, -args => 'dbc,ids' );
    if ( $args{ERRORS} ) { Message("Input Errors Found: $args{ERRORS}"); return; }

    my $dbc      = $args{-dbc};
    my $ids      = $args{-ids} || 0;                           ## plate_id (or list)
    my $reagents = $args{-reagents} || 0;                      ## extract reagents from mixture records
    my $direct   = $args{-direct} || 0;                        ## include only reagents applied directly to this plate
    my $title    = "Reagents Applied to Container(s): $ids";

    unless ($ids) {
        Message("ERROR: No plate ids specified");
        return;
    }

    print "Tracking back through solutions ? : $reagents";
    unless ($direct) {
        $ids = alDente::Container::get_Parents( -dbc => $dbc, -id => $ids, -format => 'list', -simple => 1 );
        $title .= " (or Parents)";
    }

    #    unless (@used) { print "No Reagents applied to this plate"; }
    my %used = %{ alDente::Container->get_Applications( -dbc => $dbc, -ids => $ids, -reagents => $reagents ) };
    unless ( keys %used ) { print "No Reagents applied to this plate"; }

    my $Applied = HTML_Table->new( -title => $title, fsize => '-1' );
    $Applied->Set_Headers( [ 'Name', 'ID', 'Protocol', 'Step', 'Time', 'Plate', 'Qty', 'Reagent Type', 'Application' ] );

    my @types = ('applied');
    if ($reagents) { push( @types, 'original_reagent' ) }

    my $row = 0;
    foreach my $plate ( sort keys %used ) {
        foreach my $prep ( sort keys %{ $used{$plate} } ) {
            my %info     = $dbc->Table_retrieve( 'Prep,Lab_Protocol', [ 'Lab_Protocol_Name', 'Prep_Name', 'Prep_DateTime' ], "WHERE FK_Lab_Protocol__ID=Lab_Protocol_ID AND Prep_ID = $prep" );
            my $protocol = $info{Lab_Protocol_Name}[0];
            my $step     = &Link_To( $dbc->config('homelink'), $info{Prep_Name}[0], "&HomePage=Prep&Prep_ID=$prep" );                                                                             ## <CONSTRUCTION>....
            my $time     = $info{Prep_DateTime}[0];
            foreach my $type (@types) {
                foreach my $solution ( sort keys %{ $used{$plate}{$prep}{$type} } ) {
                    unless ( $solution =~ /[1-9]/ ) {next}
                    my $used_qty = $used{$plate}{$prep}{$type}{$solution};

                    #  my $used_units =
                    my ($details) = $dbc->Table_find( 'Solution,Stock,Stock_Catalog', 'Solution_Type,Stock_Catalog_Name', "WHERE FK_Stock__ID=Stock_ID AND Solution_ID=$solution AND FK_Stock_Catalog__ID = Stock_Catalog_ID" );
                    my ( $Stype, $name ) = split ',', $details;
                    unless ($name) {
                        ($details) = $dbc->Table_find( 'Solution,Stock,Stock_Catalog', 'Solution_Type,Stock_Catalog_Name', "WHERE FK_Stcok_Catalog__ID = Stock_Catalog_ID and FK_Stock__ID=Stock_ID AND Solution_ID=$solution" );
                        ( $Stype, $name ) = split ',', $details;
                    }
                    my $colour = 'vlightyellowbw';
                    if ( $type =~ /applied/ ) { $colour = 'vlightbluebw'; }
                    $row++;
                    my $link = &Link_To( $dbc->config('homelink'), -label => $name, -param => "&HomePage=Solution&ID=$solution", -colour => $Settings{LINK_COLOUR}, -window => ['newwin'] );
                    $Applied->Set_Row( [ $link, $solution, $protocol, $step, $time, $plate, $used_qty, $Stype, $type ], $colour );
                }
            }
        }
    }

    print &Href( $dbc->config('homelink'), 3, 'Employee' );

    #    unless ($reagent=~/[1-9]/) { next }
    #	my ($details) = $dbc->Table_find('Solution,Stock','Stock_Catalog_Name,Solution_Type',"WHERE FK_Stock__ID=Stock_ID AND Solution_ID = $reagent");
    #    my ($name,$type) = split ',', $details;
    #    $Applied->Set_Row([$reagent,$name,$type]);
    #    }
    $Applied->Printout();

    return;
}

#####################
## Viewing Options ##
#####################

####################
sub view_Ancestry {
####################
    #
    # View Ancestry of Plate (previous / future generations)
    #
    # (This is the simple view showing only plate ids with multiple generations)
    #
####################
    my %args = @_;

    my $dbc     = $args{-dbc};
    my $view    = $args{-view};
    my $id      = $args{-id};
    my $Display = $args{-Display};

    my $return_html = $args{-return_html};
    my $simple      = $args{-simple};

    my ($info) = $dbc->Table_find( 'Plate', 'Plate_Type,FK_Library__Name,Plate_Number', "WHERE Plate_ID IN ($id)" );
    my ( $type, $lib, $num ) = split ',', $info;

    my $output = '';
    if ($view) {
        $Display = HTML_Table->new();
        $Display->Set_Title( "Ancestry of $type $id", fsize => '-1' );
        $Display->Set_Width('500');
        $Display->Set_Class('small');
    }

    my %Ancestry;
    $Ancestry{original} = 0;
    $Ancestry{list}     = [$id];    ## include current plate in list
    %Ancestry = alDente::Container::get_Parents( -dbc  => $dbc, -id => $id, -ancestry => \%Ancestry, -simple => $simple ) if $id;    ## add parents to Ancestry
    %Ancestry = alDente::Container::get_Siblings( -dbc => $dbc, -id => $id, -ancestry => \%Ancestry, -simple => $simple ) if $id;    ## add siblings to ancestry
    %Ancestry = alDente::Container::get_Children( -dbc => $dbc, -id => $id, -ancestry => \%Ancestry, -include_self => 1, -simple => $simple ) if $id;    ## add children to ancestry
    my $col      = 1;
    my $max_list = 8;

    if ( defined $view && !$scanner_mode ) {
        unless ($Display) {
            my $prefix = $dbc->barcode_prefix('Plate');
            $Display = HTML_Table->new();
            $Display->Set_Title( "Ancestry of $prefix $id ($lib-$num)", fsize => '-1' );
            $Display->Set_Width('500');
            $Display->Set_Class('small');
        }

        ## retrieve rearrays without following them ##

        # Display rearray sources
        if ( $Ancestry{rearray_sources} ) {
            my $rearray_list = '';
            my @rearrays     = @{ $Ancestry{rearray_sources} };
            my @unique       = do {
                my %seen;
                grep { !$seen{$_}++ } @rearrays;
            };
            @rearrays = @unique;

            # get the rearray type

            my ($rearray_type) = $dbc->Table_find( "ReArray_Request", "ReArray_Type", "WHERE FKTarget_Plate__ID=$id" );
            my $rearray_requests = join ',', $dbc->Table_find( "ReArray_Request", "ReArray_Request_ID", "WHERE FKTarget_Plate__ID=$id" );
            my $request_link = &Link_To( $dbc->config('homelink'), $rearray_type, "&cgi_application=alDente::ReArray_App&rm=View+ReArrays&Request+IDs=$rearray_requests", $Settings{LINK_COLOUR} );
            foreach my $rearray (@rearrays) {
                my $link = foreign_label( -dbc => $dbc, -plate_id => $rearray, -type => 'tooltip' );

                #my $link = &Link_To($dbc->config('homelink'),"Pla$rearray","&Scan=1&Barcode=Pla$rearray",$Settings{LINK_COLOUR},-tooltip=>$tip);
                $rearray_list .= $link .  '<br>';
            }
            if ( @rearrays > $max_list ) { $rearray_list = create_tree( -tree => { '(list ids)' => $rearray_list } ) }
            if ($view) { $Display->Set_Column( [ "<B>$request_link<BR>from:</B>", $rearray_list ] ) }
            $Display->Set_Cell_Colour( 1, $col, 'red' );
            $Display->Set_Cell_Colour( 2, $col++, 'WHite' );
        }

        # Display pooling sources
        if ( $Ancestry{pooling_sources} ) {
            my $pooling_list = '';
            my @poolings     = @{ $Ancestry{pooling_sources} };
            foreach my $pooling (@poolings) {
                my $link = foreign_label( -dbc => $dbc, -plate_id => $pooling, -type => 'tooltip' );

                #my $link .= &Link_To($dbc->config('homelink'),"Pla$pooling","&Scan=1&Barcode=Pla$pooling",$Settings{LINK_COLOUR});
                $pooling_list .= "$link<BR>";
            }
            if ( @poolings > $max_list ) { $pooling_list = create_tree( -tree => { '(list ids)' => $pooling_list } ) }
            if ($view) { $Display->Set_Column( [ "<B>Pooled <BR>from:</B>", $pooling_list ] ) }
            $Display->Set_Cell_Colour( 1, $col, 'red' );
            $Display->Set_Cell_Colour( 2, $col++, 'lightgrey' );
        }
        ## get standard generations regardless of simple status ##
        foreach my $generation ( sort { $a <=> $b } keys %{ $Ancestry{generation} } ) {

            # list of plate_ids for this generation
            my $list     = $Ancestry{generation}->{$generation};
            my $links    = '';                                     ## list of plate_ids (with links) for this generation
            my @children = split ',', $list;
            foreach my $thisid (@children) {

                #		if ($thisid eq $id) { $display = "<B><Font color=red>$id<\/Font><\/B>" }  ## highlight current plate

                $links .= foreign_label( -dbc => $dbc, -plate_id => $thisid, -type => 'tooltip', -highlight => $id );
                $links .= "<BR>";
            }
            if ( @children > $max_list ) { $links = create_tree( -tree => { '(list ids)' => $links } ) }

            # list of formats used in this generation
            my $formats = $Ancestry{formats}->{$generation};

            ## highlight current plate ##
            if ( $generation =~ /\+0/ ) {
                $generation = 'current';
            }

            if ($view) {
                $Display->Set_Column( [ "<B>$generation gen</B><BR>$formats", $links ] );
                $col++;
            }
        }
        if ($simple) {
            ## retrieve rearrays without following them ##

            # Display rearray targets
            if ( $Ancestry{rearray_targets} ) {
                my $target_list = '';
                my @targets     = @{ $Ancestry{rearray_targets} };
                foreach my $target (@targets) {
                    my $link = foreign_label( -dbc => $dbc, -plate_id => $target, -type => 'tooltip' );

                    #my $link .= &Link_To($dbc->config('homelink'),"Pla$target","&Scan=1&Barcode=Pla$target",$Settings{LINK_COLOUR});
                    $target_list .= "$link<BR>";
                }
                if ( @targets > $max_list ) { $target_list = create_tree( -tree => { '(list ids)' => $target_list } ) }

                # get type of rearray. If there is more than one type, just name it as 'rearray'. If only one type, then display type
                my $rearray_type     = '';
                my $targets          = join ',', @targets;
                my @rearray_types    = $dbc->Table_find( "ReArray_Request", "ReArray_Type", "WHERE FKTarget_Plate__ID in ($targets)", -distinct => 1 );
                my $rearray_requests = join ',', $dbc->Table_find( "ReArray_Request", "ReArray_Request_ID", "WHERE FKTarget_Plate__ID IN ($targets)" );

                if ( int(@rearray_types) > 1 ) {
                    $rearray_type = 'Rearray';
                }
                else {
                    $rearray_type = $rearray_types[0];
                }
                my $request_link = &Link_To( $dbc->config('homelink'), $rearray_type, "&cgi_application=alDente::ReArray_App&rm=View+ReArrays&Request+IDs=$rearray_requests", $Settings{LINK_COLOUR} );
                if ($view) { $Display->Set_Column( [ "<B>$request_link<BR>to:</B>", $target_list ] ) }
                $Display->Set_Cell_Colour( 1, $col, 'red' );
                $Display->Set_Cell_Colour( 2, $col++, 'lightgrey' );
            }

            # Display pooling targets
            if ( $Ancestry{pooling_targets} ) {
                my $pooling_list = '';
                my @poolings     = @{ $Ancestry{pooling_targets} };
                foreach my $pooling (@poolings) {
                    my $link .= &Link_To( $dbc->config('homelink'), $pooling, "&Scan=1&Barcode=PLA$pooling", $Settings{LINK_COLOUR} );
                    $pooling_list .= "$link<BR>";
                }
                @poolings = sort { $a <=> $b } keys %{ $Ancestry{pooling_targets} };
                foreach my $pool_target (@poolings) {
                    my $link = foreign_label( -dbc => $dbc, -plate_id => $pool_target, -type => 'tooltip' );
                    $link         .= " (" . int( @{ $Ancestry{pooling_targets}{$pool_target} } ) . ")";
                    $pooling_list .= "$link<BR>";
                }
                if ( @poolings > $max_list ) { $pooling_list = create_tree( -tree => { '(list ids)' => $pooling_list } ) }

                if ($view) { $Display->Set_Column( [ "<B>Pooled<BR>to: (total parents)</B>", $pooling_list ] ) }
                $Display->Set_Cell_Colour( 1, $col, 'red' );
                $Display->Set_Cell_Colour( 2, $col++, 'lightgrey' );
            }
        }
        if ($view) {
            ## upstream details if simple tracking used ##
            if ( $Ancestry{rearray_sources} ) {
                $Display->Set_sub_title( 'Prior History', 1, 'darkbluebw' );
            }

            #if ($Ancestry{extraction_sources}) {
            #	$Display->Set_sub_title('Branched From',1,'darkbluebw');
            #}
            if ( $Ancestry{pooling_sources} ) {
                $Display->Set_sub_title( 'Branched From', 1, 'darkbluebw' );
            }

            ## add Parents subtitle (if applicable)
            if ( $Ancestry{parent_generations} ) {
                $Display->Set_sub_title( 'Parents', $Ancestry{parent_generations}, 'mediumbluebw' );
            }
            ## add Siblings subtitle
            $Display->Set_sub_title( 'Siblings', 1, 'mediumgreenbw' );
            ## add Children subtitle (if applicable)
            if ( $Ancestry{child_generations} ) {
                $Display->Set_sub_title( 'Children', $Ancestry{child_generations}, 'lightredbw' );
            }

            if ($simple) {
                ## downstream details if simple tracking used ##
                if ( $Ancestry{rearray_targets} ) {
                    $Display->Set_sub_title( 'Branches To', 1, 'darkbluebw' );
                }
                if ( $Ancestry{pooling_targets} ) {
                    $Display->Set_sub_title( 'Branches To', 1, 'darkbluebw' );
                }

                #The above only shows direct rearray
                #Only display this if all linerage has a distannt rearray or a pool
                my ($source_rearray) = $dbc->Table_find( "ReArray_Request,ReArray,Plate as Source_Plate",
                    "ReArray_Request_ID", "WHERE FK_ReArray_Request__ID = ReArray_Request_ID AND FKSource_Plate__ID = Source_Plate.Plate_ID AND Source_Plate.FK_Library__Name = '$lib' AND Source_Plate.Plate_Number = $num limit 1" );
                my ($target_rearray) = $dbc->Table_find( "ReArray_Request,ReArray,Plate as Target_Plate",
                    "ReArray_Request_ID", "WHERE FK_ReArray_Request__ID = ReArray_Request_ID AND FKTarget_Plate__ID = Target_Plate.Plate_ID AND Target_Plate.FK_Library__Name = '$lib' AND Target_Plate.Plate_Number = $num limit 1" );
                if ( $source_rearray || $target_rearray ) {
                    my $link_to = &Link_To( $dbc->config('homelink'), "View All (Including Rearrays and Pools)", "&cgi_application=alDente::Container_App&rm=home_page&ID=$id&simple=0" );
                    $Display->Set_sub_header( $link_to, 'lightredbw' );
                }
            }
            ## print out Ancestry Table
            $output .= $Display->Printout(0);

            #my $include = alDente::Container::get_Parents( -dbc => $dbc, -id => $id, -format => 'list', -simple => $simple );

            #print create_tree(-tree=>{'Detailed view of Ancestry'=>
            #				  $self->display_ancestry($self->value('FKOriginal_Plate__ID'),-recursive=>1,-include=>$include,-original=>$plate_id) },-include=>$include);
        }

        $output .= '<p ></p>'
            . Link_To(
            -link_url => $dbc->config('homelink'),
            -label    => "View Graphic Ancestry (use to manage parent, sibling, and children plates)",
            -param    => "&cgi_application=alDente::Container_App&rm=View+Detailed+Ancestory&ID=$id",
            -colour   => $Settings{LINK_COLOUR},
            );
        $output .= '<p ></p>';
    }

    #    $self->{Ancestry} = \%Ancestry unless defined ->{Ancestry};   ## keep track of this to allow downstream use ##

    if   ($return_html) { return $output; }
    else                { return ( $output, \%Ancestry ); }
}

######################################
# Show hierarchy of plate ancestry
#
# <CONSTRUCTION>.. update to highlight current plate and direct ancestry path to original.
#
########################
sub display_ancestry {
########################
    my %args      = &filter_input( \@_, -args => 'plate_id' );
    my $dbc       = $args{-dbc};
    my $plate_id  = $args{-plate_id};                            ## plate to show ancestry for
    my $recursive = $args{-recursive} || 1;

    my $generation = $args{-generation} || 0;
    my $include    = $args{-include}    || '';
    my $focus          = $args{-focus};                          ## mark plate of focus more boldly (defaults to input plate)
    my $checkbox       = $args{-checkbox} || '';                 ## Add checkbox named '$checkbox' for each plate (value = id).
    my $tree           = $args{-tree};                           ## separate originals into separate treed layers...
    my $prefix         = $args{-prefix};
    my $suffix         = $args{-suffix};
    my $stop_recursion = $args{-stop_recursion};
    my $direction      = $args{-direction};

    my $max_gens = 20;
    if ( $generation > $max_gens ) { return "stopped at generation $max_gens - check for recursive ancestry"; }

    $plate_id = $dbc->get_id( $plate_id, 'Plate' );              ## extract only valid ids if supplied

    unless ($plate_id) {return}

    my %originals = $dbc->Table_retrieve( 'Plate', [ 'Plate_ID', 'FKOriginal_Plate__ID' ], "WHERE Plate_ID IN ($plate_id)", -distinct => 1 );

    my $output = '-';
    my $index  = 0;
    while ( defined $originals{Plate_ID}[$index] ) {
        my $original = $originals{FKOriginal_Plate__ID}[$index];
        my $plate    = $originals{Plate_ID}[$index];
        $index++;

        my $original_ancestor;
        $original_ancestor = alDente::Container::get_Parents( -dbc => $dbc, -id => $original, -format => 'original', -simple => 1 ) unless $stop_recursion;
        $original = $original_ancestor if $original_ancestor;

        ## when first called, unless focus is set specifically, display ancestry from original plate on, and track plate focus.
        my $this_focus = $focus;                                          ## local setting for each scanned plate
        my $this_include = $include ? "$plate_id,$include" : $include;    ## local setting for each scanned plate
        unless ($focus) {
            $args{-focus} = $plate_id;
            $this_focus   = $plate_id;                                    ## focus on all originally scanned in plates

            #	$plate_id = $original;
        }

        ## Separate call into originals if more than one plate supplied...  ##

        unless ($original) {next}

        my $align;
        if    ( $direction =~ /(fwd|forward)/ ) { $align = 'left' }
        elsif ( $direction =~ /rev/ )           { $align = 'right' }

        my $ancestry = HTML_Table->new( -class => 'small', -colour => 'WHITE', -border => 0, -width => '', -padding => 5, -spacing => 2, -align => $align, -width => '100%' );
        my ($name) = $dbc->Table_find_array( 'Plate', ["concat(FK_Library__Name,'-',Plate_Number)"], "WHERE Plate_ID IN ($original)", -distinct => 1 );
        $ancestry->Set_sub_header( " $name containers related to Pla$plate", 'lightredbw' ) unless ( $generation || $tree );
        my @fwd_groups = alDente::Container::get_next_gen( $dbc, $plate, -fields => ["concat(FK_Library__Name,Plate_Number) as Pnum"], -include => $this_include, -follow => 1 );
        my @rev_groups = alDente::Container::get_prev_gen( $dbc, $plate, -fields => ["concat(FK_Library__Name,Plate_Number) as Pnum"], -include => $this_include, -follow => 1 );

        ## get list of ancestors if this is the original plate called
        unless ( $generation || $this_include ) {
            my $include_parents  = alDente::Container::get_Parents( -dbc  => $dbc, -id => $this_focus, -format => 'list', -simple => 1 );    ## changed passing of $focus (?) to original
            my $include_children = alDente::Container::get_Children( -dbc => $dbc, -id => $this_focus, -format => 'list', -simple => 1 );
            $this_include = "$include_parents,$include_children";
        }

        my $fwd_view     = '';
        my $rev_view     = '';
        my @child_views  = ();
        my @parent_views = ();
        unless ( $direction =~ /rev/i ) {
            foreach my $child (@fwd_groups) {
                unless ($child) {next}
                my $child_view
                    = display_ancestry( -dbc => $dbc, -plate_id => $child, -recursive => $recursive, -generation => $generation + 1, -include => $this_include, -focus => $this_focus, -checkbox => $checkbox, -stop_recursion => 1, -direction => 'forward' );
                push( @child_views, $child_view ) if $child_view;
            }
            $fwd_view = join "<br>", @child_views;
        }

        unless ( $direction =~ /(fwd|forward)/i ) {
            foreach my $parent (@rev_groups) {
                unless ($parent) {next}
                my $parent_view = display_ancestry(
                    -dbc            => $dbc,
                    -plate_id       => $parent,
                    -recursive      => $recursive,
                    -generation     => $generation + 1,
                    -include        => $this_include,
                    -focus          => $this_focus,
                    -checkbox       => $checkbox,
                    -stop_recursion => 1,
                    -direction      => 'reverse'
                );
                push( @parent_views, $parent_view ) if $parent_view;
            }
            $rev_view = join "<br>", @parent_views;
        }

        my $tip = '';

        if (@rev_groups) {
            $ancestry->Set_Border(1) if ( int(@parent_views) > 1 );
            $tip .= "Derived from:<UL class=tip><LI>Pla";
            $tip .= join '<LI>Pla', @rev_groups;
            $tip .= "</UL>";
        }

        if (@fwd_groups) {
            $ancestry->Set_Border(1) if ( int(@child_views) > 1 );
            $tip .= "Aliquoted to:<UL class=tip><LI>Pla";
            $tip .= join '<LI>Pla', @fwd_groups;
            $tip .= "</UL>";
        }

        my $label;
        my $colour;
        $colour = '#66FF66' if ( $this_focus =~ /\b$plate\b/ );
        ## add checkbox if specified in front of label ##
        my $this_label = foreign_label( -dbc => $dbc, -plate_id => $plate, -include => $this_include, -colour => $colour, -tip => $tip );
        if ( $checkbox && $this_label ) {
            if ( $this_focus =~ /\b$plate\b/ ) {
                $label .= checkbox( -name => $checkbox, -value => $plate, -checked => 1 );
            }
            else {
                $label .= checkbox( -name => $checkbox, -value => $plate );
            }
        }
        $label .= $this_label . '<BR>' if $this_label;

        #    $label ||= '(no label found)';

        unless ($label) { Message("no label for $plate ($this_include)"); next }    ## return nothing if nothing found...
        my @rows;

        push( @rows, $rev_view ) if $rev_view;
        push @rows, $label;
        push( @rows, $fwd_view ) if $fwd_view;
        $ancestry->Set_Row( \@rows );
        my $output_view = $ancestry->Printout(0);
        if ($tree) {                                                                ## do not use tree if only one original ##
            $output .= create_tree( -tree => { "  $name containers related to Pla$plate" => $prefix . $output_view . $suffix } );
        }
        else {
            $output .= $prefix . $output_view . $suffix;
        }
    }
    return $output;
}

#
# Simplified version of Plate_History
#
# Return: Table showing Plate History information
#############################
sub view_History {
#############################
    my $self = shift;
    my %args = filter_input(\@_);
    my $dbc  = $args{-dbc} || $self->dbc();

    my $plate_id    = $args{-id};                 # plate id (or list of plate_ids)
    my $edit        = $args{-edit} || 0;          # Allow editing of results returned.
    my $verbose     = $args{-verbose} || 0;       # 0 for no output, 1 for basic, 2 for garrulous (not yet used)
    my $protocol_id = $args{-protocol_id} || 0;
    my $library     = $args{-library} || '';
    my $completed   = $args{-completed};          ## only show completed protocols
    my $plate_set   = $args{-plate_set};

    my $completed_condition;
    if ($completed) { $completed_condition = " AND Prep_Name like 'Completed Protocol'" }

    $plate_id = Cast_List( -list => $plate_id, -to => 'string' );
    $plate_id =~ s/,/, /g;

    my $ancestors = &alDente::Container::get_Parents( -dbc => $dbc, -id => $plate_id, -simple => 1, -format => 'list' )
        ;                                         ## >Table_find('Plate LEFT JOIN Plate as Parents ON Parents.Plate_ID=Plate.FKOriginal_Plate__ID', 'DISTINCT Parents.Plate_ID',"WHERE Plate.Plate_ID IN ($plate_id)");

    my $non_standard;                             #  = " AND Lab_Protocol.Lab_Protocol_Name NOT IN ('Standard')";

## Highlight Completed Protocol steps and Lowlight Standard actions ##
    my $highlight = {
        'Prep_Name' => { 'Completed Protocol' => { 'class'  => 'lightredbw' } },
        'Protocol'  => { 'Standard'           => { 'colour' => 'grey' } }
    };

    my $output;
    if ( $edit && $plate_set ) {
        my $preps = join ',', $dbc->Table_find( 'Plate_Prep', 'FK_Prep__ID', "WHERE FK_Plate_Set__Number in ($plate_set)" );
        $output .= &SDB::DB_Form_Viewer::edit_records( $dbc, 'Prep', 'Prep_ID', $preps );
    }
    elsif ( $edit && $plate_id ) {
        my $preps = join ',', $dbc->Table_find( 'Plate_Prep', 'FK_Prep__ID', "WHERE FK_Plate__ID in ($plate_id)");
        $output .= &SDB::DB_Form_Viewer::edit_records( $dbc, 'Prep', 'Prep_ID', $preps );
    }
    else {
        my @fields = (
            'Lab_Protocol_Name as Protocol',
            'GROUP_CONCAT(DISTINCT Prep_ID) as Prep_ID',
            'Prep_Name',
            'Left(Prep_DateTime,16) as Tracked_Time',
            'Employee.Initials',
            'Group_Concat(DISTINCT Plate_Prep.FK_Plate__ID) as Container_ID',
            'Group_Concat(DISTINCT FK_Solution__ID) as Solutions',
            "Group_Concat(DISTINCT Concat(Plate_Prep.Solution_Quantity, ' ', Plate_Prep.Solution_Quantity_Units)) as Sol_Qty",
            "Group_Concat(DISTINCT Concat(Plate_Prep.Transfer_Quantity, ' ', Plate_Prep.Transfer_Quantity_Units)) as Xfer_Qty",
            'Group_Concat(DISTINCT Equipment_Name) as Equipment',
            'FK_Plate_Set__Number',
            'Prep_Comments',
            "GROUP_CONCAT(DISTINCT CONCAT(Attribute_Name,' = ', Attribute_Value)) as Attributes",
        );
        push @fields, "'Edit' as Edit_Prep";

        my $page = $dbc->Table_retrieve_display(
            '(Prep, Plate_Prep, Plate, Lab_Protocol) LEFT JOIN Solution ON Solution_ID = Plate_Prep.FK_Solution__ID LEFT JOIN Equipment ON Equipment_ID = Plate_Prep.FK_Equipment__ID LEFT JOIN Employee ON Prep.FK_Employee__ID=Employee_ID LEFT JOIN Prep_Attribute ON Prep_Attribute.FK_Prep__ID=Prep_ID LEFT JOIN Attribute ON Attribute_ID=Prep_Attribute.FK_Attribute__ID',
            \@fields,
            "WHERE Plate.Plate_ID=Plate_Prep.FK_Plate__ID AND Plate_Prep.FK_Prep__ID=Prep_ID AND Prep.FK_Lab_Protocol__ID=Lab_Protocol_ID  AND Plate.FKOriginal_Plate__ID IN ($ancestors)  $non_standard $completed_condition",
            -group            => 'Prep_Name, Tracked_Time',
            -order            => 'Prep_DateTime, Prep_ID',
            -highlight_column => $highlight,
            -return_html      => 1,
            -list_in_folders  => [ 'Solutions', 'Container_ID', 'Equipment', 'Sol_Qty', 'Xfer_Qty', 'Prep_ID' ],

            # -debug            => 1,
            -title           => "Protocol Tracking History for Container(s):<BR> $plate_id",
            -link_parameters => { 'Edit_Prep' => "&cgi_application=alDente::Prep_App&rm=Edit+Prep&FK_Prep__ID=<Prep_ID>" },

        );

        $output = $page;
    }
    
    return $output;
}

################
sub Old_view_History {
################
    #
    # View Ancestry of Plate (previous / future generations)
    #
    my %args = @_;
    my $dbc  = $args{-dbc};
    $dbc->Benchmark('get_History');

    my $thisplate   = $args{-id};                 # plate id (or list of plate_ids)
    my $edit        = $args{-edit} || 0;          # Allow editing of results returned.
    my $verbose     = $args{-verbose} || 0;       # 0 for no output, 1 for basic, 2 for garrulous (not yet used)
    my $protocol_id = $args{-protocol_id} || 0;
    my $library     = $args{-library} || '';

    my $output;
    my $generations = Extract_Values( [ $args{-generations}, 20 ] );    # optional limit on # of gen's to search back..

    my %PHistory = {};                                                  ####### object storing various history info..

    my $Plate = new alDente::Container( -id => $thisplate, -dbc => $dbc );

    my $line_sep  = "<BR>";
    my $field_sep = ",";
    my $plate_sets;
    my $thisplate_set;
    my $platesetid;

    #    Future: display original tube source if available.. (or at least provide a link)
    my $parents = $thisplate;
    if ($thisplate) {                                                   ### if plate(s) specified
        ## get list of all plates in ancestry of 'thisplate'
        $parents = alDente::Container::get_Parents( -dbc => $dbc, -id => $thisplate, -generations => $generations, -format => 'list', -simple => 1 );
        ## get list of all applicable Plate Sets including any of above plates
        unless ( $parents =~ /[1-9]/ ) { Message("No valid Ancestry"); return 0; }
        $plate_sets = join ',', $dbc->Table_find( 'Plate_Set', 'Plate_Set_Number', "where FK_Plate__ID in ($parents)", 'Distinct' );

        ## get actual plate set only for 'thisplate' (not including ancestry)
        $thisplate_set = join ',', $dbc->Table_find( 'Plate_Set', 'Plate_Set_Number', "where FK_Plate__ID in ($thisplate)", 'Distinct' );

        ($platesetid) = $dbc->Table_find( 'Plate_Set', 'Max(Plate_Set_Number)', "where FK_Plate__ID in ($thisplate)" );

    }

    my $set_spec;
    if ( $plate_sets =~ /[1-9]/ ) {

        #	print "Sets: $thisplate_set from: ($plate_sets)";  ## feedback current set (all ancestral sets)
        $set_spec = "FK_Plate_Set__Number in ($plate_sets) OR ";
    }

    ### generate info from Prep table for all steps including appropriate sets...
    if ( $edit && $plate_sets ) {
        my $preps = join ',', $dbc->Table_find( 'Plate_Prep', 'FK_Prep__ID', "WHERE FK_Plate_Set__Number in ($plate_sets)" );
        $output .= &SDB::DB_Form_Viewer::edit_records( $dbc, 'Prep', 'Prep_ID', $preps );
    }
    elsif ( $edit && $thisplate ) {
        my $preps = join ',', $dbc->Table_find( 'Plate_Prep', 'FK_Prep__ID', "WHERE FK_Plate__ID in ($thisplate)" );
        $output .= &SDB::DB_Form_Viewer::edit_records( $dbc, 'Prep', 'Prep_ID', $preps );
    }
    else {

        #
        # get procedure history for all possible plate sets containing plate...
        #
        my @fields = (
            'FK_Plate__ID as Plate',
            'FK_Plate_Set__Number as Pset',
            'Lab_Protocol_Name as Protocol',
            'Lab_Protocol_ID as Protocol_ID',
            'Prep_Name as Step',
            'Prep_DateTime as DateTime',
            'Initials as Init',
            'Plate_Prep.FK_Equipment__ID as Equip',
            'Plate_Prep.FK_Solution__ID as Solution',
            'Plate_Prep.Solution_Quantity',
            'Plate_Prep.Solution_Quantity_Units',
            "Concat(Plate_Prep.Transfer_Quantity,' ',Plate_Prep.Transfer_Quantity_Units) as Xferred",
            'Prep_Comments as Comments',
            'Prep_ID as Preparation_ID',
        );

        my $container_type;
        if   ( $Plate->{type} =~ /plate/i ) { $container_type = 'Plate Attribute' }
        else                                { $container_type = 'Tube Attributes' }

        my $condition = "where Prep_ID=FK_Prep__ID AND Plate_Prep.FK_Plate__ID in ($parents)";
        my @headers = ( 'Protocol', 'Process', 'Date & Time', 'Done By', 'Solutions', 'Qty', 'Xferred', 'Equipment', 'Prep Attributes', 'Notes' );

        my $dates = join ',', $dbc->Table_find( 'Prep,Plate_Prep',              'Left(Prep_DateTime,10)', "$condition",                                         'distinct' );
        my $prots = join ',', $dbc->Table_find( 'Lab_Protocol,Prep,Plate_Prep', 'Lab_Protocol_Name',      "$condition AND Lab_Protocol_ID=FK_Lab_Protocol__ID", 'distinct' );
        my $inits = join ',', $dbc->Table_find( 'Prep,Plate_Prep,Employee',     'Initials',               "$condition and FK_Employee__ID=Employee_ID",         'distinct' );

        ## extract appropriate info...

        if ($platesetid) {

            # ? don't quite know why this is here. This excludes greater plate set numbers than the current one - which interferes with backfilling.
            #	    $condition .= " AND FK_Plate_Set__Number <= $platesetid ";
        }
        my %PHistory = Table_retrieve(
            $dbc, 'Lab_Protocol,Plate_Prep,Prep left join Employee on Prep.FK_Employee__ID=Employee_ID',
            \@fields,
            "$condition AND Lab_Protocol_ID=FK_Lab_Protocol__ID GROUP BY Prep_ID,FK_Solution__ID,FK_Equipment__ID ORDER BY Prep_DateTime",
            -date_format => "SQL"
        );

        my $History = HTML_Table->new();    ### prepare HTML Table..
                                            #	$History->Set_Line_Colour('grey');

        ######## Print common info together in title... ##########
        #	(my $plate,my $set,my $prot,my $prep,my $DT,my $init,my $equip, my $sol) = split ',',$history[0];
        #	($DT) = split ' ',$DT;         # get Date only (time comes after a space)

        $prots =~ s/(\,?Standard\,?)//g;    # remove 'Standard' from list of protocols
        my $title = "History for $library Container(s) $thisplate.";
        $title .= $q->b("Container Set $plate_set")      if $plate_set;
        $title .= '<BR>' . $q->b("Protocols: ") . $prots if $prots;
        $title .= '<BR>' . $q->b("Date: ") . $dates      if $dates;
        $title .= '<BR>' . $q->b("By: ") . $inits        if $inits;
        $History->Set_Title($title);
        $History->Set_Class('small');
        $PHistory{Sets} = $plate_sets;
        $PHistory{Set}  = $thisplate_set;

        $History->Set_Headers( \@headers );
        my $last_set;
        my $index = -1;
        #### for each step in history of plate_sets, generate row for table ###

        my ( @prep_ids, @sol_list, @sol_vol, @xfer, @equip_list, $comments, $prep_attr );
        while ( defined $PHistory{Protocol}[ ++$index ] ) {

            ## If a new set is found, print out a subheader for the set... ##
            if ( $PHistory{Pset}[$index] && ( $last_set != $PHistory{Pset}[$index] ) ) {
                my @plates_in_set = $dbc->Table_find( 'Plate_Set', 'FK_Plate__ID', "WHERE Plate_Set_Number = $PHistory{Pset}[$index]", 'distinct' );
                my $list = join "<BR>", map { 'PLA' . $_ } @plates_in_set;

                #my $plates_in_set_list = Show_Tool_Tip(int(@plates_in_set) . ' plate(s)', "Container Set Content:<BR>$list");
                my $plates_in_set_list
                    = &Link_To( $dbc->config('homelink'), int(@plates_in_set) . ' plate(s)', "&Info=1&Table=Plate&Field=Plate_ID&Like=" . join( ',', @plates_in_set ), -window => ['newwin'], -tooltip => "Container Set Content:<BR>$list" );
                $History->Set_Row( [ b("Container Set $PHistory{Pset}[$index]") .  '<br>' . $plates_in_set_list ], 'lightredbw' );
                $History->Toggle_Colour();
            }

            ## update list of prep_ids for this step ##
            my $prep_id = $PHistory{Preparation_ID}[$index];
            unless ( grep /^$prep_id$/, @prep_ids ) { push( @prep_ids, $prep_id ) }

            ## update list of equipment for this step ##
            if ( $PHistory{Equip}[$index] =~ /[1-9]/ ) {
                my $equip_id       = $PHistory{Equip}[$index];
                my $equip_name     = &get_FK_info( $dbc, 'FK_Equipment__ID', $equip_id );
                my $equipment_link = &Link_To( $dbc->config('homelink'), "$equip_name", "&Info=1&Table=Equipment&Field=Equipment_ID&Like=$equip_id", 'blue', ['newwin'] );
                unless ( grep /Equ$equip_id:/i, @equip_list ) { push( @equip_list, $equipment_link ); }
            }
            ## update list of solutions for this step ##
            if ( $PHistory{Solution}[$index] =~ /[1-9]/ ) {
                my $sol      = $PHistory{Solution}[$index];
                my $nextsol  = &get_FK_info( $dbc, 'FK_Solution__ID', $sol );
                my $sol_link = &Link_To( $dbc->config('homelink'), "$nextsol", "&Info=1&Table=Solution&Field=Solution_ID&Like=$sol", 'blue', ['newwin'] );
                unless ( grep /Sol$sol:/, @sol_list ) { push( @sol_list, $sol_link ) }
            }

            ## update comments for this step ##
            if ( $PHistory{Comments}[$index] ) {
                $comments .= $PHistory{Comments}[$index] . ";<BR>";
            }

            ## update prep_attributes for this step ##
            $prep_attr .= join( "<BR>", @{ $Plate->get_attributes( -table => "Prep", -id => $prep_id ) } );
            $prep_attr .= "<BR>" if $prep_attr !~ /<BR>$/;

            if ( $PHistory{Solution_Quantity}[$index] ) {
                my $volume = $PHistory{Solution_Quantity}[$index] . ' ' . $PHistory{Solution_Quantity_Units}[$index];
                push( @sol_vol, $volume );
            }

            if ( $PHistory{Xferred}[$index] ) { push @xfer, $PHistory{Xferred}[$index] }

            ## if next step is a new step (or no more step) ... print out row & re-initialize
            if ( $index == $#{ $PHistory{Protocol} } || $PHistory{DateTime}[$index] ne $PHistory{DateTime}[ $index + 1 ] || $PHistory{Step}[$index] ne $PHistory{Step}[ $index + 1 ] ) {
                my @row = _generate_history_row( $dbc, \%PHistory, $index, \@prep_ids, \@sol_list, \@sol_vol, \@xfer, \@equip_list, $comments, $prep_attr );
                ( @prep_ids, @sol_list, @sol_vol, @xfer, @equip_list, $comments, $prep_attr ) = ();

                # if the protocol is standard, show in a slightly different colour
                if ( ( $row[0] =~ /^Standard$/i ) && ( $row[1] =~ /Throw Away/ ) ) {
                    ## skip throw away events...
                }
                elsif ( $row[0] =~ /^Standard$/i ) {
                    $History->Set_Row( \@row, 'lightgrey' );
                    $History->Toggle_Colour();
                }
                else {
                    $History->Set_Row( \@row );
                }
            }

            $last_set = $PHistory{Pset}[$index];
        }

        $History->Toggle_Colour_on_Column(1);
        my $timestamp = &RGTools::RGIO::timestamp;
        $output .= $History->Printout("$URL_temp_dir/History.$timestamp.html");    ## generate standalone page for printing...
        $output .= $History->Printout(0);
        $dbc->Benchmark('got_History');
    }
    return $output;
}

#######################
sub _generate_history_row {
#######################
    my $dbc        = shift;
    my $history    = shift;                                                        ## the hash with the history info
    my $index      = shift;                                                        ## the index where we are looking
    my $prep_ids   = shift;
    my $sol_list   = shift;
    my $sol_vol    = shift;
    my $xfer       = shift;
    my $equip_list = shift;
    my $comments   = shift;
    my $prep_attr  = shift;

    my %PHistory = %{$history};

    my $ids      = join ',',    @$prep_ids;                                        ## list of prep_ids
    my $sols     = join '<BR>', @$sol_list;                                        ## list of solutions used (for this step)
    my $sol_vols = join '',     @$sol_vol;
    my $xfers    = join '<BR>', @$xfer;
    my $equips   = join '<BR>', @$equip_list;                                      ## list of equipment used (for this step)

    if   ($sols) { $sols = "<Span class=small>$sols</Span>"; }
    else         { $sols = '-'; }                                                  ## (reformat as necessary)

    if   ($equips) { $equips = "<Span class=small>$equips</Span>"; }
    else           { $equips = '-'; }                                              ## (reformat as necessary)

    my $DT   = $PHistory{DateTime}[$index] || '';
    my $init = $PHistory{Init}[$index]     || '';
    my $prot = $PHistory{Protocol}[$index] || '';
    my $step = $PHistory{Step}[$index];

    ## print out last prep for final preparation step
    my $step_link = &Link_To( $dbc->config('homelink'), "<B>$step</B>", "&Info=1&Table=Prep&Field=Prep_ID&Like=$ids", $Settings{LINK_COLOUR}, ['newwin'] );

    my @row = ( $prot, $step_link, $DT, $init, $sols, $sol_vols, $xfers, $equips, $prep_attr, $comments );
    return @row;
}

###############
#
# form view enabled for creating new plate records
#
#
########################
sub original_form {
########################
    # Create Original Plate from Library
    #
    my %args = @_;

    my $dbc        = $args{-dbc};
    my $lib        = $args{-library};
    my $type       = $args{-type};
    my $import     = $args{-import};
    my $plate_type = $args{-plate_type};

    my $create_extraction_details = $args{-create_extraction_details} || 0;
    my $source                    = $args{-source};
    my $plate_status              = $args{-plate_status} || 'Active';
    my $failed                    = $args{-failed} || 'No';
    my $require                   = $args{ -require };

    my $output;

    my $Current_Department = $dbc->config('Target_Department');
    if ( $type =~ /import/ ) {
    }
    elsif ( $type =~ /transfer/ ) {
        return _child_form($lib);
    }
    elsif ( $type =~ /rearray/ ) {
        return &alDente::ReArray::rearray_plate($lib);
    }
    else {

        #	 h3("Creating New Original Plate from Library");
    }

    my ($library) = $dbc->Table_find( 'Library', 'Library_Name', "where Library_Name like '$lib'" );
    unless ( $library =~ /\S{5,6}/ ) {
        if ($lib) { Message("Invalid Name: '$lib' for Library"); }
        $library = '';
    }

    my $p_type;
    if ( $plate_type =~ /tube/i ) {
        $p_type = 'Tube';
    }
    else {
        $p_type = 'Plate';
    }

    #my $platenum = 0;
    if ($library) {

        #($platenum) = $dbc->Table_find_array('Plate',['Max(Plate_Number)'],"where FK_Library__Name like '$library'");
        #$platenum++;
        #print "Making New $type $p_type $platenum in $library Library";
        my @library_sources = $dbc->Table_find( 'Library_Source', 'FK_Source__ID', "WHERE FK_Library__Name='$library'" );

        unless ($source) {
            if ( int(@library_sources) == 1 ) {
                $source = $library_sources[0];
            }
            else {
                $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'NewPlate', -type => 'plate' );
                Message("Please specify Source for which you you would like to add an original $p_type in $library");
                my %labels = ();
                foreach my $src (@library_sources) {
                    $labels{$src} = "$src - " . alDente::Source::source_name( undef, -dbc => $dbc, -id => $src );
                }
                $output .= "Available Sources: " . Show_Tool_Tip( $q->popup_menu( -name => 'Source', -values => \@library_sources, -labels => \%labels, -default => '' ), "List of Source ID's" ) . '<P>';
                $output .= $q->hidden( -name => 'Library.Library_Name', -value => $library,      -force => 1 );
                $output .= $q->hidden( -name => 'Status',               -value => $plate_status, -force => 1 );
                $output .= $q->hidden( -name => 'Failed',               -value => $failed,       -force => 1 );
                $output .= Show_Tool_Tip( $q->submit( -name => "rm", -value => "New $p_type", -class => "Std" ), "Confirm create $p_type" );
                $output .= $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App' );
                $output .= $q->end_form();
            }
        }

    }
    else {    ## require Library specification (so that next plate number may be determined)
        $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'NewPlate', -type => 'plate' );
        Message("Please specify Library for which you would like to add an original $p_type");
        $output .= &alDente::Tools::search_list( -dbc => $dbc, -name => 'Library.Library_Name', -field => 'Library_Name', -table => 'Library', -filter_by_dept => 1, -filter => 1 );
        my $order = "LENGTH(Library_Name), Library_Name";
        $output .= $q->hidden( -name => 'New Plate Type', -value => $type );
        $output .= $q->hidden( -name => 'Status',         -value => $plate_status );
        $output .= $q->hidden( -name => 'Failed',         -value => $failed, -force => 1 );
        $output .= $q->submit( -name => "rm", -value => "New $p_type", -class => "Std" );
        $output .= $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App' );
        $output .= $q->end_form();
        return $output;
    }

    unless ($source) {
        return $output;
    }

    my %preset;
    my $user_id = $dbc->get_local('user_id');
    my ($user_popdown) = $dbc->get_FK_info( 'FK_Employee__ID', $user_id );

    my %grey;
    my %omit;
    my %include;
    my %list;

    $grey{'Plate.FK_Employee__ID'}  = $user_popdown;
    $grey{'Plate.FK_Library__Name'} = $library;
    $grey{'Plate.Plate_Status'}     = $plate_status;
    $grey{'Plate.Failed'}           = $failed;

## Remove these from DB_Form FK check, updated later
    $omit{'Plate.Plate_Number'}         = '';
    $omit{'Plate.FKParent_Plate__ID'}   = '';
    $omit{'FK_Rack__ID'}                = '1';
    $omit{'Plate.Plate_Size'}           = '';    # Remove these from the DB Form, will be updated later
    $omit{'Plate.FK_Branch__Code'}      = '';
    $omit{'Plate.Plate_Parent_Well'}    = '';
    $omit{'Plate.FKOriginal_Plate__ID'} = '';
    $omit{'Plate.Parent_Quadrant'}      = '';

    # filter pipelines
    my $group_list = $dbc->get_local('group_list');
    my @pipelines = sort @{ alDente::Grp::get_group_pipeline( -dbc => $dbc, -grp => $group_list, -department_name => $Current_Department, -return_format => 'Name' ) };
    $list{'Plate.FK_Pipeline__ID'} = \@pipelines;

    $preset{'Plate.Plate_Created'} = &date_time();

    # fill in default work request ID
    my @work_requests = &get_FK_info( $dbc, 'FK_Work_Request__ID', -condition => "WHERE FK_Library__Name='$library' AND FK_Funding__ID IS NOT NULL", -list => 1 );
    $list{'Plate.FK_Work_Request__ID'} = \@work_requests;

### set attributes slightly differently based upon Plate Type (eg. Library_Plate or Tube)

    if ( $plate_type =~ /Tube/i ) {
        $grey{'Library_Plate.Plate_Position'} = 'n/a';
        $grey{'Plate.Plate_Type'}             = 'Tube';

        my @tube_formats = $dbc->get_FK_info( 'FK_Plate_Format__ID', -condition => "WHERE Plate_Format_Style like 'Tube'", -list => 1 );
        $list{'Plate.FK_Plate_Format__ID'} = \@tube_formats;

        ## This was commented out (below) - not sure if extraction details are necessary or not ...?? ##
        if ($create_extraction_details) {
            $include{"Tube.Create_Extraction_Details"} = 1;
        }
    }
    else {
        $grey{'Plate.Plate_Type'}              = 'Library_Plate';
        $preset{'Library_Plate.Sub_Quadrants'} = 'a,b,c,d';         ### default to a,b,c,d

        my @plate_formats = $dbc->get_FK_info( 'FK_Plate_Format__ID', -condition => "WHERE Plate_Format_Style like 'Plate'", -list => 1 );
        $list{'Plate.FK_Plate_Format__ID'} = \@plate_formats;
    }

    my $lib_type = &alDente::Library::check_Library_Type( -library => $library );
    if ( $lib_type eq 'seq_lib' ) {

        #        $list{'Plate.Plate_Content_Type'}   = ['Clone'];            # [ate_Contents{Sequencing_Library}{'Plate_Content_Type'}];
        #        $preset{'Plate.Plate_Content_Type'} = 'Clone';
        my ($clone_type_id) = $dbc->Table_find( 'Sample_Type', 'Sample_Type_ID', "WHERE Sample_Type = 'Clone'" );
        $list{'Plate.FK_Sample_Type__ID'}   = [$clone_type_id];     # [ate_Contents{Sequencing_Library}{'Plate_Content_Type'}];
        $preset{'Plate.FK_Sample_Type__ID'} = $clone_type_id;
        my @sample_types = &get_FK_info( $dbc, 'FK_Sample_Type__ID', -condition => "WHERE Sample_Type = 'Clone'", -list => 1 );
        $list{'Plate.FK_Sample_Type__ID'} = \@sample_types;
    }
    elsif ( $lib_type eq 'rna_lib' ) {

        #        $list{'Plate.Plate_Content_Type'} = [ 'DNA', 'RNA', 'Protein', 'Mixed', 'Amplicon', 'mRNA', 'Tissue', 'Cells', 'RNA - DNase Treated', 'cDNA', '1st strand cDNA', 'Amplified cDNA', 'Ditag', 'Concatemer - Insert', 'Concatemer - Cloned' ];
        #        $preset{'Plate.Plate_Content_Type'} = 'Mixed';

        my @sample_types = &get_FK_info( $dbc, 'FK_Sample_Type__ID', -condition => "WHERE Sample_Type NOT IN ('Clone')", -list => 1 );
        $list{'Plate.FK_Sample_Type__ID'} = \@sample_types;
        my @preset_sample_type = &get_FK_info( $dbc, 'FK_Sample_Type__ID', -condition => "WHERE Sample_Type = 'Mixed'", -list => 1 );
        $preset{'Plate.FK_Sample_Type__ID'} = \@preset_sample_type;
    }

    my %require;
    if ($require) {
        my $required = join ',', $require;    ## either comma-delim or array
        foreach my $ensure ( split ',', $required ) {
            $require{$ensure} = 1;
        }
    }

    $include{'New Plate Type'}      = 'Original';
    $include{'Add Plate Source_ID'} = $source;

    #    my ($start) = $dbc->Table_find('Plate',"Max(Plate_Number)","WHERE FK_Library__Name = '$library'");

    my ($start) = alDente::Library::get_next_plate_number( $dbc, $library );
    my $append_html
        = "Repeat X "
        . Show_Tool_Tip( $q->textfield( -name => 'DBRepeat', -size => 3, -default => 1, -force => 1 ), "Enter a number here if you wish to generate multiple original plates (with the same details) simultaneously" )
        .  '<br>'
        . "Plate Numbers starting from: "
        . Show_Tool_Tip(
        $q->textfield( -name => 'Starting Plate Number', -size => 3, -default => $start, -force => 1 ),
        "Only change this if you want to explicitly advance (or set back) the Plate Number generated for the new plate(s).<br>Unused numbers beginning with the one specified here will be used<BR>The number shown will be the number normally applied to the next plate created."
        );

    my $form = SDB::DB_Form->new( -dbc => $dbc, -table => 'Plate', -target => 'Database', -append_html => $append_html );
    $form->configure( -preset => \%preset, -grey => \%grey, -require => \%require, -title => 'Original Plate Form', -list => \%list, -include => \%include, -omit => \%omit );

    $output = $form->generate( -return_html => 1 );
    return $output;
}

##################
sub _child_form {
##################
    #
    # Create daughter plate from Existing plate
    #
    my %args = @_;

    my $dbc      = $args{-dbc};
    my $end_form = $args{-end_form} || 'yes';    ## close form unless 'no'
    my $parents  = $args{-parents};

    my $output = h3("Creating New Plate from Existing Plate");

    my $current_date = &date_time();
    my $lib          = Library->new();

    #    my @lib_plate_info = $lib->library_plates(param('Library.Library_Name'),param('Use Plate Number'));

    #    $last_page = "Child Plate";

    $output .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'ChildPlate', -type => 'plate' );
    if ($parents) {
        $output .= $q->hidden( -name => 'Parent Plate', -value => $parents );
    }
    else {
        $output .= "Parent Plate(s): " . $q->textfield( -name => 'Parent Plate', -size => 30 ) . " (may enter list)<BR>";

        #		    popup_menu(-name=>'Parent List',-value=>[@lib_plate_info]);
    }

    my %Parameters;
    $Parameters{Plate_Created} = $current_date;

    my $form = SDB::DB_Form->new( -dbc => $dbc, -table => 'Plate', -target => 'Database', -parameters => \%Parameters, 'start_form' => 1, -title => 'Child Plate Form' );
    $output .= $form->generate( -return_html => 1 );

    $output .= "Repeat X:" . &hspace(5) . $q->textfield( -name => 'TransferX', -size => 4, -default => 1 );

    unless ( $end_form =~ /no/i ) { $output .= $q->end_form() }

    return $output;
}

####################################################################
# Display the update plate schedule form
#
# Usage: update_plate_schedule_frm(-dbc=>$dbc, -plate_id=>[122,2222]);
# return HTML form;
###############################
sub update_plate_schedule_frm {
###############################
    my %args     = filter_input( \@_ );
    my $plate_id = $args{-plate_id};
    my $dbc      = $args{-dbc};
    my @plates   = Cast_List( -list => $plate_id, -to => 'Array' );
    require alDente::Plate_Schedule;
    my $plate_schedule_obj = alDente::Plate_Schedule->new( -dbc => $dbc );
    my @pipelines;
    foreach my $plate (@plates) {
        my $schedule = $plate_schedule_obj->get_plate_schedule( -plate_id => $plate );
        @pipelines = @{ $schedule->{FK_Pipeline__ID} } if defined( $schedule->{FK_Pipeline__ID} );
    }
    my $table = HTML_Table->new( -class => 'small', -title => 'Update Plate Schedule' );
    if (@pipelines) {
        foreach my $pipeline (@pipelines) {
            $pipeline = $dbc->get_FK_info( 'FK_Pipeline__ID', $pipeline );
            my $pipeline_select = &alDente::Tools::search_list( -dbc => $dbc, -name => 'FK_Pipeline__ID', -filter_by_dept => 1, -search => 1, -filter => 1, -default => $pipeline );
            $table->Set_Row( [$pipeline_select], -repeat => 1 );
        }
    }
    else {
        my $pipeline_select = &alDente::Tools::search_list( -dbc => $dbc, -name => 'FK_Pipeline__ID', -filter_by_dept => 1, -search => 1, -filter => 1 );
        $table->Set_Row( [$pipeline_select], -repeat => 1 );
    }
    my $plate_schedule_btn = $plate_schedule_obj->update_plate_schedule_btn();
    $table->Set_Row( [$plate_schedule_btn] );
    my $frm .= alDente::Form::start_alDente_form( $dbc, -name => 'Update_Plate_Schedule_Frm', -link => $dbc->config('homelink') );
    $frm .= $table->Printout(0);
    $frm .= hidden( -name => 'rm',              -value => 'Update_Plate_Schedule',  -force => 1 );
    $frm .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );
    $frm .= hidden( -name => 'Plate_ID',        -value => \@plates );
    $frm .= end_form();
    return $frm;
}

########################################
#
# Tool box to display plate ancestry and allows the user to fail plates
#
####################
sub fail_toolbox {
####################
    my %args = &filter_input( \@_, -args => 'plates', -mandatory => 'plates' );
    my $dbc = $args{-dbc};

    my $Plate  = $args{-Plate};
    my $plates = $args{-plates} || $Plate->{plate_id};
    my $tree   = $args{-tree};

    if ( $plates =~ /,/ ) { $tree = 1; }
    ## Get the fail reasons for the groups of the user
    my $groups   = $dbc->get_local('group_list');
    my $reasons  = alDente::Fail::get_reasons( -object => 'Plate', -grps => $groups );
    my $checkbox = 'Confirm_Fail';
    my ( $prefix, $suffix );
    if ($reasons) {
        $prefix = alDente::Form::start_alDente_form( $dbc, 'Fail' );
        $suffix
            = button( -name => 'Select All', -onClick => "SetSelection(this.form,'$checkbox',1,'all')", -class => 'Std' )
            . hspace(5)
            . button( -name => 'Clear All', -onClick => "SetSelection(this.form,'$checkbox',0,'all')", -class => 'Std' )
            .  '<br>'
            . 'Fail Reason: '
            . popup_menu(
            -name   => 'FK_FailReason__ID',
            -values => [ sort keys %{$reasons} ],
            -labels => $reasons,
            -force  => 1
            )
            . hspace(4)
            . ' Notes: '
            . textfield( -name => 'Mark Note', -size => 20, -id => 'Mark Note' )
            . set_validator( -name => 'FK_FailReason__ID', -mandatory => 1 )
            .  '<br>'
            . checkbox( -name => 'Throw_out', -label => 'Fail & throw out' )
            . hspace(5)
            . submit(
            -name    => 'rm',
            -value   => 'Fail Plates',
            -class   => 'Action',
            -onClick => 'return validateForm(this.form)'
            )
            . hidden(
            -name  => 'cgi_application',
            -value => 'alDente::Container_App',
            -force => 1
            ) . end_form();
    }

    $Plate ||= new alDente::Container( -dbc => $dbc, -id => $plates );

    ## generate prefix and suffix that should be included in each (if > 1) display_ancestry tree ##
    my $string = display_ancestry(
        -dbc      => $dbc,
        -plate_id => $plates,
        -checkbox => $checkbox,
        -tree     => $tree,
        -prefix   => $prefix,
        -suffix   => $suffix
    );

    if ( grep /\bAdmin\b/, @{ $dbc->get_local('groups') } ) {
        $string .= &Link_To( $dbc->config('homelink'), '(<i>Define New Fail Reason</i>)', '&New+Entry=New+FailReason', $Settings{LINK_COLOUR}, ['newwin'] );
    }

    return $string;
}

######################
sub search_options {
######################
    my %args           = &filter_input( \@_, -args => 'Plate' );
    my $Plate          = $args{-Plate};
    my $id             = $args{-id} || $Plate->{id};                         ## current id
    my $current_plates = $args{-current_plates} || $Plate->{list} || $id;    ## current plates

    #    my $parameters     = shift;  ## parameters to pass into form
    my $dbc = $Plate->{dbc};

    my $button_value;
    if    ( $Plate->{type} =~ /plate/i ) { $button_value = 'Plate History' }
    elsif ( $Plate->{type} =~ /array/i ) { $button_value = 'Array History' }
    else                                 { $button_value = 'Tube History' }

    my $output = alDente::Form::start_alDente_form( $dbc, 'search_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'search_options',undef,$parameters);
    $output .= hidden( -name => 'Plate IDs',    -value => $id,             -force => 1 );
    $output .= hidden( -name => 'Barcode',      -value => "Pla$id",        -force => 1 );
    $output .= hidden( -name => 'Parent Plate', -value => $current_plates, -force => 1 );

    my $search_options_table = HTML_Table->new();
    $search_options_table->Set_Class('small');
    $search_options_table->Set_Width('100%');
    $search_options_table->Toggle_Colour('off');
    $search_options_table->Set_Row( [ submit( -name => 'rm', -value => "List Applied Reagents", -class => "Search", -force => 1 ) ] );
    $search_options_table->Set_Row(
        [         submit( -name => 'rm', -value => 'Protocol Summary', -class => "Search", -force => 1 )
                . &hspace(5)
                . 'Scope: '
                . radio_group( -name => 'PS Scope', -values => [ 'Library', 'Plate' ], -default => 'Plate', -force => 1 )
                . &hspace(5)
                . ' Plate #s:'
                . Show_Tool_Tip( textfield( -name => 'Plate Numbers', -size => 6, -default => '' ), " Indicate range of Plate numbers to include (eg 1-5)" )
                . hidden( -name => 'Library_Name', -value => $Plate->value('Plate.FK_Library__Name'), -force => 1 )
                . hidden( -name => 'Plate Number', -value => $Plate->value('Plate.Plate_Number'),     -force => 1 )
        ]
    );
    $search_options_table->Set_Row(
        [         submit( -name => 'rm', value => 'Plate History', -class => "Search" )
                . hspace(5)
                . checkbox( -name => 'Allow editing' )
                . hspace(5)
                . Show_Tool_Tip( checkbox( -name => 'Completed Protocols only' ), "Only retrieve record of completed protocols" )
        ]
    );

    if ( $dbc->package_active('Sample_Tracking') ) {
        $search_options_table->Set_Row( ['<HR SPAN=2>'] );
        if ( $Plate->value('Plate.Plate_Type') eq 'Tube' ) {
            $search_options_table->Set_Row( [ submit( -name => 'rm', -value => 'Get Sample Info', -class => "Search" ) . hidden( -name => 'Sample Plate', -value => $plate_id ) . hidden( -name => 'Well', -value => 'n/a' ) ] );
        }
        elsif ( $Plate->value('Plate.Plate_Type') eq 'Library_Plate' ) {
            $search_options_table->Set_Row(
                [         'Get '
                        . submit( -name => 'rm', -value => 'Get Sample Info',       -class => "Search", -force => 1 ) . ' or '
                        . submit( -name => 'rm', -value => 'DNA Quantitation Info', -class => "Search", -force => 1 )
                        . ' for Well: '
                        . textfield( -name => 'Well' )
                        . " (eg. 'A01')"
                        . hidden( -name => 'Sample Plate', -value => $plate_id )
                ]
            );
        }
    }
    $output .= $search_options_table->Printout(0);
    $output .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );    ## only rm for cgi_application currently (will need to be changed to handle all through run modes)
    $output .= end_form();

    return $output;
}

#
# Renamed from misc_options (not very helpful)
#
# This should be placed somewhere more appropriate than a standalone layer 
#
#
####################
sub upload_aliases {
####################
    my $Plate          = shift;
    my $id             = shift || $Plate->{id};                                                          ## current id
    my $current_plates = shift || $Plate->{list} || $id;                                                 ## current plates
                                                                                                         #   my $parameters     = shift;  ## parameters to pass into form
    my $dbc            = $Plate->{dbc};

    my $output = alDente::Form::start_alDente_form( $dbc, 'misc_options', -type => 'Plate' );            ## alDente::Form::start_alDente_form($dbc,'misc_options',undef,$parameters);
    $output .= hidden( -name => 'Barcode',      -value => "Pla$id" );
    $output .= hidden( -name => 'Parent Plate', -value => $current_plates );

    #    $output .= hidden(-name=>'id',-value=>$plate_id) . hidden(-name=>'type',-value=>'Ligation') . hspace(10);
    $output .= hidden( -name => 'id', -value => $id ) . hspace(10);
    $output .= hidden(-name=>'cgi_application', -value=>'alDente::Container_App', -force=>1);
    
    # hidden(-name=>'type',-value=>'Ligation') . hspace(10);

    my $misc_table = HTML_Table->new();
    $misc_table->Set_Class('small');
    $misc_table->Set_Width('100%');
    $misc_table->Toggle_Colour('off');

    if ( $dbc->package_active('Sample_Tracking') ) {
        $misc_table->Set_Row(
            [   '<B>Sample Aliases:</B>',
                Show_Tool_Tip(
                    submit(
                        -name  => 'rm',
                        -value => 'Upload Sample Aliases',
                        -style => "background-color:lightgreen"
                    ),
                    "Use the browse button to choose the sample alias file and upload"
                ),
                filefield(
                    -name      => 'Sample Alias File',
                    -default   => 'File name',
                    -size      => 20,
                    -maxlength => 200
                )
            ]
        );
    }

    if ( $misc_table->rows() ) {
        $output .= $misc_table->Printout(0);
        $output .= end_form();
        return $output;
    }

    return;
}

#####################
sub choose_set {
#####################
    my $sets   = shift;
    my $plates = shift;

    my $prompt = "Choose Set: ";

    my $default = "Save NEW set";
    my @set_options = Cast_List( -list => $sets, -to => 'array', -sort => 'desc' );

    # if set options is blank, remove it
    if ( int(@set_options) > 0 ) {
        if ( $set_options[0] == '' ) {
            shift @set_options;
        }
    }
    if ( ( int(@set_options) == 1 ) && ( $set_options[0] =~ /(\d+)/ ) ) { $default = $set_options[0] }
    elsif ( int(@set_options) > 1 ) { $default = $set_options[0] }
    push( @set_options, 'Save NEW set' );

    my $options = radio_group( -name => 'Plate_Set_Number', -values => \@set_options, -default => $default, -linebreak => 'true' );
    if ($plates) { $options .= hidden( -name => 'Plate_ID', -value => $plates, -force => 1 ) }

    return $BS->row( [ $prompt, $options ], -span => [ 4, 4 ] );
}

###################################################
# Generate form to extract new plate_content type
#
#
#
#####################
sub extract_prompt {
#####################

    my $Plate = shift;
    my $id    = shift;    ## current id
    $current_plates = shift;    ## current plates

    #    my $parameters     = shift;  ## parameters to pass into form

    my $dbc = $Connection;
    my @transfer_types = ( 'Transfer', 'Aliquot', 'Pre-Print' );

    my $output = alDente::Form::start_alDente_form( $dbc, 'extract_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'extract_options',undef,$parameters);
    $output .= hidden( -name => 'Barcode',         -value => "Pla$id" );
    $output .= hidden( -name => 'Parent Plate',    -value => $current_plates );
    $output .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );

    my $form = 'plate';

    $Plate->{type} ||= $Plate->value('Plate.Plate_Type');

## tube option to pool current plates
    if ( $Plate->{type} =~ /tube/i && $current_plates =~ /,/ ) {
        push @transfer_types, 'Pool';
    }
    else {
        push @transfer_types, 'Extract';
    }

    my @transfer_units = &get_enum_list( $Plate->{dbc}, 'Plate_Prep', 'Transfer_Quantity_Units' );

    $output .= hidden( -name => 'Plate_Type', -value => $Plate->{type} );

    my $def_rack = get_FK_info( $dbc, 'FK_Rack__ID', $Plate->value('Plate.FK_Rack__ID') );    ## convert to readable...
    my $notes = $Plate->value('Plate.Plate_Comments') || '';

    #my $condition;
    #if ( $Plate->{type} =~/Library/i ) { $condition = "WHERE Plate_Format_Style like 'Plate'" }
    #elsif ( $Plate->{type} =~/Tube/i ) { $condition = "WHERE Plate_Format_Style like 'Tube'" }

    my @formats = &get_FK_info( $dbc, 'FK_Plate_Format__ID', -list => 1, -condition => " Plate_Format_Style NOT LIKE 'Array'" );

    ### options only for Library Plates ###
    my $quadrant_packing;
    my $quadrant_options;
    if ( $Plate->{type} =~ /Library/i ) {
        ## <CONSTRUCTION> If a user selects quadrants of a Tray the system does not extract only those quadrants, and does it for all the plates on that tray
        if ( $Plate->value('Plate_Format.Wells') =~ /384/ ) {
            $quadrant_packing = checkbox( -name => 'Pack Quadrants' );
            $quadrant_options = "Extract 96-well quadrants:<BR>" . checkbox_group( -name => 'Quadrant', -values => [ 'a', 'b', 'c', 'd' ] ) . &hspace(10);
        }
        else {
            $quadrant_packing = hidden( -name => 'Pack Quadrants', -value => 1 );
        }
    }

    ### print transfer block ###
    if ( $scanner_mode == 2 ) {
        if ( $Configs{volume_tracking} ) {
            $output .= "<BR>Amount: " . Show_Tool_Tip( textfield( -name => 'Transfer_Quantity', -size => 5 ) . "Entire volume assumed if not entered" ) . popup_menu( -name => 'Transfer_Quantity_Units', -values => \@transfer_units );
        }

        if ( int(@formats) == 1 ) {
            $output .= hidden( -name => 'Target Plate Format', -value => $formats[0] );
        }
        else {
            $output .= "<br>New Type: " . popup_menu( -name => 'Target Plate Format', -force => 1, -values => [ '', @formats ], default => '' ) . '<BR>';
        }

        #	$output .= "(Repeat X ". textfield(-name=>'TransferX',-size=>5,-default=>'1') . ")<BR>";
        $output .= checkbox( -name => 'Test Plate Only' ) . "<BR>" . $quadrant_packing . $quadrant_options;
    }

    my $dispense = HTML_Table->new( -padding => 3 );
    $dispense->Set_Title( 'Extract New Sample Type', fsize => '-1' );

    $dispense->Set_Class('small');
    $dispense->Toggle_Colour('off');

    if ( $Configs{volume_tracking} ) {
        $dispense->Set_Row( [ "Amount: ", Show_Tool_Tip( textfield( -name => 'Transfer_Quantity', -size => 5 ), "Entire volume assumed if not entered" ) . popup_menu( -name => 'Transfer_Quantity_Units', -values => \@transfer_units ) ] );
    }

    if ( int(@formats) == 1 ) {
        $output .= hidden( -name => 'Target Plate Format', -value => $formats[0] );
    }
    else {
        $dispense->Set_Row( [ 'New Type: ', popup_menu( -name => 'Target Plate Format', -force => 1, -values => [ '', @formats ], default => '' ) ] );
    }

    my ($default_pipeline) = $dbc->Table_find( "Plate", "FK_Pipeline__ID", "WHERE Plate_ID in ($current_plates)" );
    $default_pipeline = &get_FK_info( $dbc, "FK_Pipeline__ID", $default_pipeline );

    my $pipeline_prompt = alDente::Tools->search_list( -dbc => $dbc, -name => 'FK_Pipeline__ID', -default => $default_pipeline, -search => 1, -filter => 1, -breaks => 1, -filter_by_dept => 1 );
    $dispense->Set_Row( [ "Pipeline:", $pipeline_prompt ] );

    $dispense->Set_Row(
        [   checkbox( -name => 'Test Plate Only' ), ''

                #			" (Repeat X ". textfield(-name=>'TransferX',-size=>5,-default=>'1') . ")"
        ]
    );
    $dispense->Set_Row( [ $quadrant_packing, $quadrant_options ] );

    my $options = hidden( -name => 'New Plate Contents', -value => 1 ) . hidden( -name => 'rm', -value => 'Pool' );

    my @content_types = $dbc->get_FK_info_list('FK_Sample_Type__ID');    ## sort $dbc->get_enum_list( 'Plate', 'Plate_Content_Type' );
    ################
    $dispense->Set_Row( [ "Extract: ", popup_menu( -name => 'FK_Sample_Type__ID', -values => [ '-- choose type --', @content_types ], -default => '', -force => 1, -linebreak => 1 ) . '<BR>' ] );

    $dispense->Set_Row( [ 'Comments:', textfield( -name => 'Plate_Comments', -size => 20 ) ] );
    $dispense->Set_Row( [ 'Label:',    textfield( -name => 'Plate_Label',    -size => 10 ) ] );

    $dispense->Set_Row( [ $options, submit( -name => 'rm', -value => 'Extract', -class => "Action" ) ] );
    $output .= $dispense->Printout( 0, -nowrap => 1 );
    $output .= end_form();

    $output .= std_plate_actions( $Plate, $current_plates );

    return $output;
}

##################
# Generate prompt to transfer plate..
#
######################
sub transfer_prompt {
######################
    my %args           = &filter_input( \@_, -args => 'Plate' );
    my $Plate          = $args{-Plate};
    my $id             = $args{-id} || $Plate->{id};                         ## current id
    my $current_plates = $args{-current_plates} || $Plate->{list} || $id;    ## current plates

    my $dbc = $args{-dbc} || $Plate->{dbc};
    my $transfer_types = $args{-transfer_types};

    my @transfer_types;
    if ($transfer_types) {
        @transfer_types = @$transfer_types;
    }
    else {
        @transfer_types = ( 'Transfer', 'Aliquot', 'Pre-Print', 'Decant', 'Extract' );
    }

    alDente::Container::reset_current_plates( $dbc, $current_plates );    ## so that form automatically includes Current Plates element...

    my $output = alDente::Form::start_alDente_form( $dbc, 'transfer_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'transfer_options',undef,$parameters);
    $output .= hidden( -name => 'Barcode',      -value => "Pla$id" );
    $output .= hidden( -name => 'Parent Plate', -value => $current_plates );

    my $form = 'plate';

    $Plate->{type} ||= $Plate->value('Plate.Plate_Type');

    ## tube option to pool current plates
    if ( $current_plates =~ /,/ ) {
        push @transfer_types, 'Pool';
    }

    my @transfer_units = &get_enum_list( $Plate->{dbc}, 'Plate_Prep', 'Transfer_Quantity_Units' );
    $output .= hidden( -name => 'Plate_Type', -value => $Plate->{type} );

    my $def_rack = get_FK_info( $dbc, 'FK_Rack__ID', $Plate->value('Plate.FK_Rack__ID') );    ## convert to readable...
    my $notes = $Plate->value('Plate.Plate_Comments') || '';

    #my $condition;
    #if ( $Plate->{type} =~/Library/i ) { $condition = "WHERE Plate_Format_Style like 'Plate'" }
    #elsif ( $Plate->{type} =~/Tube/i ) { $condition = "WHERE Plate_Format_Style like 'Tube'" }

    my @formats = &get_FK_info( $dbc, 'FK_Plate_Format__ID', -list => 1, -condition => " Plate_Format_Style NOT LIKE 'Array'" );

    ## get the failed/thrown out quadrant/wells
    my $exclude = get_exclude_list( -current_plates => $current_plates, -dbc => $dbc );
    ### options only for Library Plates ###
    my $quadrant_packing;
    my $quadrant_options;
    my $exclude_well;

    my $well_options;
    my $well_list = '';
    my $tray_options;
    if ( $Plate->{type} =~ /Library/i ) {
        ## <CONSTRUCTION> If a user selects quadrants of a Tray the system does not extract only those quadrants, and does it for all the plates on that tray
        if ( $Plate->value('Plate_Format.Wells') =~ /384/ ) {
            $quadrant_packing = checkbox( -name => 'Pack Quadrants' );
            ## get the available quadrants
            my $barcode = $q->param('Barcode');
            my $tray_id;
            if ( $barcode =~ /tra(\d+)/i ) {    # on a tray
                $tray_id = $1;
            }
            my @default_quadrants;
            @default_quadrants = $dbc->Table_find( 'Plate_Tray', 'Plate_Position', "WHERE FK_Tray__ID = $tray_id" ) if $tray_id;

            #my @default_quadrants = ( 'a', 'b', 'c', 'd' );
            if (@$exclude) {
                @default_quadrants = RGmath::minus( \@default_quadrants, $exclude );
            }
            $quadrant_options = "Extract 96-well quadrants:<BR>" . checkbox_group( -name => 'Quadrant', -values => [ 'a', 'b', 'c', 'd' ], -defaults => \@default_quadrants ) . &hspace(10);
            if (@$exclude) {
                $quadrant_options .= "<BR><font color='red'>" . int(@$exclude) . " failed/thrown out quadrant(s) excluded by default</font>";
            }
        }
        else {
            $quadrant_packing = hidden( -name => 'Pack Quadrants', -value => 1 );
        }
    }

    ## use text box for optionally specify wells to include/exclude if not Library Plates
    else {
        my $exclude_list = join ',', @$exclude;
        $well_list .= "<BR>Enter well(s) to be included/excluded in the action: ";
        if ( $dbc->mobile() ) {
            $well_list .= "<BR>";
        }
        $well_list .= Show_Tool_Tip( textfield( -name => 'Well_List', -value => $exclude_list, -size => '20' ), "optionally indicate well(s) to include/exclude. Eg: A01,A02,B01" );
        if (@$exclude) {
            $well_list .=  '<br>' . "<font color='red'>" . int(@$exclude) . " failed/thrown out well(s) excluded by default</font>" .  '<br>';
        }
        $well_options = &vspace(3) . "<B>Include/Exclude:</B>" .  '<br>' . radio_group( -name => 'Include_Exclude_Well', -values => [ 'Include', 'Exclude' ], -default => 'Exclude', -force => 1, -linebreak => 1 ) .  '<br>';

        my @tray_ids = $Plate->{dbc}->Table_find( "Plate_Tray,Plate", "distinct FK_Tray__ID", "WHERE FK_Plate__ID IN ($current_plates) AND FK_Plate__ID = Plate_ID and Plate_Type = 'Tube' ORDER BY FIELD(Plate_ID, $current_plates)" );
        require alDente::Tray_Views;
        my $tray_view = alDente::Tray_Views->new( -dbc => $Plate->{dbc} );

        #$output .= $tray_view->tray_of_tube_plate_set_page( -tray_ref => \@tray_ids );
        for my $tray_id (@tray_ids) {
            $tray_id = alDente::Tray::add_prefix( -id => $tray_id );
            my $tray_table = HTML_Table->new( -title => "Select wells from $tray_id to do actions" );
            my $box = $tray_view->tray_of_tube_box( -tray_id => $tray_id, -resolve => 1 );
            $tray_table->Set_Row( [$box] );
            $tray_options .= create_tree( -tree => { "$tray_id" => $tray_table->Printout(0) }, -print => 0 );
        }

    }

    ### print transfer block ###
    if ( $scanner_mode == 2 ) {
        if ( $Configs{volume_tracking} ) {
            $output .= "<BR>Amount: " . Show_Tool_Tip( textfield( -name => 'Transfer_Quantity', -size => 5 ) . "Entire volume assumed if not entered" ) . popup_menu( -name => 'Transfer_Quantity_Units', -values => \@transfer_units );
        }

        $output .= "<br>New Type: " . popup_menu( -name => 'Target Plate Format', -force => 1, -values => [ '', @formats ], default => '' ) . '<BR>' .

            $output .= "(Repeat X " . textfield( -name => 'TransferX', -size => 5, -default => '1' ) . ")<BR>" . checkbox( -name => 'Test Plate Only', -label => 'Test Plate' ) . "<BR>" . $quadrant_packing . $quadrant_options;
    }

    my $dispense = HTML_Table->new( -padding => 3 );
    $dispense->Set_Title( 'Transfer, Decant or Aliquot', fsize => '-1' );
    $dispense->Toggle_Colour('off');
    if ( $Configs{volume_tracking} ) {
        my @id_list = split ',', $current_plates;
        my $size = @id_list;
        $dispense->Set_Row(
            [   "Amount: ",
                Show_Tool_Tip(
                    SDB::HTML::dynamic_text_element(
                        -name         => 'Transfer_Quantity',
                        -cols         => 20,
                        -rows         => 1,
                        -force        => 1,
                        -max_cols     => 20,
                        -max_rows     => $size,
                        -split_commas => 1
                    ),
                    "Entire volume assumed if not entered"
                    )
                    . popup_menu( -name => 'Transfer_Quantity_Units', -values => \@transfer_units )
            ]
        );
    }
    if ( int(@formats) == 1 ) {
        $output .= hidden( -name => 'Target Plate Format', -value => $formats[0] );
    }
    else {
        $dispense->Set_Row( [ 'Container Type: ', popup_menu( -name => 'Target Plate Format', -force => 1, -values => [ '', @formats ], default => '' ) ] );
        $output .= set_validator( -name => "Target Plate Format", -mandatory => 1 );
        $dispense->Set_Row( [ 'Material Type: ', alDente::Tools::search_list( -dbc => $dbc, -field => 'FK_Sample_Type__ID' ) . set_validator( -name => 'FK_Sample_Type__ID', -required => 1 ) ], -element_id => "FK_Sample_Type__ID_Row" );
    }

    # filter pipelines
    my ($default_pipeline) = $dbc->Table_find( "Plate", "FK_Pipeline__ID", "WHERE Plate_ID in ($current_plates)" );
    $default_pipeline = &get_FK_info( $dbc, "FK_Pipeline__ID", $default_pipeline );
    my $Current_Department = $dbc->config('Target_Department');
    my $group_list         = $dbc->get_local('group_list');
    
    if ($dbc->table_loaded('GrpPipeline')) {
        my @pipelines          = sort @{ alDente::Grp::get_group_pipeline( -dbc => $dbc, -grp => $group_list, -department_name => $Current_Department, -return_format => 'Name' ) };
        my $pipeline_prompt    = $q->popup_menu( -name => 'FK_Pipeline__ID', -values => \@pipelines, -default => $default_pipeline );
        $dispense->Set_Row( [ "Pipeline:", $pipeline_prompt ] );
    }
    
    my $format_field = "Plate_Label";
    $format_field = "Tray_Label" if $tray_options;
    my ($format) = $dbc->Table_find( "DBField", "Field_Format", "WHERE Field_Name = '$format_field'" );
    $dispense->Set_Row(
        [   'Target Label: ',
            Show_Tool_Tip( $q->textfield( -name => 'Target Plate Label', -value => '' ), " optional - applied to target plate/tray (40 characters limit for plate, 10 characters limit for tray)" )
                . set_validator( -name => 'Target Plate Label', -format => $format )
        ]
    );

    $dispense->Set_Row( [ '', checkbox( -name => 'Test Plate Only', -label => 'Test Plate' ) . " (Repeat X " . textfield( -name => 'TransferX', -size => 5, -default => '1' ) . ")" ] );

    if ( $quadrant_packing || $quadrant_options ) { $dispense->Set_Row( [ $quadrant_packing, $quadrant_options ] ) }
    if ( $well_options     || $well_list )        { $dispense->Set_Row( [ $well_options,     $well_list ] ) }
    if ($tray_options) { $dispense->Set_Row( [$tray_options] ) }

    my $cond = "HideVisibilityRadio('FK_Sample_Type__ID_Row','rm','Decant,Aliquot,Transfer,Pre-Print');";

    my $options = radio_group( -name => 'rm', -values => \@transfer_types, -default => 'Extract', -force => 1, -linebreak => 1, -onClick => $cond, -id => 'rm' ) .  '<br>';

    $dispense->Set_Row( [ "<B><U>Instructions</U>:</B>", $options . $q->submit( -name => 'Go', -value => 'Go', -class => "Action", -force => 1, -onClick => 'return validateForm(this.form)' ) ] );
    $output .= $dispense->Printout( 0, -nowrap => 1 );
    $output .=  '<br>';

    $output .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -class => "Action", -force => 1 );
    $output .= end_form();

    return $output;
}

############################
#	Retrieve a list of the failed / thrown out wells or quadrants
#
#	Usage:	my $exclude = get_exclude_list( -dbc => $dbc, -current_plates => '445267,445268,445269,445270' );
#
#	Return:	Array ref of failed/thrown out wells/qudrants
############################
sub get_exclude_list {
############################
    my %args           = &filter_input( \@_, -args => 'current_plates,dbc' );
    my $current_plates = $args{-current_plates};
    my $dbc            = $args{-dbc};

    my $barcode = $q->param('Barcode');
    my $tray_id;
    if ( $barcode =~ /tra(\d+)/i ) {    # on a tray
        $tray_id = $1;
    }
    my @plates = Cast_List( -list => $current_plates, -to => 'array' );
    my @excluded;
    foreach my $plate (@plates) {
        my ($status_info) = $dbc->Table_find( "Plate", "Plate_Status,Failed", "WHERE Plate_ID = $plate" );
        my ( $status, $failed ) = split ',', $status_info;
        if ( $failed =~ /yes/i || $status =~ /thrown out/i || $status =~ /inactive/i ) {
            if ($tray_id) {             # on a tray
                my ($position) = $dbc->Table_find( 'Plate_Tray', 'Plate_Position', "WHERE FK_Tray__ID = $tray_id and FK_Plate__ID = $plate " );
                push @excluded, $position;
            }
        }
    }

    @excluded = Cast_List( -list => \@excluded, -to => 'array', -sort => 1 );

    return \@excluded;
}

###########################
sub std_plate_actions {
###########################
    my $Plate          = shift;
    my $current_plates = shift || $Plate->{list} || $Plate->{id};
    my $dbc            = $Plate->{dbc};

    #    my $parameters     = shift;
    require alDente::Transform_Views;

    ## Form start and end tags
    my $init = alDente::Form::start_alDente_form( $dbc, 'transfer_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'transfer_options',undef,$parameters);
    $init .= hidden( -name => 'Move_Plate_IDs', -value => $current_plates );
    my $end = hidden( -name => "cgi_application", -value => "alDente::Container_App", -force => 1 ) . end_form();

    my $shortcuts_table = HTML_Table->new( -padding => 3 );
    $shortcuts_table->Set_Title( 'Quick Plate Actions', fsize => '-1' );
    $shortcuts_table->Toggle_Colour('off');

    my @shortcuts = ('Throw Away');                                                            ## make this always executable (even if already thrown away)

    my $plate_status = $Plate->value('Plate_Status');
    if ( $plate_status =~ /Active/ ) {
        push @shortcuts, ( 'Thaw', 'On Hold', 'Archive' );
    }
    elsif ( $plate_status != ~/Active/ ) {
        push( @shortcuts, 'Re-Activate' );
    }

    if ( grep( /Admin/i, @{ $dbc->get_local('Access')->{$Current_Department} } ) ) { push @shortcuts, 'Delete' }

    my $shortcuts = b("Available Actions:") .  '<br>' . $q->radio_group( -name => 'rm', -values => \@shortcuts, -force => 1, -linebreak => 1, -mobile => $dbc->mobile() );
    $shortcuts_table->Set_Row( [$shortcuts] );
    $shortcuts_table->Set_Row( [ submit( -name => "Go", -value => "Go", -class => "Action" ) ] );

    my $transform_actions;
    if ( !$dbc->mobile ) {

        #### JACHAN insert
        $transform_actions = HTML_Table->new( -padding => 3 );
        $transform_actions->Set_Title( 'Transform', fsize => '-1' );
        $transform_actions->Toggle_Colour('off');
        $transform_actions->Set_Row( [ alDente::Transform_Views::show_Plate_to_Source_option( -dbc => $dbc, -plate => $current_plates ) ] );


    }

    my $output = $init . $shortcuts_table->Printout( 0, -nowrap => 1 ) . $end;

    if ( !$dbc->mobile ) {
        $output .= vspace() . $transform_actions->Printout( 0, -nowrap => 1 ) . $end ;
    }

    return $output;
}

#################
sub move_link {
#################
    my $Plate          = shift;
    my $current_plates = shift || $Plate->{list} || $Plate->{id};
    my $dbc            = $Plate->dbc();

    my $location_list_ref = alDente::Rack::get_export_locations( -dbc => $dbc );
    my @location_list = @$location_list_ref;


    my $init = alDente::Form::start_alDente_form( $dbc, 'transfer_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'transfer_options',undef,$parameters);

    $init .= hidden( -name => 'Move_Plate_IDs', -value => $current_plates );

    my $end = hidden( -name => "cgi_application", -value => "alDente::Container_App", -force => 1 ) . end_form();

    my $move_form = HTML_Table->new( -padding => 3 );
    $move_form->Toggle_Colour('off');

    $move_form->Set_Row(
        [   $q->submit(
            -name    => 'rm',
            -value   => 'Move Plates',
            -class   => "Action",
            -onClick => "unset_mandatory_validators(this.form);
            document.getElementById('Rack_Validator').setAttribute('mandatory',1);
            return validateForm(this.form)"
            )
            
            . ' to: ',
            $q->textfield(-name=>'FK_Rack__ID', -placeholder=>'-- Scan Location --')
#            alDente::Tools->search_list( -dbc => $dbc, -field => 'Plate.FK_Rack__ID', -default => '', -search => 1, -filter => 1, -breaks => 1, -filter_by_dept => 1, -placeholder => '-- Scan Location --') 
            . set_validator( -name => 'FK_Rack__ID', -mandatory => 1, -id => 'Rack_Validator' )
        ]
    );

    my $export_tip = "Choose from this list only if you desire to track the sample specifically to the target location<BR>Otherwise, simply annotate the comments with an indication of where it is going";

    if ( $dbc->mobile() && ! $dbc->table_loaded('Shipment') ) {
        ## only allow if shipment tracking not enabled ## 

        $move_form->Set_Row(
            [   submit(
                -name    => 'rm',
                -value   => 'Export Plates',
                -class   => "Action",
                -onClick => "unset_mandatory_validators(this.form);
                document.getElementById('Destination_Validator').setAttribute('mandatory',1);
                return validateForm(this.form)"
                )
                . ' to: ',
                Show_Tool_Tip( popup_menu( -name => 'Destination', -value => [ '-- untracked location --', @location_list ], -force => 1 ), $export_tip )
                . hspace(2)
                . "Comments: "
                . Show_Tool_Tip( textfield( -name => 'Export_Comments', -size => 17 ), 'Indicate details of where sample(s) are being sent' )
            ]
        );
    }
    elsif (! $dbc->table_loaded('Shipment')) {
        ## only allow if shipment tracking not enabled ## 
        $move_form->Set_Row(
            [   $init . submit(
                -name    => 'rm',
                -value   => 'Export Plates',
                -class   => "Action",
                -onClick => "unset_mandatory_validators(this.form);
                document.getElementById('Destination_Validator').setAttribute('mandatory',1);
                return validateForm(this.form)"
                )
                . ' to: ',
                Show_Tool_Tip( popup_menu( -name => 'Destination', -value => [ '-- untracked location --', @location_list ], -force => 1 ), $export_tip )
                . hspace(3)
                . &Link_To( $dbc->config('homelink'), 'Add NEW Location', "&AddNewLocation=1", 'red' ),
                "Comments: " . Show_Tool_Tip( textfield( -name => 'Export_Comments', -size => 17 ), 'Indicate details of where sample(s) are being sent' )
            ]
        );
    }

    my $output = $init . $move_form->Printout( 0, -nowrap => 1 ) . $end;
    return $output;
}

######################
sub start_protocol {
#####################
    my %args       = &filter_input( \@_ );
    my $valid_sets = $args{-sets};
    my $plates     = $args{-plates};

    #    my $parameters     = $args{-parameters};  ## parameters to pass into form
    my $type = $args{-type};
    my $dbc  = $args{-dbc};

    my $output = subsection_heading("Protocol Tracking");

    $output .= alDente::Form::start_alDente_form( $dbc, 'start_protocol', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'start_protocol',undef,$parameters);
    $output .= hidden( -name => 'Plate_IDs', -value => "$plates" );
    $output .= choose_set( $valid_sets, $plates );
    $output .= &Set_options( -dbc => $dbc, -set => $valid_sets, -type => $type, -no_form => 1, -plate_list => $plates );
    $output .= end_form();

    return $output;

    &Views::Table_Print(
        content => [ [ &choose_set( $valid_sets, $plates ), &Set_options( -dbc => $dbc, -set => $valid_sets, -type => $type, -no_form => 1, -plate_list => $plates ) ] ],
        print => 0,
        padding => 10,
        bgcolor => '#dddddd'
    );
    $output .= end_form();
    return $output;
}

###################
sub Set_options {
###################
    my %args = &filter_input( \@_, -args => 'set,type' );
    my $dbc              = $args{-dbc} || SDB::Errors::log_deprecated_usage( "Connection", $Connection );
    my $set              = $args{-set};
    my $type             = $args{-type};
    my $default_protocol = $args{-protocol};
    my $no_form          = $args{-no_form};                                                                 ## (only applicable for simple version) do not wrap blocks in forms (in case other parameters are to be included outside of this method)
    my $simple           = $args{-simple} || $no_form;                                                      ## boolean - in this mode only provide standard option to initiate protocols
    my $plate_list       = $args{-plate_list};

    my $last_protocol;
    my $last_protocol_id;
    my $next_protocol;
    my $next_protocol_message;
    my $pipeline_id;
    my $next_pipeline_step;

    my @all_pipelines;
    if ($plate_list) {
        @all_pipelines = $dbc->Table_find( 'Plate', 'FK_Pipeline__ID', "WHERE Plate_ID IN ($plate_list)", -distinct => 1 );

        my @done = $dbc->Table_find( 'Prep,Plate_Prep', 'FK_Lab_Protocol__ID', "where Prep_ID=FK_Prep__ID AND FK_Plate__ID IN ($plate_list) Order by Prep_DateTime" );
        my $num = scalar(@done);
        if ( $num > 0 ) {
            $last_protocol_id = $done[ $num - 1 ];    # last protocol ID
            ($last_protocol) = $dbc->get_FK_info( 'FK_Lab_Protocol__ID', $last_protocol_id );
        }
    }
    elsif ($set) {
        @all_pipelines = $dbc->Table_find( 'Plate_Set,Plate', 'FK_Pipeline__ID', "where FK_Plate__ID = Plate_ID and Plate_Set_Number in ($set)", -distinct => 1 );

        my $all_sets = $set;
        my $parents = alDente::Container_Set::get_parent_sets( -dbc => $dbc, -sets => $set, -recursive => 10, -format => 'list' );
        if ($parents) { $all_sets .= ",$parents" }

        my @done = $dbc->Table_find( 'Prep,Plate_Prep', 'FK_Lab_Protocol__ID', "where Prep_ID=FK_Prep__ID AND FK_Plate_Set__Number in ($all_sets) Order by Prep_DateTime" );
        my $num = scalar(@done);
        if ( $num > 0 ) {
            $last_protocol_id = $done[ $num - 1 ];    # last protocol ID
            ($last_protocol) = $dbc->get_FK_info( 'FK_Lab_Protocol__ID', $last_protocol_id );
        }
    }

    if ( !$default_protocol ) { $default_protocol = $last_protocol }

    ## get the next protocol if applicable
    # get all the pipelines
    my $pipelines_count = scalar(@all_pipelines);

    if ( $pipelines_count == 1 ) {                    # all plates in this set are in the same pipeline
        $pipeline_id = $all_pipelines[0];

        # get the Pipeline_Step_Order of the last protocol
        if ( defined $last_protocol ) {
            my ($last_step_number)
                = $dbc->Table_find( "Pipeline_Step,Object_Class", 'Pipeline_Step_Order', "where FK_Pipeline__ID = $pipeline_id and FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Lab_Protocol' and Object_ID = $last_protocol_id" );
            if ( defined $last_step_number ) {

                # get the next protocol if determined
                my ($next_step_number)
                    = $dbc->Table_find( "Pipeline_Step,Object_Class", 'Pipeline_Step_Order',
                    "where FK_Pipeline__ID = $pipeline_id and FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Lab_Protocol' and Pipeline_Step_Order > $last_step_number order by Pipeline_Step_Order asc limit 1" );
                if ($next_step_number) {
                    my @next = $dbc->Table_find( "Pipeline_Step,Object_Class", "Pipeline_Step_ID,Object_ID",
                        "where FK_Pipeline__ID = $pipeline_id and FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Lab_Protocol' and Pipeline_Step_Order = $next_step_number" );
                    my $next_count = scalar(@next);
                    if ( $next_count == 1 ) {
                        my $next_protocol_id;
                        ( $next_pipeline_step, $next_protocol_id ) = split ',', $next[0];
                        ($next_protocol) = $dbc->get_FK_info( 'FK_Lab_Protocol__ID', $next_protocol_id );
                        $next_protocol_message = $next_protocol;
                    }
                    else {
                        $next_protocol_message = "Can't determine next protocol";
                    }
                }
                else {
                    $next_protocol_message = "End";
                }
            }
            else {
                $next_protocol_message = "Can't determine next protocol";
            }
        }
        else {    # no last step, get protocol from the first step
            my ($next_step_number)
                = $dbc->Table_find( "Pipeline_Step,Object_Class", 'Pipeline_Step_Order', "where FK_Pipeline__ID = $pipeline_id and FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Lab_Protocol' order by Pipeline_Step_Order asc limit 1" );
            if ($next_step_number) {
                my @next = $dbc->Table_find( "Pipeline_Step,Object_Class", "Pipeline_Step_ID,Object_ID",
                    "where FK_Pipeline__ID = $pipeline_id and FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Lab_Protocol' and Pipeline_Step_Order = $next_step_number" );
                my $next_count = scalar(@next);
                if ( $next_count == 1 ) {
                    my $next_protocol_id;
                    ( $next_pipeline_step, $next_protocol_id ) = split ',', $next[0];
                    ($next_protocol) = $dbc->get_FK_info( 'FK_Lab_Protocol__ID', $next_protocol_id );
                    $next_protocol_message = $next_protocol;
                }
                else {
                    $next_protocol_message = "Can't determine next protocol";
                }
            }
            else {
                $next_protocol_message = "End";
            }
        }
    }
    else {
        $next_protocol_message = "Multiple pipelines; Can't determine next protocol";
    }

    if ( $next_protocol && !$default_protocol ) {
        $default_protocol = $next_protocol;
    }

    ### Protocol Tracking Block ###
    my $protocol_block = show_protocol_tracking(
        -dbc                   => $dbc,
        -plate_list            => $plate_list,
        -no_form               => $no_form,
        -set                   => $set,
        -default_protocol      => $default_protocol,
        -pipeline_id           => $pipeline_id,
        -next_pipeline_step    => $next_pipeline_step,
        -last_protocol         => $last_protocol,
        -next_protocol_message => $next_protocol_message
    );

    ### Only show option for starting Protocols in Simple mode (shown as a layer)
    if ($simple) { return $protocol_block }

    ### Move Plates block ###
    my $move_block = alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'move_set', -type => 'plate' );
    $move_block .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );
    $move_block .= subsection_heading("Move Plates in Set");
    $move_block .= submit( -name => 'rm', -value => "Move Plate Set", -class => 'Action' ) . " to: " . hidden( -name => 'Move_Plate_IDs', -value => "$plate_list" );
    if ($scanner_mode) {
        $move_block .= textfield( -name => 'FK_Rack__ID', -size => 10 );
    }
    else {
        my @racks = $dbc->get_FK_info( 'FK_Rack__ID', -condition => "WHERE Rack_Type <> 'Slot' ORDER BY Rack_Alias", -list => 1 );
        $move_block .= alDente::Tools->search_list( -dbc => $dbc, -name => 'FK_Rack__ID', -options => \@racks, -search => 1, -filter => 1, -breaks => 0, -width => 300, -smart_sort => 1 );
    }
    $move_block .= hr . submit( -name => 'rm', -value => 'Throw Out Plates', -class => 'Action' );
    $move_block .= end_form();

    ### Barcoding Block ###
    my $barcoding_block = alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'barcoding_set', -type => 'plate' );
    $barcoding_block .= subsection_heading("Barcode Options");
    $barcoding_block .= submit( -name => 'Barcode_Event', -value => 'Re-Print Plate Barcode', -class => 'Std' ) . &hspace(5);
    $barcoding_block .= hidden( -name => 'Plate_IDs', -value => "$plate_list" );
    my @valid_labels = $dbc->Table_find( "Barcode_Label", "Label_Descriptive_Name", "WHERE Barcode_Label_Type like 'Plate' AND Barcode_Label_Status ='Active'" );

    if ( $dbc->package_active('Tubes_Only') ) {
        @valid_labels = grep( /Tube/i, @valid_labels );
    }
    if ( $#valid_labels > 0 ) {
        unshift( @valid_labels, '--Select--' );
        $barcoding_block .= popup_menu( -name => "Barcode Name", -values => \@valid_labels );
    }
    elsif ( $valid_labels[0] ) {
        $barcoding_block .= hidden( -name => 'Barcode Name', -value => $valid_labels[0] );
        $barcoding_block .= " <i>($valid_labels[0])</i>";
    }
    $barcoding_block .= end_form();

    ### History Block ###
    my $button_value;
    if   ( $type =~ /plate/i ) { $button_value = 'Plate History' }
    else                       { $button_value = 'View Container History' }

    my $history_block;
    unless ($scanner_mode) {
        $history_block .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'Container History', -type => 'plate' );
        $history_block .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );
        $history_block .= hidden( -name => 'Plate IDs', -value => $plate_list );
        $history_block .= subsection_heading("History");

        #hidden(-name=>'Plate_Set',-value=>$set) .
        $history_block .= submit( -name => 'rm', -value => $button_value, -class => "Search" ) . " for " . textfield( -name => 'Generations', -size => 4, -default => '5', -force => 1 ) . " generations" . checkbox( -name => 'Allow Editing' ) . &vspace(5);

        $history_block .= end_form();
    }

    my %layers;
    $layers{'Protocols'} = $protocol_block;    ## simple output block
    $layers{'Move Set'}  = $move_block;
    $layers{'Barcode'}   = $barcoding_block;
    $layers{'History'}   = $history_block;

    my $Plate = new alDente::Container( -id => $plate_list, -dbc => $dbc );
    if ( $Sess->{Tracking}{volume} || $Plate->{Tabs}{Transfer} ) {
        $layers{'Actions'} = transfer_prompt($Plate) . std_plate_actions( $Plate, $plate_list );
    }

    my $output;
    if ($scanner_mode) {
        $output .= $protocol_block . $move_block . $barcoding_block . $history_block;
    }
    else {
        if ( $dbc->mobile() ) {
            $output = define_Layers( -layers => \%layers, -default => 'Protocols', -layer_type => 'mobile' );
        }
        else {
            $output = define_Layers( -layers => \%layers, -default => 'Protocols' );
        }
    }
    return $output;
}

#########################
sub display_record_page {
#########################
    my $self     = shift;
    my %args     = filter_input( \@_ );
    my $id       = $args{-id} || $self->{id};
    my $Plate    = $args{-Plate} || $self->Model( -id => $id );    ## new alDente::Container( -id => $id, -dbc => $dbc );
    my $detailed = $args{-detailed};

    my $dbc = $self->{dbc};
    if ($id) { $dbc->{current_plates} = [ Cast_List( -list => $id, -to => 'ARRAY' ) ] }

    my $plate_id       = $Plate->{id}   || $id;                    ## redundant ... phase out along with $id...
    my $current_plates = $Plate->{list} || $plate_id;

    my $type = $Plate->{type} || $Plate->value('Plate.Plate_Type');
    my $plate_count = scalar( my @array = split( ',', $current_plates ) );
    my $tube_ids = join ',', $dbc->Table_find( "Tube",          "Tube_ID",          " WHERE FK_Plate__ID IN ($current_plates)" );
    my $LP_ids   = join ',', $dbc->Table_find( "Library_Plate", "Library_Plate_ID", " WHERE FK_Plate__ID IN ($current_plates)" );

    my $quadrants = $Plate->value('Library_Plate.Sub_Quadrants');

    my ( $links, $extra_links, $top, $centre, $right );
    my @layers;
    ##########################
    ##### Protocol Layer #####
    ##########################

    ## show set or options for sets at left, with options to continue protocol to the right ##
    my $default = '';
    my $container_options;    ## deprecate...

    ## Protocol Options ##
    my ( $protocol_layer, $save_set_options ) = $self->_protocol_layer( $Plate, $type );
    if ($protocol_layer) { push @layers, $protocol_layer }
    
    my $move_link = $self->move_link($current_plates);
    
    my ($middle, $mobile_summary);       ## variable to store save_set_options and notes on plate for mobile version (to store in tab)
    if ( $dbc->mobile() ) {
        $mobile_summary = $save_set_options;
        $mobile_summary .= $self->_get_Notes($Plate);
    }
    else {
        $middle = '<hr>' . $save_set_options;
        $middle .= $self->_get_Notes($Plate);
    }

    ##  QC ##
    my $qc_options = $self->_qc_options($Plate);
    push @layers, { label => 'QC', content => $qc_options };

    if ( $Sess->{Tracking}{volume} || $Plate->{Tabs}{Transfer} ) {
        push @layers, { label => 'Actions', content => $self->_actions($Plate) };
    }

    if ( !$dbc->mobile() ) {
        ## Desktop mode only ##
        push @layers, { label => 'Extract',   content => extract_prompt($Plate) } if $Plate->{Tabs}{Extract};
        push @layers, { label => 'Summaries', content => search_options($Plate) } if $Plate->{Tabs}{Summaries};

        ## different format for add_layers... fix...
        if ( $dbc->table_loaded('Run') ) {
            require alDente::Run_Views;
            my @parents = split ',', alDente::Container::get_Children( -dbc => $dbc, -id => $current_plates, -format => 'list' );
            push @layers, { label => 'Data', content => &alDente::Run_Views::show_run_data( $dbc, -plate_id => [ @parents, $id ], -title => 'Experimental Data', -quiet => 1 ) };
        }

        if ( $self->objects() > 1 ) { push @layers, { label => 'DB Record', content => display_plate_contents( -Plate => $Plate, -id => $id ) } }    ## add DB record info for multiple records

        if ( $type eq 'Library_Plate' ) { push @layers, { label => 'Misc', content => upload_aliases($Plate) } if $Plate->{Tabs}{Links} }
    }

    my $group_options;
    if ( $current_plates =~ /,/ ) { $group_options .= $self->_multiple_plate_links($Plate) }

    my $default_layer = 'Start Protocol';
    if ( $self->objects() > 1 ) {
        if ( $dbc->mobile() ) {
            if ($links) { $mobile_summary .= '<HR>' . $links }                                                                                       ## include links in layers section for multi-record page ##
            $top = show_trays( $dbc, $current_plates );
        }
        else {
            if ($links) { $middle .= '<HR>' . $links }                                                                                               ## include links in layers section for multi-record page ##
            $top = show_trays( $dbc, $current_plates );
        }
    }
    elsif ( $dbc->config('screen_mode') eq 'desktop' ) {        
        if ($links) { $centre = $links }                                                                                                             ## include links in layers section for multi-record page ##
        $right = view_Ancestry( -dbc => $dbc, -view => 1, -id => $plate_id, -return_html => 1, -simple => 1 );                                       ## $simple );
    }

    push @layers, $self->_extra_layers($Plate);
    if ( $dbc->mobile() ) {
        return $self->SUPER::display_record_page(
            -top        => $top,
            -centre     => $centre,                                                                                                                  ## only defined for single record home pages
            -right      => $right,                                                                                                                   ## only defined for single record home pages
            -mobile     => $mobile_summary,
            -layers     => \@layers,
            -layer_type => 'mobile',
            -visibility => { 'Samples' => ['desktop'] },
            -label_span => 6,
            -open_layer => $default_layer,
        );
    }
    else {
        return $self->SUPER::display_record_page(
            -top        => $top,
            -centre     => $centre,                                                                                                                  ## only defined for single record home pages
            -right      => $right,                                                                                                                   ## only defined for single record home pages
            -middle     => $middle,
            -layers     => \@layers,
            -visibility => { 'Samples' => ['desktop'] },
            -open_layer => $default_layer,
            -detailed   => $detailed,
            -group_options=> $group_options,
        );
    }
}

## phased out - standardized for all barcoded items ... ##
#######################
sub reprint_plate_option {
#######################
    my $self = shift;
    my %args = filter_input( \@_ );
    my $dbc  = $args{-dbc};
    my $id   = $args{-id};

    my @valid_labels = $dbc->Table_find( "Barcode_Label", "Label_Descriptive_Name", "WHERE Barcode_Label_Type like 'plate' AND Barcode_Label_Status='Active'" );
    unshift( @valid_labels, '--Select--' );

    #Plate_Type

    my $page;
    if ($id) {
        my ($type) = $dbc->Table_find( "Plate", "Plate_Type", "WHERE Plate_ID IN ($id)" );
        my @tray_ids = $dbc->Table_find( "Plate_Tray,Plate", "distinct FK_Tray__ID", "WHERE FK_Plate__ID IN ($id) AND FK_Plate__ID = Plate_ID and Plate_Type = 'Tube'" );
        my $tray_ids = join ',', @tray_ids;
        $page
            = alDente::Form::start_alDente_form( $dbc, 'reprint' )
            . $q->submit( -name => 'rm', -value => "Re-Print Plate Labels", -class => "Std" )
            . $q->hidden( -name => "Type",            -value => $type,                    -force => 1 )
            . $q->hidden( -name => "Plate IDs",       -value => $id,                      -force => 1 )
            . $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 )
            . $q->popup_menu( -name => "Barcode Name", -values => \@valid_labels )
            . $q->end_form();
        if ($tray_ids) {
            $page
                .= alDente::Form::start_alDente_form( $dbc, 'reprint_tray' )
                . vspace()
                . $q->submit( -name => 'rm', -value => "Re-Print Tray Labels", -class => "Std" )
                . $q->hidden( -name => "Type",            -value => $type,                    -force => 1 )
                . $q->hidden( -name => "Plate IDs",       -value => $id,                      -force => 1 )
                . $q->hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 )
                . $q->popup_menu( -name => "Barcode Name", -values => \@valid_labels )
                . $q->end_form();
        }

    }
    return $page;
}

#
# Return: Folder containing Notes if applicable ...
##################
sub _get_Notes {
##################
    my $self  = shift;
    my $Plate = shift;

    my $id = shift || $Plate->{id};
    my $current_plates = shift || $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    ### show notes (plate comments for all parent plates) below ancestry ###
    my @note_list = $Plate->get_Notes( -dbc => $dbc, -plate_id => $current_plates, -output => 'list' );
    my $notes = Cast_List( -list => \@note_list, -to => 'UL' );

    if ( $notes && $dbc->config('screen_mode') eq 'desktop' ) {
        return create_tree( -tree => { 'Notes' => $notes }, -print => 0 );
    }

    return;
}

#####################
sub _protocol_layer {
#####################
    my $self  = shift;
    my $Plate = shift;
    my $type  = shift;

    my $id = $Plate->{id};
    my $current_plates = $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    if ( !$dbc->config('protocol_tracking') ) {return}

    ### list sets containing this plate ###
    my $plate_count = scalar( my @array = split( ',', $current_plates ) );

    ## Sets that match exactly the current list of plates ##
    my $exact_sets = join ',',
        $dbc->Table_find( 'Plate_Set, Plate_Set AS entire_set',
        'Plate_Set.Plate_Set_Number', " WHERE Plate_Set.FK_Plate__ID IN ($current_plates) AND Plate_Set.Plate_Set_Number=entire_set.Plate_SEt_Number GROUP BY entire_set.Plate_Set_Number having SQRT(count(entire_set.FK_Plate__ID))=$plate_count" );

    ## Check the order of the current list of plates against plate_set order
    my %not_exact_order_sets;
    %not_exact_order_sets = $dbc->Table_retrieve(
        'Plate_Set',
        [ 'Plate_Set_Number', 'Group_Concat(FK_Plate__ID Order By Plate_Set_ID) AS plate_list' ],
        "WHERE Plate_Set_Number IN ($exact_sets) GROUP BY Plate_Set_Number having Group_Concat(FK_Plate__ID Order By Plate_Set_ID) != '$current_plates'"
    ) if $exact_sets;

    my $index = 0;
    while ( defined $not_exact_order_sets{Plate_Set_Number}[$index] ) {
        my $wrong_order_set        = $not_exact_order_sets{Plate_Set_Number}[$index];
        my $wrong_order_plate_list = $not_exact_order_sets{plate_list}[$index];
        $dbc->session->warning("Plate set $wrong_order_set has the same plates but in different order ($wrong_order_plate_list instead of $current_plates)");
        $exact_sets =~ s/\,?$wrong_order_set\,?//;    # remove from exact_set since order is different
        $index++;
    }

    ## possible sets including any of the current_plates ##
    my $possible_sets = join ',', $dbc->Table_find( 'Plate_Set', 'Plate_Set.Plate_Set_Number', " WHERE Plate_Set.FK_Plate__ID IN ($current_plates) ", -distinct => 1 );

    my $set_link = "(Not in any container sets)" . &vspace(10);

    ## Generate Protocol Layer ##
    my $layer = {
        label   => 'Start Protocol',
        content => &start_protocol(
            -dbc    => $dbc,
            -sets   => $exact_sets,
            -type   => $type,
            -plates => $current_plates
        )
    };

    ## Generate Container Options block ##
    my $button_name;

    if    ( $type =~ /plate/i ) { $button_name = 'Save Plate Set' }
    elsif ( $type =~ /array/i ) { $button_name = 'Save Array Set' }
    else                        { $button_name = 'Save Tube Set' }

    ## Generate buttons allowing users to Save / Recover Plate Sets for Protocols ##
    my $save_set_options = alDente::Form::start_alDente_form( $dbc, 'container_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'container_options',undef,\%Parameters);
    $save_set_options .= hidden( -name => 'Plate_ID',        -value => $current_plates );
    $save_set_options .= hidden( -name => 'Plate_IDs',       -value => $current_plates );
    $save_set_options .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );

    if ($possible_sets) {
        if ( $dbc->mobile() ) {
            $save_set_options .= $BS->row(
                [   "<B>Set(s)</B>:<BR> $exact_sets ($possible_sets overlap) ",
                    $q->submit( -name => 'rm', -value => $button_name, -class => "Action", -mobile => $dbc->mobile() ),
                    $q->hidden( -name => 'Possible_Sets', -value => $possible_sets ) . $q->submit( -name => 'rm', -value => 'Recover Set', -class => "Std", -mobile => $dbc->mobile() )
                ],
                -span   => [ 4, 4, 4 ],
                -size   => 'xs',
                -mobile => 1
            );
        }
        else {
            $save_set_options .= $BS->row(
                [   "<B>Set(s)</B>: $exact_sets ($possible_sets overlap) ",
                    $q->submit( -name => 'rm', -value => $button_name, -class => "Action", -mobile => $dbc->mobile() ),
                    $q->hidden( -name => 'Possible_Sets', -value => $possible_sets ) . $q->submit( -name => 'rm', -value => 'Recover Set', -class => "Std", -mobile => $dbc->mobile() )
                ],
                -span => [ 4, 4, 4 ]
            );
        }
    }
    else {
        $save_set_options .= $q->submit( -name => 'rm', -value => $button_name, -class => "Action", -mobile => $dbc->mobile() );
    }

    $save_set_options .= end_form();

    return ( $layer, $save_set_options );
}

#
# Standard Links for plate records
#
#
# Return block containing links
############################
sub _actions {
############################
    my $self  = shift;
    my $Plate = shift;

    my $id = shift || $Plate->{id};
    my $current_plates = shift || $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    my $actions;
    $actions .= transfer_prompt($Plate);
    $actions .= std_plate_actions( $Plate, $current_plates );

    return $actions;
}

#
# Links generated when multiple plates are scanned
#
#
############################
sub _multiple_plate_links {
############################
    my $self  = shift;
    my $Plate = shift;

    my $id = shift || $Plate->{id};
    my $current_plates = shift || $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    my $links;

    ## if multiple plates scanned, provide link directly to Pool / ReArray Page
    ## if tray ids available, use tray ids
    my @tray_ids = $Plate->{dbc}->Table_find( "Plate_Tray,Plate", "distinct FK_Tray__ID", "WHERE FK_Plate__ID IN ($current_plates) AND FK_Plate__ID = Plate_ID and Plate_Type = 'Tube'" );
    my $trays = Cast_List( -list => \@tray_ids, -to => 'string' );
    my $tray;
    for my $tray_id (@tray_ids) {
        $tray_id = alDente::Tray::add_prefix( -id => $tray_id );
        $tray .= $tray_id;
    }
    if ($tray) {
        my $prefix = $dbc->barcode_prefix('Plate');
        #check missing pla, if there is add them
        my ($plas) = $dbc->Table_find( "Plate LEFT JOIN Plate_Tray ON Plate_ID = FK_Plate__ID AND FK_Tray__ID IN ($trays)", "GROUP_CONCAT(CONCAT('$prefix',Plate_ID))", "WHERE Plate_ID IN ($current_plates) AND FK_Plate__ID IS NULL" );
        $tray = $plas . $tray if $plas;
    }
    my $list = $current_plates;
    $list = $tray if $tray;
    if ( !$dbc->mobile() ) {
        $links .= Link_To( $dbc->config('homelink'), "Pool / Rearray Above Plates/Tubes to Existing Library", "&cgi_application=alDente::ReArray_App&rm=ReArray/Pool Wells&ReArrayed From=$list&ReArray Well Nomenclature=Tube" );
        $links .= "<BR>\n";
        $links .= Link_To( $dbc->config('homelink'), "Pool / Rearray Above Plates/Tubes to Hybrid Library",   "&cgi_application=alDente::ReArray_App&rm=ReArray/Pool Wells&ReArrayed From=$list&ReArray Well Nomenclature=Tube&Hybrid=1" );
    }
    else {
        $links .= Link_To(
            $dbc->config('homelink'),
            "<button type='button' class='btn btn-lg btn-primary'>Pool / Rearray Above Plates/Tubes to Existing Library</button>",
            "&cgi_application=alDente::ReArray_App&rm=ReArray/Pool Wells&ReArrayed From=$list&ReArray Well Nomenclature=Tube"
        );
        $links .= "<BR><BR>\n";
        $links .= Link_To(
            $dbc->config('homelink'),
            "<button type='button' class='btn btn-lg btn-primary'>Pool / Rearray Above Plates/Tubes to Hybrid Library</button>",
            "&cgi_application=alDente::ReArray_App&rm=ReArray/Pool Wells&ReArrayed From=$list&ReArray Well Nomenclature=Tube&Hybrid=1"
        );
    }

    return $links;
}

#################
sub _qc_options {
#################
    my $self  = shift;
    my $Plate = shift;

    my $id = shift || $Plate->{id};
    my $current_plates = shift || $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    ## the variables below should be phased out unless there is a reason why they may be different (?)  ... just copied over for now

    my $qc_options;
    if ( $dbc->config('QC_tracking') ) {
        my $qc_status = &alDente::QA::check_for_qc( -dbc => $dbc, -ids => $current_plates, -table => "Plate" );
        my $qc_prompt = &alDente::QA_Views::get_qc_prompt( -dbc => $dbc, -qc_status => $qc_status );
        $qc_options .= $qc_prompt . &hspace(10) . '<P></P>';
        $qc_options .= alDente::QA_Views::QC_Control_Plate_button();

        require alDente::QA_Views;
        $qc_options .= alDente::QA_Views::qc_status_view( -table => 'Plate', -id => $current_plates, -dbc => $dbc );

    }
    $qc_options .=  '<br>';

    ### Plate_App options ###
    my $output = alDente::Form::start_alDente_form( $dbc, 'qc_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'container_options',undef,\%Parameters);
    $output .= hidden( -name => 'Plate_ID',        -value => $id );
    $output .= hidden( -name => 'Plate_IDs',       -value => $current_plates );
    $output .= hidden( -name => 'cgi_application', -value => 'alDente::QA_App', -force => 1 );
    $output .= $qc_options;
    $output .= end_form();

    return $output;
}

#
# Add additional layers (previously generated through LP_button_options and Tube_button_options, but they appear to do similar things... )
#
##
#################
sub _extra_layers {
#################
    my $self  = shift;
    my %args  = filter_input( \@_, -args => 'Plate' );
    my $Plate = $args{-Plate};

    my $id = shift || $Plate->{id};
    my $current_plates = shift || $Plate->{list} || $Plate->{id};

    my $dbc = $self->{dbc};

    my @layers;
    if ( $dbc->config('screen_mode') eq 'desktop' ) {

        if ($Plate->value('Plate.Plate_Type') eq 'Library_Plate') {
            ## Add Wells Layers if applicable ##
            my $well_options = well_options( $Plate, -dbc => $dbc );
            push @layers, { label => 'Wells', content => $well_options };
        }
        
        ## Add Links Layer ##
        my $links;
        if ( $dbc->admin_access() && $dbc->table_loaded('Transposon') ) { $links .= transposon_options( $Plate, -dbc => $dbc ) . hr }

        my $size      = $Plate->value('Plate.Plate_Size');
        my $quadrants = $Plate->value('Library_Plate.Sub_Quadrants');

        if ( $dbc->table_loaded('Clone_Source') ) {
            # check if the plate has already been linked using Clone_Source. If it has, then disallow this link
            my @clone_source_names = $dbc->Table_find( "Clone_Source", "distinct concat(Source_Collection,' ',Source_Plate)", "WHERE FK_Plate__ID IN ($id)" );
            if ( int(@clone_source_names) == 0 ) {
                $links .= '<span class=small>' . &Link_To( $dbc->config('homelink'), "Link Plate to Sample Source", "&DBForm=1&Plate_ID=$id&DBAppend=Clone_Source", $Settings{LINK_COLOUR} ) . '</span><hr>';
            }
            else {
                my $clone_plate_name = $clone_source_names[0];
                $links .= "<span class=small>Plate linked to $clone_plate_name</span><hr>";
            }
        }

        ## Add links to other objects ##
        my $misc_table = HTML_Table->new();
        $misc_table->Set_Class('small');
        $misc_table->Set_Width('100%');
        $misc_table->Toggle_Colour('off');
        $misc_table->Set_Title( 'Link to other Objects', fsize => '-1' );

        if ( $dbc->package_active('Fingerprinting') ) {
            $misc_table->Set_Row(
                [   '<B>Gel Run:</B>',
                    &Link_To( -link_url => "$dbc->config('homelink')", -label => "Load Gel", -param => "&GelRun_Request=1&Load+GelRun=1&FK_Plate__ID=$current_plates", -colour => $Settings{LINK_COLOUR}, -method => 'GET', -form_name => "plate" )
                ]
            );
            $misc_table->Set_sub_header( hr() );
        }

        # for tubes only - use plate as Library Submission ligation
        if ( $dbc->package_active('Sequencing') ) {
            if ( ( $Plate->{type} =~ /tube/i ) && ( $current_plates !~ /,/ ) ) {
                $misc_table->Set_Row(
                    [   &Link_To(
                            -link_url  => "$dbc->config('homelink')",
                            -label     => "Submit this tube as new Sequencing Library",
                            -param     => "&Create New Library=1&Library_Type=Sequencing&Target=Submission&Scanned ID=pla$current_plates",
                            -colour    => $Settings{LINK_COLOUR},
                            -method    => 'GET',
                            -form_name => "plate"
                        )
                    ]
                );
            }
        }

        if ($misc_table->{rows}) { $links .= $misc_table->Printout(0) }

        if ($links) { push @layers, { label => "Links " . $BS->icon('external-link'), content => $links } }

    }
    return @layers;
}

#############################
sub display_rearray_options {
#############################
    my $current_plates = shift;
    ## Rearray to new plate

    ## Rearray to existing plate

    ## Pick the rearray type
    my $rearray_option_table = HTML_Table->new( -class => 'small' );

    my $rearray_options = radio_group( -name => 'Rearray_Option', -values => [ 'New Plate', 'Existing Plate' ] );

    my $submit_rearray = Show_Tool_Tip( submit( -name => "Display_ReArray_Wells", -value => "Pick Wells to ReArray", -class => "Std" ),
        "ReArray: move selected wells to chosen target wells on a new plate.\nThe new plate will have a new plate number and the plate format and size can be different than the parent plate." );
    my $existing_plate_scan = Show_Tool_Tip( textfield( -name => 'Existing_Plate', -value => '', -force => 1 ), "Scan existing rearray plate" );
    my $source_plates = hidden( -name => 'source_plates', -value => $current_plates );

    $rearray_option_table->Set_Row( [ $submit_rearray . hspace(20) . $rearray_options . hspace(10) . $existing_plate_scan . $source_plates ] );

    my $submit_transfer = Show_Tool_Tip( submit( -name => "Display_Transfer_Wells", -value => "Pick Wells to Transfer to New Plate", -class => "Action" ),
        "Transfer: move selected wells to the same well positions (e.g. A03 to A03) on a new plate.\nThe new plate will have the same plate number, format and size as the parent plate." );
    $rearray_option_table->Set_Row( [$submit_transfer] );

    return $rearray_option_table->Printout(0);
}

####################
sub well_options {
####################
    my %args           = filter_input( \@_, -args => 'Plate' );
    my $Plate          = $args{-Plate};
    my $id             = $args{-id} || $Plate->{id};                         ## current id
    my $current_plates = $args{-current_plates} || $Plate->{list} || $id;    ## current plates
    my $dbc            = $args{-dbc} || $Plate->{dbc};
    require alDente::Tray_Views;

    #my $parameters     = shift;  ## parameters to pass into form
    my $output = alDente::Form::start_alDente_form( $dbc, 'well_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'well_options',undef,$parameters);
    $output .= hidden( -name => 'Barcode',      -value => "Pla$id" );
    $output .= hidden( -name => 'Parent Plate', -value => $current_plates );

    my $library_plate_table = HTML_Table->new();
    $library_plate_table->Set_Title( 'Plate Options', fsize => '-1' );
    $library_plate_table->Set_Class('small');
    $library_plate_table->Set_Width('100%');
    $library_plate_table->Toggle_Colour('off');

    my $proceed_btn = submit( -name => 'Select_Wells', value => 'Proceed to:', -class => "Std" ) . hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );

    $library_plate_table->Set_Row( [ '',           radio_group( -name => 'rm', -value => ['Set No Grows'],          -force => 1 ), radio_group( -name => 'rm', -value => ['Set Slow Grows'],  -force => 1 ) ] );
    $library_plate_table->Set_Row( [ $proceed_btn, radio_group( -name => 'rm', -value => ['Set Unused Wells'],      -force => 1 ), radio_group( -name => 'rm', -value => ['Set Empty Wells'], -force => 1 ) ] );
    $library_plate_table->Set_Row( [ '',           radio_group( -name => 'rm', -value => ['Set Problematic Wells'], -force => 1 ), radio_group( -name => 'rm', -value => ['Set Test Status'], -force => 1 ) ] );
    $library_plate_table->Set_Row( [ '',           radio_group( -name => 'rm', -value => ['View Plate'],            -force => 1 ), radio_group( -name => 'rm', -value => ['Fail Wells'],      -force => 1 ) ] );

    #$library_plate_table->Set_Row( [ display_rearray_options() . hidden( -name => 'Parse_ReArray_Wells', -value => 1, -force => 1 ) ] );
    $output .= $library_plate_table->Printout(0);
    $output .= end_form();

    $output .= alDente::Form::start_alDente_form( $dbc, 'well_options_rearray', -type => 'Plate' );
    $output .= display_rearray_options($current_plates) . hidden( -name => 'Parse_ReArray_Wells', -value => 1, -force => 1 );
    $output .= end_form();

    my $quadrants = $Plate->value('Library_Plate.Sub_Quadrants');
    my $size      = $Plate->value('Plate.Plate_Size');

    if ( $size =~ /384/ ) {
        $output .= alDente::Form::start_alDente_form( $dbc, 'Plate', -type => 'Plate' );
        my $well_plate = $current_plates || $id;
        $output
            .= hidden( -name => '384 Well Plate', -value => $well_plate )
            . submit( -name => 'Re-Set Available Quadrants', -class => "Action" ) . " to: "
            . textfield( -name => 'Sub Quadrants', -size => 10, -default => $quadrants, -force => 1 )
            . hidden( -name => 'Plate_Type', -value => $Plate->{type} )
            . end_form();
    }
    $output .= br . show_well_conversion_tool( -dbc => $dbc, -wrap => 1 ) . br;
    my @tray_ids = $Plate->{dbc}->Table_find( "Plate_Tray,Plate", "distinct FK_Tray__ID", "WHERE FK_Plate__ID IN ($current_plates) AND FK_Plate__ID = Plate_ID and Plate_Type = 'Tube' ORDER BY FIELD(Plate_ID, $current_plates)" );
    my $tray_view = alDente::Tray_Views->new( -dbc => $Plate->{dbc} );

    if ( int @tray_ids == 1 ) {
        $output .= $tray_view->prompt_to_confirm_Contents( -tray_id => $tray_ids[0] );
    }

    $output .= $tray_view->tray_of_tube_plate_set_page( -tray_ref => \@tray_ids );

    $output .= create_tree( -tree => { 'Set QC Status' => $tray_view->tray_of_tube_qc_status_page( -tray_ref => \@tray_ids, -attribute => 'Sample_QC_Status' ) }, -print => 0 );
    $output .= create_tree( -tree => { 'Set Intermediate QC Status' => $tray_view->tray_of_tube_qc_status_page( -tray_ref => \@tray_ids, -attribute => 'Intermediate_QC_Status' ) }, -print => 0 );
    return $output;
}

#########################
sub transposon_options {
#########################
    my %args           = filter_input( \@_, -args => 'Plate' );
    my $Plate          = $args{-Plate};
    my $id             = $args{-id} || $Plate->{id};                         ## current id
    my $current_plates = $args{-current_plates} || $Plate->{list} || $id;    ## current plates
    my $dbc            = $args{-dbc};

    my $output = alDente::Form::start_alDente_form( $dbc, 'transposon_options', -type => 'Plate' );    ## alDente::Form::start_alDente_form($dbc,'transposon_options',undef,$parameters);
    $output .= hidden( -name => 'Barcode',      -value => "Pla$id" );
    $output .= hidden( -name => 'Parent Plate', -value => $current_plates );

    my $transposon_table = new HTML_Table();
    $transposon_table->Set_Width('100%');
    $transposon_table->Toggle_Colour('off');
    $transposon_table->Set_Title("Transposon Pooling for Plate/s: ($current_plates)");
    $transposon_table->Set_Row( [ &submit( -name => "Prompt Create Transposon Pool", -label => "Combine Current Plates into Transposon Pool", -class => "Action" ), checkbox( -name => 'New Transposon Library', -checked => 'on' ) ] );
    $output .= $transposon_table->Printout(0);
    $output .= end_form();
    return $output;
}

####################################
# Convert the source wells to 96 or
# 384 well format
#
####################################
sub convert_wells {
    my $Plate = shift;
    my %args  = @_;

    my $source_wells  = $args{-source_wells};
    my $input_format  = $args{-input_format} || 'Mixed';
    my $output_format = $args{-output_format} || 'List';
    my $dbc           = $args{-dbc} || SDB::Errors::log_deprecated_usage( "Connection", $Connection );

    unless ($source_wells) {
        my $condition;
        if ( $input_format =~ /96([abcd])/ ) {
            my $quad = $1;
            $condition = "WHERE Quadrant like '$quad'";
        }
        $source_wells = &Table_retrieve_display( $dbc, 'Well_Lookup', [ "Plate_96 as 96_well_format", "Quadrant", "Plate_384 as 384_well_format" ], $condition );
        return;
    }

    $source_wells = Cast_List( -list => $source_wells, -to => 'arrayref' );

    my @before = &alDente::Well::Format_Wells( -wells => $source_wells, -input_format => $input_format );
    my @after  = &alDente::Well::Convert_Wells( -dbc  => $dbc,          -wells        => \@before );

    my $table = HTML_Table->new();
    $table->Set_Title('Well Conversion Results');

    if ( $output_format =~ /list/i ) {
        $table->Set_Row( [ "Before conversion:", join( ",", @before ) ] );
        $table->Set_Row( [ "After conversion:",  join( ",", @after ) ] );
    }
    else {
        $table->Set_Headers( [ 'Before Conversion', 'After Conversion' ] );
        foreach my $index ( 0 .. $#before ) {
            $table->Set_Row( [ $before[$index], $after[$index] ] );
        }
    }
    $table->Printout();

    print vspace(10);
    print show_well_conversion_tool( -dbc => $dbc, -wrap => 1 );
}

####################################
# Shows the well conversion tool to
# to converts well from 96-well format
# to 384-well format and vice versa
#
####################################
sub show_well_conversion_tool {
####################################
    my %args = @_;

    my $dbc = $args{-dbc};
    my $wrap = $args{-wrap} || 0;    ### Whether to wrap the form with start form and end form

    my $output;

    #Message("Note: This tool accepts a comma-delimited list of wells to convert from and will return a comma-delimited list of converted wells.");
    #Message("- If the well provided includes a quadrant, then it is assumed to be 96-well format. Otherwise, it is assumed to be 384-well format.");
    #Message("- To convert wells from 96-well to 384-well, include the quadrant using the format 'H12d' for well 'H12' of the 'd' quadrants.");
    #Message("- To convert wells from 384-well to 96-well, simply input the well without any quadrant desigination.");
    #print br;

    if ($wrap) {
        $output .= alDente::Form::start_alDente_form( $dbc, 'Well_Conversion_Tool', -type => 'Plate' );
    }
    my $checkbox
        = '<SPAN class=small>'
        . hspace(25)
        . checkbox( -name => 'List Mode' )
        . ' (eg. D5-H12)'
        . hspace(2)
        . checkbox( -name => 'Show Well ID', -value => 'Show Well Numbers' )
        . hspace(2)
        . submit( -name => "Well Colour Map", -class => "Search" )
        . '</SPAN>';

    my $table = HTML_Table->new();
    $table->Set_Title( '<FONT size=-1><Span class=medium>' . 'Well Conversion Tool' . '</SPAN></FONT>' . $checkbox );
    $table->Set_Width('100%');
    $table->Toggle_Colour('off');
    $table->Set_Row(
        [   'Wells: ',
            Show_Tool_Tip(
                textfield( -name => 'Source_Wells', -size => 30 ),
                "If the well provided includes a quadrant, then it is assumed to be 96\-well format. Otherwise, it is assumed to be 384\-well format. To include quadrant, use the format \\H12d\\ for well \\H12\\ of the \\d\\ quadrants"
            ),

            Show_Tool_Tip( "<input type='radio' name='Input_Format' value='Mixed' checked/>", "Eg. A02,A02c - A01a,B03" ) 
                . "Mixed "
                . Show_Tool_Tip( "<input type='radio' name='Input_Format' value='384'/>", "Eg. A04 - A02b" )
                . "384->96 "
                . &vspace
                . "96->384: "
                . Show_Tool_Tip( "<input type='radio' name='Input_Format' value='96a'/>a ", "Eg: A02 - A03" )
                . Show_Tool_Tip( "<input type='radio' name='Input_Format' value='96b'/>b ", "Eg: A02 - A04" )
                . Show_Tool_Tip( "<input type='radio' name='Input_Format' value='96c'/>c ", "Eg: A02 - B03" )
                . Show_Tool_Tip( "<input type='radio' name='Input_Format' value='96d'/>d",  "Eg: A02 - B04" ),

            submit( -name => 'Convert_Wells', -value => 'Convert to', -class => "Std" ),
            radio_group( -name => 'Convert_Format', -values => [ 'list', 'table' ], -linebreak => 1 )
        ]
    );
    $output .= $table->Printout(0);

    $output .= "</form>" if ($wrap);

    return $output;
}

########################################################
#
#
#
##########################
sub show_Detailed_Ancestry {
##########################
    my %args     = &filter_input( \@_ );
    my $dbc      = $args{-dbc};
    my $plate_id = $args{-id};
    my $page;
    my $Plate = new alDente::Container( -id => $plate_id, -dbc => $dbc );
    $page .= fail_toolbox( -dbc => $dbc, -Plate => $Plate, -plates => $plate_id, -tree => 'Ancestry Details' );    #
    $page .= inherit_plate_attributes_view( -plate_id => $plate_id, -dbc => $dbc );
    return $page;
}

####################
sub object_label {
####################
    my $self = shift;
    my %args = @_;
    my $id   = $args{-id} || $args{-plate_id} || $self->{id};

    $args{-dbc} = $self->{dbc};
    $args{-id}  = $id;
    return foreign_label(%args);
}

########################################
# Generates a small label describing the container
#
# Options:
#  table type - returns small colour coded table cell
#  tooltip type - returns link to plate with details showing up as tooltip
#  details type - returns details of plate in text string (can be used for external tooltips) #
#
# Returns a string containing info about a container
####################
sub foreign_label {
####################
    my %args         = &filter_input( \@_, -args => 'dbc,plate_id,include', -mandatory => 'dbc|self', -self => 'alDente::Container_Views' );
    my $self         = $args{-self};
    my $dbc          = $args{-dbc} || SDB::Errors::log_deprecated_usage( "Connection", $Connection );
    my $plate_id     = $args{-plate_id} || $args{-id} || $self->{id};
    my $include      = $args{-include};                                                                                                        ## indicate record id to include. (eg current plate) - WHY
    my $type         = $args{-type} || 'table';                                                                                                ## eg 'tooltip', 'table', or 'details'
    my $verbose      = $args{-verbose};                                                                                                        ## more details than the concise label.
    my $border       = defined $args{-border} ? $args{-border} : 1;
    my $colour       = $args{-colour} || '#ccffcc';
    my $text_colour  = $args{-text_colour} || 'black';
    my $highlight    = $args{-highlight};
    my $tip          = $args{-tip};
    my $all_plates   = $args{-all_plates} || $current_plates;
    my $parent_plate = $plate_id;
    my $link_label   = $args{-label};
    my $class        = $args{-class};
    my $debug        = $args{-debug};                                                                                                          ## optionally override label to appear in link...

    if ( $highlight =~ /\b$plate_id\b/ ) { $colour = 'red'; $class = 'highlight'; $text_colour = 'red'; }

    my $prefix = $dbc->barcode_prefix('Plate');

    # Why is this necessary ?
    #
    #    if (defined $include) {
    #	unless ($include =~ /\b$plate_id\b/) { return };
    #    }

    my $tables = '(Plate,Library,Plate_Format,Employee,Rack';
    my @fields = (
        'Plate_ID', 'Plate.FK_Library__Name', 'Plate_Format_Type', 'Plate_Created', 'Initials', 'Parent_Quadrant', 'Plate.Plate_Number', 'Rack_ID', 'Plate_Status', 'Failed', 'Plate_Test_Status', 'Plate_Size', 'Plate_Comments', 'Library_FullName',
        'Pipeline_Name', 'Pipeline_Code', 'FK_Branch__Code', 'Plate.FK_Sample_Type__ID', 'Plate_Label', 'Plate_Type', 'Plate.FKOriginal_Plate__ID as Original',
        'Plate_Parent_Well', 'FK_Plate_Format__ID', 'Current_Volume', 'Current_Volume_Units'
    );

    my $condition = "WHERE Plate.FK_Library__Name=Library_Name  AND Plate.FK_Plate_Format__ID=Plate_Format_ID AND Plate.FK_Employee__ID=Employee_ID AND Plate_ID in ($plate_id) and Plate.FK_Rack__ID = Rack_ID";

    if ( $Configs{source_tracking} ) {
        $tables    .= ",Original_Source";
        $condition .= " AND FK_Original_Source__ID=Original_Source_ID";
        push( @fields, 'Original_Source_Name' );
    }
    $tables .= ") LEFT JOIN Pipeline ON Plate.FK_Pipeline__ID=Pipeline_ID";

    my %data = $dbc->Table_retrieve( $tables, \@fields, $condition);

    my $source;
    if ($verbose) {
        ($source) = $dbc->Table_find( 'Sample,Plate_Sample,Plate', 'FK_Source__ID', "WHERE Plate.FKOriginal_Plate__ID = Plate_Sample.FKOriginal_Plate__ID AND FK_Sample__ID=Sample_ID AND Plate_ID IN ($plate_id)", -distinct => 1 );
    }

    unless ( $data{Plate_ID}[0] ) {
        $dbc->warning("Plate information incomplete for Plate $plate_id");
        $dbc->Table_retrieve( $tables, \@fields, $condition, -debug => $debug );
        return;
    }

    $plate_id = $data{Plate_ID}[0];

    my $lib = $data{FK_Library__Name}[0];

    my $format = $dbc->get_FK_info( 'FK_Plate_Format__ID', $data{FK_Plate_Format__ID}[0] );

    my ($created) = split ' ', convert_date( $data{Plate_Created}[0], 'Simple' );
    my $by                = $data{Initials}[0];
    my $num               = $data{Plate_Number}[0];
    my $quad              = $data{Parent_Quadrant}[0];
    my $rack              = alDente::Tools::alDente_ref( 'Rack', $data{Rack_ID}[0], -dbc => $dbc );    ## $dbc->get_FK_info('FK_Rack__ID',$data{Rack_ID}[0]);
    my $test_status       = $data{Plate_Test_Status}[0];
    my $status            = $data{Plate_Status}[0];
    my $failed            = $data{Failed}[0];
    my $size              = $data{Plate_Size}[0];
    my $comments          = $data{Plate_Comments}[0];
    my $lib_name          = $data{Library_FullName}[0] || $data{FK_Library__Name}[0];
    my $os_name           = $data{Original_Source_Name}[0];
    my $branch_name       = $data{FK_Branch__Code}[0];
    my $pipeline          = $data{Pipeline_Name}[0];
    my $pipeline_code     = $data{Pipeline_Code}[0];
    my $content_id        = $data{FK_Sample_Type__ID}[0];
    my $label             = $data{Plate_Label}[0];
    my $original_plate    = $data{Original}[0];
    my $plate_type        = $data{Plate_Type}[0];
    my $plate_parent_well = $data{Plate_Parent_Well}[0];
    my $qty               = $data{Current_Volume}[0] . ' ' . $data{Current_Volume_Units}[0];

    my ($content) = $dbc->Table_find( 'Sample_Type', 'Sample_Type', "WHERE Sample_Type_ID = $content_id" );
    if ( $qty =~ /[1-9]/ ) { $content .= " [$qty]" }

    if ( $rack =~ /exported/i ) {
        my @expTo = $dbc->Table_find( 'Prep,Plate_Prep', 'Prep_Comments', "WHERE FK_Prep__ID=Prep_ID AND Prep_Comments like 'To:%' AND FK_Plate__ID = $plate_id" );
        my $exp = $expTo[ scalar(@expTo) - 1 ];
        $rack .= " $exp";
    }

    ## find out which protocol (if any) in which this plate was created #
    my $protocol;
    if ( $Configs{protocol_tracking} ) {
        $protocol = alDente::Container::get_birth_protocol( -dbc => $dbc, -plate_id => $plate_id )->{protocol_name} if $plate_id;
        $protocol ||= '(created o/s protocol)';
    }

    my $name;
    my $suffix;

    my $lbr = "<br>";    ## define linebreak

    my $plate_name = "<B>";
    if   ( $Configs{library_tracking} ) { $plate_name .= "$lib-" }
    else                                { $plate_name .= " #" }      ## do not show library name...

    $plate_name .= "$num$quad</B>";
    $plate_name .= ".$branch_name" if ($branch_name);
    my $schedule = alDente::Container::get_plate_schedule_code( -dbc => $dbc, -plate_id => $plate_id );

    my $details;
    $details .= ' ' . b($plate_name) . $lbr;    
    $details .= "<B>'$label'</B>" . $lbr if $label;
    $details .= "<B>$content</B>" . $lbr if $content || $Configs{plateContent_tracking};
    $details .= "$format" . $lbr                    if $Configs{plate_tracking};
    $details .= "$protocol" . $lbr                  if $protocol && $Configs{protocol_tracking};
    $details .= "<B>Library:</B> $lib_name" . $lbr  if $verbose && $Configs{library_tracking};
    $details .= "<B>From OS: </B> $os_name" . $lbr  if $verbose && $Configs{source_tracking};
    $details .= "<B>Made:</B> $created, $by" . $lbr if $Configs{user_tracking};
    $details .= "<B>Current Pipeline:</B> $pipeline_code" .  '<br>' if $pipeline_code && $Configs{pipeline_tracking};

    $details .= '<BR>';

    my $edit_schedule = Link_To( $dbc->config('homelink'), "Edit", "&cgi_application=alDente::Container_App&rm=Display Edit Plate Schedule&Plate_ID=$plate_id" );
    $edit_schedule .= " " . Link_To( $dbc->config('homelink'), "Batch Edit", "&cgi_application=alDente::Container_App&rm=Display Edit Plate Schedule&Plate_ID=$all_plates" );
    $details .= "<B>Schedule: ($edit_schedule) </B>" . $schedule .  '<br>' if ( $Configs{pipeline_tracking} );

    $details .= "<B>Location:</B> $rack" . $lbr if $Configs{location_tracking};

    #    $details .= '<BR>';
    if ( $plate_type eq 'Tube' ) {
        my $additional_condition;
        $additional_condition .= " AND Well = '$plate_parent_well'" if $plate_parent_well;
        my ($sample_id) = $dbc->Table_find( 'Plate_Sample', 'FK_Sample__ID', "WHERE FKOriginal_Plate__ID = '$original_plate' $additional_condition" );
        $details .= "<B>Sample:</B> " . alDente::Tools::alDente_ref( 'Sample', $sample_id, -dbc => $dbc );
        $details .= '<BR>';
    }

    $details .= "SRC: " . alDente::Tools::alDente_ref( 'Source', $source, -dbc => $dbc ) .  '<br>' if $source;

    if ( $verbose && $plate_id !~ /,/ ) {
        ## this is slow and should only be generated if necessary... ## moved to below Ancestry (only for single plate page)
        # $details .= '<p ></p>' . alDente::Rack_Views::show_Relocation_History( 'Plate', $plate_id, -dbc => $dbc );
    }

    if ( $protocol eq 'Original Plate' ) { $border = "6 bordercolor=green"; }    ## recolour for ancestry view

    if ( alDente::Tray::exists_on_tray( $dbc, 'Plate', $plate_id ) ) {
        ## show tray positions ##
        my $tray = alDente::Tray->new( -dbc => $dbc, -plate_ids => $plate_id );
        if ($verbose) {
            $details .=  '<br>'
                . $dbc->Table_retrieve_display(
                'Plate_Tray', [ 'FK_Tray__ID AS TRA', 'Plate_Position AS Position' ],
                "WHERE FK_Plate__ID IN ($plate_id)",
                -title       => 'Tray Positions',
                -return_html => 1
                );
        }
        else {
            my @trays = $dbc->Table_find( 'Plate_Tray', 'FK_Tray__ID,Plate_Position', "WHERE FK_Plate__ID IN ($plate_id)" );
            foreach my $tray (@trays) {
                my ( $tray_id, $pos ) = split ',', $tray;
                $details .= "Tray $tray_id ($pos)<BR>";
            }
        }
    }

    if ($verbose) {
        ## show priority
        require alDente::Priority_Object_Views;
        my $priority_label = alDente::Priority_Object_Views::priority_label( -dbc => $dbc, -object => 'Plate', -id => $plate_id );
        if ($priority_label) { $details .= "<BR>$priority_label" }

        ## show process deviation
        my @pds = $dbc->Table_find( 'Process_Deviation_Object,Object_Class', 'FK_Process_Deviation__ID', "WHERE FK_Object_Class__ID = Object_Class_ID and Object_Class = 'Plate' and Object_ID in ($plate_id) " );
        if ( int(@pds) ) {
            require alDente::Process_Deviation_Views;
            my $deviation_label = alDente::Process_Deviation_Views::deviation_label( -dbc => $dbc, -deviation_ids => \@pds );
            $details .= '<BR>' . $deviation_label;
        }
    }

    $details .= '<hr>';

    $details .= alDente::Attribute_Views::show_Attributes( $dbc, 'Plate', $plate_id );

    ## Note: the class is used below to determine the label colour (based upon css classes defined in the custom_bootstrap.css file) ##

    if ( $test_status =~ /test/i ) {
        $colour = '#FFCCCC';    ## light red to indicate test plate
        $details .= "**<B>Test Plate</B>**";
        $class = 'test';
    }
    elsif ( $failed eq 'Yes' ) {
        $class = 'failed';
        my $fail_reasons = '';
        my %fail_info = $dbc->Table_retrieve( 'Fail,FailReason,Object_Class', [ 'Fail_ID', 'Fail.Comments' ], "WHERE FK_FailReason__ID=FailReason_ID AND Fail.FK_Object_Class__ID=Object_Class_ID AND Object_Class='Plate' AND Object_ID = $plate_id" );
        if ( exists $fail_info{Fail_ID}[0] ) {
            $fail_reasons = join ';', @{ $fail_info{Comments} };
            $colour = '#FF3333';    ## bright red to indicate failed plate
            $details .= "**<B>FAILED </B>$fail_reasons" . br();
        }
        else {
            $dbc->warning("Missing Fail reason");
        }
    }
    elsif ( $status eq 'Active' ) {
        $class = 'active';
    }
    elsif ( $status =~ /thrown out/i || $status =~ /inactive/i ) {
        $colour = '#BBBBBB';
        $class  = 'inactive';
    }
    elsif ( $status =~ /exported/i ) {
        $colour = '#DDDDDD';
        $class  = 'exported';
    }
    else {
        $class = 'undefined';
    }

    if ( $comments && $verbose && !$scanner_mode ) {
        $details .= "<B>Comments:</B> " . &truncate_string( -string => $comments, -length => 20, -tip => 'link' ) . br();
    }

    $details .= Link_To( $dbc->homelink() . 'cgi_application=alDente::Rack_App&rm=Storage+History&Table=Plate&ID=' . $plate_id, 'Show Relocation History' );

    if ( $type =~ /tip/i ) {
        $tip ||= $details;
    }
    else {
        $suffix = $details;
    }

    $link_label ||= "$prefix$plate_id";
    if ( $type =~ /tip/ ) { $link_label = "<Font color=$text_colour>$link_label</Font>" }

    $name .= Link_To( $dbc->config('homelink'), "$link_label", "&Scan=1&Barcode=$prefix$plate_id", -tooltip => $tip, -tooltip_placement => 'bottom' );    ## move tooltip to the bottom since it could get truncated above ...
    $name .= "$suffix";

    ## Deprecated usage ##
    ## separate table wrapper in case it is not necessary ##
    #    my $open_wrapper  = "<Table cellspacing=0 cellpadding=2 border=$border><TR><TD bgcolor='$colour' nowrap>";
    #    my $close_wrapper = "</TD></TR></Table>";
    #    return $open_wrapper . $name . $close_wrapper;       #                                                                                                      ## return table cell for label

    if ( $type =~ /table/i ) {
        return "<div class='$class'>\n$name</div>\n";                                                                                                            ## return table cell for label

        #        return $open_wrapper . $name . $close_wrapper;       #                                                                                                      ## return table cell for label
    }
    elsif ( $type =~ /tip/i ) {
        return $name;                                                                                                                                            ## return link with details showing up as tooltip
    }
    elsif ( $type =~ /details/i ) {
        return "<font size=-2>$details</font>";                                                                                                                  ## return simple text string containing plate details.
    }
}

################################################################
# Block of code generating rows (<TD>...</TD>) of plate labels.
# (requires calling code to include initial table and row tags)
#
# -Requires refactoring, but it works for now...
#
# (used by both Tube.pm, Library_Plate.pm
#
# Return: number of columns generated
#########################
sub show_trays {
#########################
    my %args     = filter_input( \@_, -args => 'dbc,plates' );
    my $dbc      = $args{-dbc};
    my $plates   = $args{-plates};
    my $detailed = $args{-detailed};                             ## show labels for individual wells in trays

    my $col      = 0;
    my $colspan  = 0;
    my $cols     = 6;
    my $max_rows = 4;                                            ## limit rows of plate_labels displayed to this many rows...
    my $rows     = 1;

    my @all_plates = split ',', $plates;
    my $num_plates = int(@all_plates);
    my $output;
    my %Tray;
    foreach my $plate (@all_plates) {
        ## if more than  one plate provide simple label for each plate scanned ##
        my ($tray_info) = $dbc->Table_find( 'Plate_Tray', 'FK_Tray__ID,Plate_Position', "WHERE FK_Plate__ID=$plate" );
        if ($tray_info) {
            my ( $tray_id, $position ) = split ',', $tray_info;
            push @{ $Tray{$tray_id}{pos} }, $position;
            if ( int( @{ $Tray{$tray_id}{pos} } ) > 1 ) {next}    ## skip labelling for additional wells on same tray
        }
    }
    $colspan ||= $col;

    my @trays;
    if (%Tray) {
        foreach my $key ( keys %Tray ) {
            my @positions = @{ $Tray{$key}{pos} };

            my $tray = alDente::Tools::alDente_ref( 'Tray', $key, -dbc => $dbc ) . " - <B>Tray Positions: $positions[0] .. $positions[-1]</B>";

            push @trays, $tray;
        }
    }

    if (@trays) { return "<div class='object-label'>\n" . 'Trays:' . Cast_List( -list => \@trays, -to => 'OL' ) . "</div>\n" }

    return;
}

########################################################
#
#
##########################
sub display_Plate_Prep_check {
##########################
    my %args    = &filter_input( \@_ );
    my $dbc     = $args{-dbc};
    my $plates  = $args{-ids};
    my $confirm = $args{-confirm};
    my $page;
    my @prep_records = $dbc->Table_find( 'Plate_Prep', 'FK_Prep__ID', "WHERE FK_Plate__ID IN ($plates)" );
    my $count = @prep_records;
    if ( $count && !$confirm ) {
        $page .= 'The following preps have been done on the plates to be deleted';
        $page .= $dbc->Table_retrieve_display( 'Plate_Prep', [ 'FK_Prep__ID', 'FK_Plate__ID', 'FK_Plate_Set__Number', 'FK_Solution__ID' ], "WHERE FK_Plate__ID IN ($plates)", -title => 'Prep Records', -return_html => 1 );
    }

    return $page;
}

###############################
sub display_plate_contents {
###############################
    my %args  = &filter_input( \@_ );
    my $Plate = $args{-Plate};
    my $id    = $args{-id};
    my $dbc   = $Plate->{dbc};

    if ( !$id ) {
        return;
    }

    my @fields = (
        "Concat('PLA',Plate_ID) AS Barcode",
        'FK_Tray__ID AS Tray',
        'Plate_Position AS Position',
        'Plate_ID',
        'Plate.FK_Library__Name AS Library',
        'External_Identifier AS External_ID',
        'Sample_Type.Sample_Type',
        'Source_Label',
        'Received_Date',
        'Original_Source_Type',
        'Taxonomy_Name AS Taxonomy',
        'Anatomic_Site_Alias AS Anatomic_Site',
        'Pathology_Alias AS Pathology',
        'Plate_Label',
        "Concat(Plate_Size, ' ', Plate_Format_Type) AS Container_Format",
        "Concat(Current_Volume, ' ', Current_Volume_Units) AS Volume",
    );
    my $tables = "(Plate, Plate_Sample, Sample, Source, Original_Source, Plate_Format, Sample_Type ) ";
    $tables .= " LEFT JOIN Taxonomy ON FK_Taxonomy__ID = Taxonomy_ID ";
    $tables .= " LEFT JOIN Anatomic_Site ON FK_Anatomic_Site__ID = Anatomic_Site_ID ";
    $tables .= " LEFT JOIN Pathology ON FK_Pathology__ID = Pathology_ID ";
    $tables .= " LEFT JOIN Plate_Tray ON FK_Plate__ID = Plate_ID ";

    my $condition = "WHERE Plate_Sample.FKOriginal_Plate__ID = Plate.FKOriginal_Plate__ID ";
    $condition .= " and Plate_Sample.FK_Sample__ID = Sample_ID and Sample.FK_Source__ID = Source_ID ";
    $condition .= " and Source.FK_Original_Source__ID = Original_Source_ID ";
    $condition .= " and Plate.FK_Plate_Format__ID = Plate_Format_ID ";
    $condition .= " and Plate.FK_Sample_Type__ID = Sample_Type_ID ";
    $condition .= " and Plate_ID in ( $id ) ";

    my $output = "";

    ## if tray - provide simple list of PLA values (which can be cut and pasted as needed)
    my %Tray_contents = $dbc->Table_retrieve( 'Plate,Plate_Tray', [ 'Plate_ID', 'Plate_Position' ], "WHERE FK_Plate__ID=Plate_ID AND Plate_ID IN ($id) ORDER BY Plate_Position" );
    my $tray_contents;
    if ( $Tray_contents{Plate_ID} ) {
        my $prefix = $dbc->barcode_prefix('Plate');
        my $prefix_list = join "<BR>$prefix", @{ $Tray_contents{Plate_ID} };
        my $id_list     = join '<BR>',               @{ $Tray_contents{Plate_ID} };
        my $pos_list    = join '<BR>',               @{ $Tray_contents{Plate_Position} };

        $tray_contents = create_tree(
            -tree => { "$prefix list" => Views::Table_Print( content => [ [ '<U><B>Position</B></U>', '<U><B>Barcodes</B></U>', '<U><B>IDs</B></U>' ], [ $pos_list, $prefix . $prefix_list, $id_list ] ], print => 0, width => 200 ) } );
    }

    my $result = $dbc->Table_retrieve_display(
        -title       => "Plate Contents",
        -return_html => 1,
        -table       => $tables,
        -fields      => \@fields,
        -condition   => $condition,
        -order       => 'FK_Tray__ID,Plate_Position,Plate_ID',
        -distinct    => 1,
        -excel_link  => 1,
    );

    my %colspan;
    $colspan{1}->{1} = 2;    ## set the Heading to span 2 columns
                             #$output .= &Views::Heading("Plate Contents:");
    $output .= &Views::Table_Print(
        content => [ [$result] ],
        spacing => 5,
        colspan => \%colspan,
        print   => 0
    );
    my $view = &Link_To( $dbc->config('homelink'), "View - Plate Contents", "&cgi_application=alDente::View_App&rm=Display&File=/opt/alDente/www/dynamic/views/$Configs{DATABASE}/Group/23/general/Plate_Contents.yml&Plate_ID=$id&Generate+Results=1" );

    $output = $tray_contents . $view . $output;
    return $output;
}

#############################
# Display the protocol tracking block
#############################
sub show_protocol_tracking {
#############################
    my %args                  = &filter_input( \@_, -args => 'dbc,plate_list,no_form,set,default_protocol,pipeline_id,next_pipeline_step,last_protocol,next_protocol_message' );
    my $dbc                   = $args{-dbc};
    my $plate_list            = $args{-plate_list};
    my $no_form               = $args{-no_form};
    my $set                   = $args{-set};
    my $default_protocol      = $args{-default_protocol};
    my $pipeline_id           = $args{-pipeline_id};
    my $next_pipeline_step    = $args{-next_pipeline_step};
    my $last_protocol         = $args{-last_protocol};
    my $next_protocol_message = $args{-next_protocol_message};

    my $protocol_block;

    $Current_Department ||= $dbc->config('Target_Department');
    my $group_type = $dbc->get_local('group_type');
    my @group_types;

    if ( $group_type && $Current_Department && defined $group_type->{$Current_Department} ) {
        @group_types = @{ $group_type->{$Current_Department} };
    }
    else {
        $dbc->warning("Type: $group_type or Dept: $Current_Department undef");
    }

    my @plate_protocols = alDente::Protocol::get_protocol_options( $dbc, -plate_id => $plate_list, -format => 'name', -debug => 0 );

    if ( grep /TechD/i, @group_types ) {
        my $prod_protocols = alDente::Protocol::get_protocols( -dbc => $dbc, -department => $Current_Department, -grp_type => 'Lab,Production', -grp_access => 'Admin', -status => 'Active' );
        if (@$prod_protocols) {
            $protocol_block .= choose_from_protocols( -dbc => $dbc, -protocol_type => 'Production Protocol', -default_protocol => $default_protocol, -plate_list => $plate_list, -set => $set, -protocol_list => $prod_protocols, -no_form => $no_form );
        }

        $protocol_block .= '<hr>';

        my $techD_development_protocols = $dbc->Security->get_accessible_items( -table => 'Lab_Protocol', -extra_condition => "Grp.Grp_Type = 'TechD' AND Grp_Access = 'Admin' AND Lab_Protocol_Status ='Under Development' " );
        $protocol_block .= choose_from_protocols(
            -dbc              => $dbc,
            -protocol_type    => 'Pending TechD Protocol',
            -default_protocol => $default_protocol,
            -plate_list       => $plate_list,
            -set              => $set,
            -protocol_list    => $techD_development_protocols,
            -no_form          => $no_form,
            -include_dev      => 1
        );

        $protocol_block .= '<hr>';

        my $techD_approved_protocols = $dbc->Security->get_accessible_items( -table => 'Lab_Protocol', -extra_condition => "Grp.Grp_Type = 'TechD' AND Grp_Access = 'Admin' AND Lab_Protocol_Status ='Active' " );
        $protocol_block
            .= choose_from_protocols( -dbc => $dbc, -protocol_type => 'Approved TechD Protocol', -default_protocol => $default_protocol, -plate_list => $plate_list, -set => $set, -protocol_list => $techD_approved_protocols, -no_form => $no_form );

        $protocol_block .= '<hr>';
    }
    else {
        my $grp_protocols = $dbc->Security->get_accessible_items( -table => 'Lab_Protocol', -extra_condition => "Lab_Protocol_Status = 'Active'" );
        $protocol_block .= choose_from_protocols( -dbc => $dbc, -protocol_type => 'Lab Protocol', -default_protocol => $default_protocol, -plate_list => $plate_list, -set => $set, -protocol_list => $grp_protocols, -no_form => $no_form );
    }

    ## display the pipeline graph
    if ( $pipeline_id && !$dbc->mobile ) {
        my $pipeline_obj = alDente::Pipeline->new( -pipeline => $pipeline_id, -dbc => $dbc );
        $protocol_block .= $pipeline_obj->display_pipeline( -no_action => 1, -highlight_pipeline_step => $next_pipeline_step );

        $last_protocol = "-" if ( !$last_protocol );

        #        if ( !$next_protocol ) {                                                                          # display text message
        $protocol_block .= "<p ></p>Last Protocol: $last_protocol</p>";
        $protocol_block .= "<p ></p>Next Protocol: $next_protocol_message</p> ";

        #        }
    }

    return $protocol_block;
}

############################
sub choose_from_protocols {
############################
    my %args             = &filter_input( \@_ );
    my $dbc              = $args{-dbc};
    my $plate_list       = $args{-plate_list};
    my $set              = $args{-set};
    my $protocol_type    = $args{-protocol_type} || 'Lab Protocol';
    my $protocol_list    = $args{-protocol_list};
    my $default_protocol = $args{-default_protocol};
    my $no_form          = $args{-no_form};
    my $include_dev      = $args{-include_dev};                       # flag to include under development protocols ( should be for TechD only )
    my $debug            = $args{-debug};

    my $protocol_block;

    if ( $protocol_list && !@$protocol_list ) { return $protocol_block . "<h3>No $protocol_type options available</h3><B>[If expected protocol is not listed, ensure you are in the correct Department layer]</B>" }

    my @group_types = @{ $dbc->get_local('group_type')->{$Current_Department} };
    my @plate_protocols = alDente::Protocol::get_protocol_options( $dbc, -plate_id => $plate_list, -format => 'name', -include_dev => $include_dev, -debug => $debug );
    if ($debug) { print HTML_Dump "plate protocols:", \@plate_protocols }

    ## show production protocols only
    if ( !$no_form ) {
        $protocol_block .= alDente::Form::start_alDente_form( -dbc => $dbc, -name => 'start_protocol', -type => 'plate' );
        $protocol_block .= hidden( -name => 'Plate_Set_Number', -value => $set );
        $protocol_block .= hidden( -name => 'Plate_IDs', -value => $plate_list, -force => 1 );

        $protocol_block .= set_validator( -name => 'Production Protocol', -mandatory => 1 );
    }
    else {
        ## plate_ids & set included already in choose_set method ...
    }

    my ($protocol_ref) = RGmath::intersection( $protocol_list, \@plate_protocols );

    my @protocols = @$protocol_ref;
    if ( !@protocols ) {
        $dbc->message("No $protocol_type options for current Group + Format");

        # print HTML_Dump "No common protocols for Grp + Format:", \@grp_protocols,\@plate_protocols;
    }

    if ( int(@protocols) == 1 ) { $default_protocol = $protocols[0] }

    $protocol_block
        .= "<B>Protocol:</B> "
        . $BS->dropdown( -name => $protocol_type, -id => "$protocol_type.id", -value => [ '', @protocols ], -force => 1, -default => $default_protocol )
        . "<BR><B>[If expected protocol is not listed, ensure you are in the correct Department layer]</B>"
        . &vspace(10);

    $protocol_block .= $q->submit(
        -name    => 'rm',
        -value   => "Continue with $protocol_type",
        -class   => "Std",
        -onClick => "document.getElementById('$protocol_type.id').setAttribute('mandatory',1); return validateForm(this.form);",
        -mobile  => 1
        )
        . hidden( -name => 'cgi_application', -value => 'alDente::Prep_App', -force => 1 )

        #        . set_validator(-name=>"$protocol_type", -mandatory=>1, -force=>1, -case_name=>'rm', -case_value=>"Continue with $protocol_type")
        . &hspace(10);

    if ( !$dbc->mobile() ) {
        ## Ensure no batch edit option available when on the scanner
        $protocol_block .= $q->checkbox( -name => "Batch_Edit $protocol_type", -force => 1, -value => 'Batch Execute' );    # does not make sense to allow this
        $protocol_block .= hspace(10);
        $protocol_block .= checkbox( -name => "Enable Dynamic Text Fields for $protocol_type", -force => 1, -checked => 1 );    # does not make sense to allow this
        $protocol_block .= &vspace(10);
    }
    if ( !$no_form ) { $protocol_block .= end_form() }

    return $protocol_block;
}

############################
# Display the protocol dropdown list and the "Continue Prep" button
############################
sub show_protocol_dropdown {
############################
    my %args            = &filter_input( \@_, -args => 'table,no_form,preset,grp_protocols,plate_protocols,type,default,batch_edit' );
    my $table           = $args{-table};
    my $no_form         = $args{-no_form};
    my $preset          = $args{-preset};
    my $grp_protocols   = $args{-grp_protocols};
    my $plate_protocols = $args{-plate_protocols};
    my $type            = $args{-type};
    my $default         = $args{-default};
    my $batch_edit      = $args{-batch_edit};
    my $dbc             = $args{-dbc};

    my $start_form = '';
    my $end_form   = '';
    if ( !$no_form ) {
        $start_form = alDente::Form::start_alDente_form( -dbc => $dbc, -name => "start_protocol_$type", -type => 'plate' );
        $start_form .= $preset;
        $end_form = end_form() if ( !$no_form );
    }

    my $batch_edit_spec;
    if ($batch_edit) {
        unless ($scanner_mode) {
            ## Ensure no batch edit option available when on the scanner
            $batch_edit_spec = checkbox( -name => 'Batch_Edit', -value => 'Batch Execute' ) . &vspace(10);    # does not make sense to allow this
        }
    }

    my ($protocol_ref) = RGmath::intersection( $grp_protocols, $plate_protocols );
    my @protocols = @$protocol_ref;
    if ( !@protocols ) {
        $table->Set_Row( [ "<B>$type Protocol:</B> ", "No $type protocols common for current Group + Format" ] );
    }
    else {
        if ( int(@protocols) == 1 ) { $default = $protocols[0] }
        my $onClick = '';
        if ($no_form) {                                                                                       # clear param 'Protocol' if no separate form for each 'Continue Prep' button
            $onClick = "var list = document.getElementById('Continue_Prep_Protocol_$type'); var i = list.selectedIndex; var options = list.options; var field = document.getElementById('param_protocol'); field.value = options[i].value;";
        }

        $table->Set_Row(
            [   "<B>$type Protocol:</B> ",
                $start_form . $q->popup_menu( -id => "Continue_Prep_Protocol_$type", -name => "Protocol_$type", -value => [ '', @protocols ], -force => 1, -default => $default ) . $batch_edit_spec,
                submit( -name => 'Continue Prep', -class => "Std", -onClick => $onClick, -force => 1 ) . $end_form
            ]
        );
    }
}

###############################
# Description:
#	- Displays the resolve ambiguous funding page
#
# <snip>
#	Usage example:
#		my $page = alDente::Container_Views::display_resolve_ambiguous_funding( -dbc => $dbc, -work_request => \%library_fundings );
#
#	Return:
#		HTML page
# </snip>
###############################
sub display_resolve_ambiguous_funding {
###############################
    my %args          = filter_input( \@_, -args => 'dbc,work_request' );
    my $dbc           = $args{-dbc};
    my $work_requests = $args{-work_request};                               # hash ref.
                                                                            # $work_request{$library_name}{plates} = \@plate_ids
                                                                            # $work_request{$library_name}{work_requests} = \@work_request_ids
    my @plates;
    my $table = HTML_Table->new();
    $table->Set_Title('Pick Work Request with Valid Funding');
    $table->Set_Headers( [ 'Library', 'Plate ID', 'Work Request' ] );

    foreach my $lib ( keys %$work_requests ) {
        my %labels;
        foreach my $wr ( @{ $work_requests->{$lib}{work_requests} } ) {
            $labels{$wr} = $dbc->get_FK_info( -field => 'FK_Work_Request__ID', -id => $wr );
        }
        my $plate_list = join ',', @{ $work_requests->{$lib}{plates} };
        $table->Set_Row( [ "$lib", $plate_list, popup_menu( -name => "Work_Request", -value => $work_requests->{$lib}{work_requests}, -labels => \%labels, -force => 1 ) ] );
        push @plates, @{ $work_requests->{$lib}{plates} };
    }
    my $libraries = join ',', keys %$work_requests;
    my $plates    = join ',', @plates;

    my $output = alDente::Form::start_alDente_form( $dbc, 'Resolve Funding' );
    $output .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );
    $output .= hidden( -name => 'Library',         -value => $libraries,               -force => 1 );
    $output .= hidden( -name => 'Plate_ID',        -value => $plates,                  -force => 1 );
    $output .= $table->Printout(0);
    $output .= submit( -name => 'rm', -value => 'Resolve Funding', -class => 'Action', -force => 1 );
    $output .= end_form();

    return $output;
}

############################
#
# Display failed plates and ask user to confirm include the failed plates or not
#
############################
sub prompt_to_confirm_transfer_failed_plate {
############################
    my %args    = filter_input( \@_, -args => 'dbc,current,failed,action,query' );
    my $dbc     = $args{-dbc};
    my $current = $args{-current};                                                   # current list of plates
    my $failed  = $args{-failed};                                                    # array ref of failed plate ids
    my $action  = $args{-action};
    my $old_q   = $args{-query};

    my $page = alDente::Form::start_alDente_form( $dbc, 'verify' );
    if ($failed) {
        my $failed_count = int(@$failed);
        my $failed_ids = join ',', @$failed;
        $page .= "<font class=panel-title>$failed_count Plate(s) are Failed: </font>";
        $page .= $dbc->Table_retrieve_display(
            'Plate LEFT JOIN Plate_Tray ON Plate_Tray.FK_Plate__ID = Plate_ID', [ 'Plate_ID', 'FK_Library__Name', 'Plate_Status', 'Failed', 'Plate_Position' ], "WHERE Plate_ID in ($failed_ids)",
            -title       => "Failed Plate",
            -return_html => 1
        );

        $page .= "<BR><font class=text-danger>";

        ############## comment out the following block so not to let user have a choice to aliquot/transfer a failed plate #################
        #$page .= "Warning: if 'Include Failed' is chosen, the newly generated daughter plate of a Failed plate will become Active and NOT Failed!<BR>";
        #$page .= "</font>" . vspace();
        #$page .= $q->submit( -name => 'Continue Transfer Plate', -value => "Exclude Failed", -force => 1, -class => 'Action' );
        #$page .= hspace(5) . $q->submit( -name => 'Continue Transfer Plate', -value => "Include Failed", -force => 1, -class => 'Action' );

        $page .= "The above Failed plates will be excluded!<BR>";
        $page .= "</font>" . vspace();
        $page .= $q->submit( -name => 'Continue_Action', -value => "Continue $action", -force => 1, -class => 'Action' );
        $page .= $q->hidden( -name => 'Continue Transfer Plate', -value => "Exclude Failed", -force => 1 );

        $page .= $q->hidden( -name => 'Failed_Plate',   -value => $failed_ids, -force => 1 );
        $page .= $q->hidden( -name => 'Current Plates', -value => $current,    -force => 1 );

        ## append all the params from the previous query
        my @names = $old_q->param;
        foreach my $name (@names) {

            #if( $name eq 'rm' || $name eq 'cgi_application' ) { next }		## keep the same cgi_application and rm
            if ( $name eq 'Current Plates' ) {next}    ## don't use the current plates param from the previous page
            my @values = $old_q->param($name);         # treat it as multivalued
            $page .= $q->hidden( -name => $name, -value => \@values, -force => 1 );
        }
    }

    $page .= end_form();
    return $page;

}

############################################
# Display Throw Away Plate button
#
# Return: HTML page
############################################
sub display_throw_away_btn {
##############################
    my %args      = filter_input( \@_, -args => 'dbc' );
    my $dbc       = $args{-dbc};                           # the database connection
    my $from_view = $args{-from_view};                     # A parameter that needs to be set if this button is being used in a view. If it is from a view, the run mode will be handled via sub_cgi_app
    my $confirmed = $args{-confirmed};

    my $page;
    my $onclick;
    if ($from_view) {
        $page .= hidden( -id => 'sub_cgi_application', -force => 1 );
        $page .= hidden( -name => 'RUN_CGI_APP', -value => 'AFTER', -force => 1 );
        $onclick = "sub_cgi_app( 'alDente::Container_App')";
    }
    else {
        $page .= hidden( -name => 'cgi_application', -value => 'alDente::Container_App', -force => 1 );
    }

    $page .= Show_Tool_Tip( submit( -name => 'rm', -value => 'Throw Away Plate', -class => 'Action', -onClick => "$onclick", -force => 1 ), "Throw away selected containers" );

    if ($confirmed) { $page .= hidden( -name => 'Confirmed', -value => $confirmed, -force => 1 ) }

    return $page;

}

return 1;
